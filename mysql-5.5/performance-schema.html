<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Chapter 20. MySQL Performance Schema</title><link rel="stylesheet" href="mysql-html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.69.1"><link rel="start" href="index.html" title="MySQL 5.5 Reference Manual"><link rel="up" href="index.html" title="MySQL 5.5 Reference Manual"><link rel="prev" href="information-schema.html" title="Chapter 19. INFORMATION_SCHEMA Tables"><link rel="next" href="connectors-apis.html" title="Chapter 21. Connectors and APIs">
<script language="javascript" type="text/javascript">
  function addOnload(theFunc)
  {
    var previous = window.onload;
    if (typeof window.onload != 'function')
    {
      window.onload = theFunc;
    }
    else
    {
      window.onload = function()
      {
        previous();
        theFunc();
      }
    }
  }

  addOnload(function()
  {
    var base = new Date(1328790650*1000);
    var now = new Date();
    var diff = ((now-base)/1000)/(24*3600);

    if (diff > 90) {
      var nodes = document.getElementsByClassName('titlepage');
      nodes[0].innerHTML = '<p style="border: 5px #ff0000 solid; padding: 5px; margin 5px">' +
        'This copy of the manual is more than 90 days old. We encourage you to download a ' +
        'new version from <a href="http://dev.mysql.com">dev.mysql.com/doc</a>.</p>' + nodes[0].innerHTML;
    }
  });
</script>
<noscript></noscript>
</head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 20. MySQL Performance Schema</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="information-schema.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="connectors-apis.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="performance-schema"></a>Chapter 20. MySQL Performance Schema</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="performance-schema.html#performance-schema-quick-start">20.1. Performance Schema Quick Start</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-configuration">20.2. Performance Schema Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="performance-schema.html#performance-schema-build-configuration">20.2.1. Performance Schema Build Configuration</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-startup-configuration">20.2.2. Performance Schema Startup Configuration</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-runtime-configuration">20.2.3. Performance Schema Runtime Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="performance-schema.html#performance-schema-queries">20.3. Performance Schema Queries</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-instrument-naming">20.4. Performance Schema Instrument Naming Conventions</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-status-monitoring">20.5. Performance Schema Status Monitoring</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-table-characteristics">20.6. Performance Schema General Table Characteristics</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-table-descriptions">20.7. Performance Schema Table Descriptions</a></span></dt><dd><dl><dt><span class="section"><a href="performance-schema.html#performance-schema-setup-tables">20.7.1. Performance Schema Setup Tables</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-instance-tables">20.7.2. Performance Schema Instance Tables</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-waits-tables">20.7.3. Performance Schema Wait Event Tables</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-summary-tables">20.7.4. Performance Schema Summary Tables</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-miscellaneous-tables">20.7.5. Performance Schema Miscellaneous Tables</a></span></dt></dl></dd><dt><span class="section"><a href="performance-schema.html#performance-schema-system-variables">20.8. Performance Schema System Variables</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-status-variables">20.9. Performance Schema Status Variables</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-and-plugins">20.10. Performance Schema and Plugins</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-examples">20.11. Using the Performance Schema to Diagnose Problems</a></span></dt></dl></div><a class="indexterm" name="id1434177"></a><a class="indexterm" name="id1434186"></a><a class="indexterm" name="id1434195"></a><a class="indexterm" name="id1434207"></a><p>
    The MySQL Performance Schema is a feature for monitoring MySQL
    Server execution at a low level. The Performance Schema is available
    as of MySQL 5.5.3 and has these characteristics:
  </p><div class="itemizedlist"><ul type="disc"><li><p>
        The Performance Schema provides a way to inspect internal
        execution of the server at runtime. It is implemented using the
        <a href="performance-schema.html" title="Chapter 20. MySQL Performance Schema"><code class="literal">PERFORMANCE_SCHEMA</code></a> storage engine
        and the <code class="literal">performance_schema</code> database. The
        Performance Schema focuses primarily on performance data. This
        differs from <code class="literal">INFORMATION_SCHEMA</code>, which serves
        for inspection of metadata.
      </p></li><li><p>
        The Performance Schema monitors server events. An
        “<span class="quote">event</span>” is anything the server does that takes time
        and has been instrumented so that timing information can be
        collected. In general, an event could be a function call, a wait
        for the operating system, a stage of an SQL statement execution
        such as parsing or sorting, or an entire statement or group of
        statements. Currently, event collection provides access to
        information about synchronization calls (such as for mutexes)
        and file I/O calls for the server and for several storage
        engines.
      </p></li><li><p>
        Performance Schema events are distinct from events written to
        the server's binary log (which describe data modifications) and
        Event Scheduler events (which are a type of stored program).
      </p></li><li><p>
        Current events are available, as well as event histories and
        summaries. This enables you to determine how many times
        instrumented activities were performed and how much time they
        took. Event information is available to show the activities of
        specific threads, or activity associated with particular objects
        such as a mutex or file.
      </p></li><li><p>
        The <a href="performance-schema.html" title="Chapter 20. MySQL Performance Schema"><code class="literal">PERFORMANCE_SCHEMA</code></a> storage
        engine collects event data using “<span class="quote">instrumentation
        points</span>” in server source code.
      </p></li><li><p>
        Collected events are stored in tables in the
        <code class="literal">performance_schema</code> database. These tables can
        be queried using <a href="sql-syntax.html#select" title="12.2.9. SELECT Syntax"><code class="literal">SELECT</code></a>
        statements like other tables.
      </p></li><li><p>
        Performance Schema configuration can be modified dynamically by
        updating tables in the <code class="literal">performance_schema</code>
        database through SQL statements. Configuration changes affect
        data collection immediately.
      </p></li><li><p>
        Tables in the <code class="literal">performance_schema</code> database are
        views or temporary tables that use no persistent on-disk
        storage.
      </p></li><li><p>
        Monitoring is available on all platforms supported by MySQL.
      </p><p>
        Some limitations might apply: The types of timers might vary per
        platform. Instruments that apply to storage engines might not be
        implemented for all storage engines. Instrumentation of each
        third-party engine is the responsibility of the engine
        maintainer. See also
        <a href="restrictions.html#performance-schema-restrictions" title="E.8. Restrictions on Performance Schema">Section E.8, “Restrictions on Performance Schema”</a>.
      </p></li><li><p>
        Data collection is implemented by modifying the server source
        code to add instrumentation. There are no separate threads
        associated with the Performance Schema, unlike other features
        such as replication or the Event Scheduler.
      </p></li></ul></div><p>
    The Performance Schema is intended to provide access to useful
    information about server execution while having minimal impact on
    server performance. The implementation follows these design goals:
  </p><div class="itemizedlist"><ul type="disc"><li><p>
        Activating the Performance Schema causes no changes in server
        behavior. For example, it does not cause thread scheduling to
        change, and it does not cause query execution plans (as shown by
        <a href="sql-syntax.html#explain" title="12.8.2. EXPLAIN Syntax"><code class="literal">EXPLAIN</code></a>) to change.
      </p></li><li><p>
        No memory allocation is done beyond that which occurs during
        server startup. By using early allocation of structures with a
        fixed size, it is never necessary to resize or reallocate them,
        which is critical for achieving good runtime performance.
      </p></li><li><p>
        Server monitoring occurs continuously and unobtrusively with
        very little overhead. Activating the Performance Schema does not
        make the server unusable.
      </p></li><li><p>
        The parser is unchanged. There are no new keywords or
        statements.
      </p></li><li><p>
        Execution of server code proceeds normally even if the
        Performance Schema fails internally.
      </p></li><li><p>
        When there is a choice between performing processing during
        event collection initially or during event retrieval later,
        priority is given to making collection faster. This is because
        collection is ongoing whereas retrieval is on demand and might
        never happen at all.
      </p></li><li><p>
        It is easy to add new instrumentation points.
      </p></li><li><p>
        Instrumentation is versioned. If the instrumentation
        implementation changes, previously instrumented code will
        continue to work. This benefits developers of third-party
        plugins because it is not necessary to upgrade each plugin to
        stay synchronized with the latest Performance Schema changes.
      </p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-schema-quick-start"></a>20.1. Performance Schema Quick Start</h2></div></div></div><p>
      This section briefly introduces the Performance Schema with
      examples that show how to use it. For additional examples, see
      <a href="performance-schema.html#performance-schema-examples" title="20.11. Using the Performance Schema to Diagnose Problems">Section 20.11, “Using the Performance Schema to Diagnose Problems”</a>.
    </p><p>
      For the Performance Schema to be available, support for it must
      have been configured when MySQL was built. You can verify whether
      this is the case by checking the server's help output. If the
      Performance Schema is available, the output will mention several
      variables with names that begin with
      <code class="literal">performance_schema</code>:
    </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqld --verbose --help</code></strong>
...
  --performance_schema
                      Enable the performance schema.
  --performance_schema_events_waits_history_long_size=#
                      Number of rows in events_waits_history_long.
...
</pre><p>
      If such variables do not appear in the output, your server has not
      been built to support the Performance Schema. In this case, see
      <a href="performance-schema.html#performance-schema-configuration" title="20.2. Performance Schema Configuration">Section 20.2, “Performance Schema Configuration”</a>.
    </p><p>
      Assuming that the Performance Schema is available, it is disabled
      by default. To enable it, start the server with the
      <a href="performance-schema.html#sysvar_performance_schema"><code class="literal">performance_schema</code></a> variable
      enabled. For example, use these lines in your
      <code class="filename">my.cnf</code> file:
    </p><pre class="programlisting">[mysqld]
performance_schema</pre><p>
      When the server starts, it sees
      <a href="performance-schema.html#sysvar_performance_schema"><code class="literal">performance_schema</code></a> and attempts
      to initialize the Performance Schema. To verify successful
      initialization, use this statement:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'performance_schema';</code></strong>
+--------------------+-------+
| Variable_name      | Value |
+--------------------+-------+
| performance_schema | ON    |
+--------------------+-------+
</pre><p>
      A value of <code class="literal">ON</code> means that the Performance Schema
      initialized successfully and is ready for use. A value of
      <code class="literal">OFF</code> means that some error occurred. Check the
      server error log for information about what went wrong.
    </p><p>
      The Performance Schema is implemented as a storage engine. If this
      engine is available (which you should already have checked
      earlier), you should see it listed with a
      <code class="literal">SUPPORT</code> value of <code class="literal">YES</code> in the
      output from the
      <a href="information-schema.html#engines-table" title="19.6. The INFORMATION_SCHEMA ENGINES Table"><code class="literal">INFORMATION_SCHEMA.ENGINES</code></a> table or
      the <a href="sql-syntax.html#show-engines" title="12.7.5.17. SHOW ENGINES Syntax"><code class="literal">SHOW ENGINES</code></a> statement:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM INFORMATION_SCHEMA.ENGINES</code></strong>
    -&gt; <strong class="userinput"><code>WHERE ENGINE='PERFORMANCE_SCHEMA'\G</code></strong>
*************************** 1. row ***************************
      ENGINE: PERFORMANCE_SCHEMA
     SUPPORT: YES
     COMMENT: Performance Schema
TRANSACTIONS: NO
          XA: NO
  SAVEPOINTS: NO

mysql&gt; <strong class="userinput"><code>SHOW ENGINES\G</code></strong>
...
      Engine: PERFORMANCE_SCHEMA
     Support: YES
     Comment: Performance Schema
Transactions: NO
          XA: NO
  Savepoints: NO
...
</pre><p>
      The <a href="performance-schema.html" title="Chapter 20. MySQL Performance Schema"><code class="literal">PERFORMANCE_SCHEMA</code></a> storage engine
      operates on tables in the <code class="literal">performance_schema</code>
      database. You can make <code class="literal">performance_schema</code> the
      default database so that references to its tables need not be
      qualified with the database name:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>USE performance_schema;</code></strong>
</pre><p>
      Many examples in this chapter assume that
      <code class="literal">performance_schema</code> is the default database.
    </p><p>
      Performance Schema tables are stored in the
      <code class="literal">performance_schema</code> database. Information about
      the structure of this database and its tables can be obtained, as
      for any other database, by selecting from the
      <code class="literal">INFORMATION_SCHEMA</code> database or by using
      <a href="sql-syntax.html#show" title="12.7.5. SHOW Syntax"><code class="literal">SHOW</code></a> statements. For example, use
      either of these statements to see what Performance Schema tables
      exist:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES</code></strong>
    -&gt; <strong class="userinput"><code>WHERE TABLE_SCHEMA = 'performance_schema';</code></strong>
+----------------------------------------------+
| TABLE_NAME                                   |
+----------------------------------------------+
| cond_instances                               |
| events_waits_current                         |
| events_waits_history                         |
| events_waits_history_long                    |
| events_waits_summary_by_instance             |
| events_waits_summary_by_thread_by_event_name |
| events_waits_summary_global_by_event_name    |
| file_instances                               |
| file_summary_by_event_name                   |
| file_summary_by_instance                     |
| mutex_instances                              |
| performance_timers                           |
| rwlock_instances                             |
| setup_consumers                              |
| setup_instruments                            |
| setup_timers                                 |
| threads                                      |
+----------------------------------------------+

mysql&gt; <strong class="userinput"><code>SHOW TABLES FROM performance_schema;</code></strong>
+----------------------------------------------+
| Tables_in_performance_schema                 |
+----------------------------------------------+
| cond_instances                               |
| events_waits_current                         |
| events_waits_history                         |
...
</pre><p>
      The number of Performance Schema tables is expected to increase
      over time as implementation of additional instrumentation
      proceeds.
    </p><p>
      The name of the <code class="literal">performance_schema</code> database is
      lowercase, as are the names of tables within it. Queries should
      specify the names in lowercase.
    </p><div xmlns="http://www.w3.org/1999/xhtml" class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">Note</div><p xmlns="">
        Before MySQL 5.5.8, the table names were uppercase, which caused
        problems on some systems for certain values of the
        <a href="server-administration.html#sysvar_lower_case_table_names"><code class="literal">lower_case_table_names</code></a> system
        variable.
      </p></div><p>
      To see the structure of individual tables, use <code class="literal">SHOW
      CREATE TABLE</code>:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW CREATE TABLE setup_timers\G</code></strong>
*************************** 1. row ***************************
       Table: setup_timers
Create Table: CREATE TABLE `setup_timers` (
  `NAME` varchar(64) NOT NULL,
  `TIMER_NAME` enum('CYCLE','NANOSECOND','MICROSECOND','MILLISECOND','TICK')
   NOT NULL
) ENGINE=PERFORMANCE_SCHEMA DEFAULT CHARSET=utf8
</pre><p>
      Table structure is also available by selecting from tables such as
      <a href="information-schema.html#columns-table" title="19.4. The INFORMATION_SCHEMA COLUMNS Table"><code class="literal">INFORMATION_SCHEMA.COLUMNS</code></a> or by
      using statements such as <code class="literal">SHOW COLUMNS</code>.
    </p><p>
      Tables in the <code class="literal">performance_schema</code> database can
      be grouped according to the type of information in them: Current
      events, event histories and summaries, object instances, and setup
      (configuration) information. The following examples illustrate a
      few uses for these tables. For detailed information about the
      tables in each group, see
      <a href="performance-schema.html#performance-schema-table-descriptions" title="20.7. Performance Schema Table Descriptions">Section 20.7, “Performance Schema Table Descriptions”</a>.
    </p><p>
      To see what the server is doing at the moment, examine the
      <a href="performance-schema.html#events-waits-current-table" title="20.7.3.1. The events_waits_current Table"><code class="literal">events_waits_current</code></a> table. It
      contains one row per thread showing each thread's most recent
      monitored event:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM events_waits_current\G</code></strong>
*************************** 1. row ***************************
            THREAD_ID: 0
             EVENT_ID: 5523
           EVENT_NAME: wait/synch/mutex/mysys/THR_LOCK::mutex
               SOURCE: thr_lock.c:525
          TIMER_START: 201660494489586
            TIMER_END: 201660494576112
           TIMER_WAIT: 86526
                SPINS: NULL
        OBJECT_SCHEMA: NULL
          OBJECT_NAME: NULL
          OBJECT_TYPE: NULL
OBJECT_INSTANCE_BEGIN: 142270668
     NESTING_EVENT_ID: NULL
            OPERATION: lock
      NUMBER_OF_BYTES: NULL
                FLAGS: 0
...
</pre><p>
      This event indicates that thread 0 was waiting for 86,526
      picoseconds to acquire a lock on
      <code class="literal">THR_LOCK::mutex</code>, a mutex in the
      <code class="literal">mysys</code> subsystem. The first few columns provide
      the following information:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
          The ID columns indicate which thread the event comes from and
          the event number.
        </p></li><li><p>
          <code class="literal">EVENT_NAME</code> indicates what was instrumented
          and <code class="literal">SOURCE</code> indicates which source file
          contains the instrumented code.
        </p></li><li><p>
          The timer columns show when the event started and stopped and
          how long it took. If an event is still in progress, the
          <code class="literal">TIMER_END</code> and <code class="literal">TIMER_WAIT</code>
          values are <code class="literal">NULL</code>. Timer values are
          approximate and expressed in picoseconds. For information
          about timers and event time collection, see
          <a href="performance-schema.html#performance-schema-timing" title="20.2.3.1. Performance Schema Event Timing">Section 20.2.3.1, “Performance Schema Event Timing”</a>.
        </p></li></ul></div><p>
      The history tables contain the same kind of rows as the
      current-events table but have more rows and show what the server
      has been doing “<span class="quote">recently</span>” rather than
      “<span class="quote">currently.</span>” The
      <a href="performance-schema.html#events-waits-history-table" title="20.7.3.2. The events_waits_history Table"><code class="literal">events_waits_history</code></a> and
      <a href="performance-schema.html#events-waits-history-long-table" title="20.7.3.3. The events_waits_history_long Table"><code class="literal">events_waits_history_long</code></a> tables
      contain the most recent 10 events per thread and most recent
      10,000 events, respectively. For example, to see information for
      recent events produced by thread 13, do this:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT EVENT_ID, EVENT_NAME, TIMER_WAIT</code></strong>
    -&gt; <strong class="userinput"><code>FROM events_waits_history WHERE THREAD_ID = 13</code></strong>
    -&gt; <strong class="userinput"><code>ORDER BY EVENT_ID;</code></strong>
+----------+-----------------------------------------+------------+
| EVENT_ID | EVENT_NAME                              | TIMER_WAIT |
+----------+-----------------------------------------+------------+
|       86 | wait/synch/mutex/mysys/THR_LOCK::mutex  |     686322 |
|       87 | wait/synch/mutex/mysys/THR_LOCK_malloc  |     320535 |
|       88 | wait/synch/mutex/mysys/THR_LOCK_malloc  |     339390 |
|       89 | wait/synch/mutex/mysys/THR_LOCK_malloc  |     377100 |
|       90 | wait/synch/mutex/sql/LOCK_plugin        |     614673 |
|       91 | wait/synch/mutex/sql/LOCK_open          |     659925 |
|       92 | wait/synch/mutex/sql/THD::LOCK_thd_data |     494001 |
|       93 | wait/synch/mutex/mysys/THR_LOCK_malloc  |     222489 |
|       94 | wait/synch/mutex/mysys/THR_LOCK_malloc  |     214947 |
|       95 | wait/synch/mutex/mysys/LOCK_alarm       |     312993 |
+----------+-----------------------------------------+------------+
</pre><p>
      As new events are added to a history table, older events are
      discarded if the table is full.
    </p><p>
      Summary tables provide aggregate information for all events over
      time. The tables in this group summarize event data in different
      ways. To see which instruments have been executed the most times
      or have taken the most wait time, sort the
      <a href="performance-schema.html#event-wait-summary-tables" title="20.7.4.1. Event Wait Summary Tables"><code class="literal">events_waits_summary_global_by_event_name</code></a>
      table on the <code class="literal">COUNT_STAR</code> or
      <code class="literal">SUM_TIMER_WAIT</code> column, which correspond to a
      <code class="literal">COUNT(*)</code> or <code class="literal">SUM(TIMER_WAIT)</code>
      value, respectively, calculated over all events:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT EVENT_NAME, COUNT_STAR</code></strong>
    -&gt; <strong class="userinput"><code>FROM events_waits_summary_global_by_event_name</code></strong>
    -&gt; <strong class="userinput"><code>ORDER BY COUNT_STAR DESC LIMIT 10;</code></strong>
+---------------------------------------------------+------------+
| EVENT_NAME                                        | COUNT_STAR |
+---------------------------------------------------+------------+
| wait/synch/mutex/mysys/THR_LOCK_malloc            |       6419 |
| wait/io/file/sql/FRM                              |        452 |
| wait/synch/mutex/sql/LOCK_plugin                  |        337 |
| wait/synch/mutex/mysys/THR_LOCK_open              |        187 |
| wait/synch/mutex/mysys/LOCK_alarm                 |        147 |
| wait/synch/mutex/sql/THD::LOCK_thd_data           |        115 |
| wait/io/file/myisam/kfile                         |        102 |
| wait/synch/mutex/sql/LOCK_global_system_variables |         89 |
| wait/synch/mutex/mysys/THR_LOCK::mutex            |         89 |
| wait/synch/mutex/sql/LOCK_open                    |         88 |
+---------------------------------------------------+------------+

mysql&gt; <strong class="userinput"><code>SELECT EVENT_NAME, SUM_TIMER_WAIT</code></strong>
    -&gt; <strong class="userinput"><code>FROM events_waits_summary_global_by_event_name</code></strong>
    -&gt; <strong class="userinput"><code>ORDER BY SUM_TIMER_WAIT DESC LIMIT 10;</code></strong>
+----------------------------------------+----------------+
| EVENT_NAME                             | SUM_TIMER_WAIT |
+----------------------------------------+----------------+
| wait/io/file/sql/MYSQL_LOG             |     1599816582 |
| wait/synch/mutex/mysys/THR_LOCK_malloc |     1530083250 |
| wait/io/file/sql/binlog_index          |     1385291934 |
| wait/io/file/sql/FRM                   |     1292823243 |
| wait/io/file/myisam/kfile              |      411193611 |
| wait/io/file/myisam/dfile              |      322401645 |
| wait/synch/mutex/mysys/LOCK_alarm      |      145126935 |
| wait/io/file/sql/casetest              |      104324715 |
| wait/synch/mutex/sql/LOCK_plugin       |       86027823 |
| wait/io/file/sql/pid                   |       72591750 |
+----------------------------------------+----------------+
</pre><p>
      These results show that the <code class="literal">THR_LOCK_malloc</code>
      mutex is “<span class="quote">hot,</span>” both in terms of how often it is used
      and amount of time that threads wait attempting to acquire it.
    </p><div xmlns="http://www.w3.org/1999/xhtml" class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">Note</div><p xmlns="">
        The <code class="literal">THR_LOCK_malloc</code> mutex is used only in
        debug builds. In production builds it is not hot because it is
        nonexistent.
      </p></div><p>
      Instance tables document what types of objects are instrumented.
      An instrumented object, when used by the server, produces an
      event. These tables provide event names and explanatory notes or
      status information. For example, the
      <a href="performance-schema.html#file-instances-table" title="20.7.2.2. The file_instances Table"><code class="literal">file_instances</code></a> table lists instances
      of instruments for file I/O operations and their associated files:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM file_instances\G</code></strong>
*************************** 1. row ***************************
 FILE_NAME: /opt/mysql-log/60500/binlog.000007
EVENT_NAME: wait/io/file/sql/binlog
OPEN_COUNT: 0
*************************** 2. row ***************************
 FILE_NAME: /opt/mysql/60500/data/mysql/tables_priv.MYI
EVENT_NAME: wait/io/file/myisam/kfile
OPEN_COUNT: 1
*************************** 3. row ***************************
 FILE_NAME: /opt/mysql/60500/data/mysql/columns_priv.MYI
EVENT_NAME: wait/io/file/myisam/kfile
OPEN_COUNT: 1
...
</pre><p>
      Setup tables are used to configure and display monitoring
      characteristics. For example, to see which event timer is
      selected, query the <a href="performance-schema.html#setup-timers-table" title="20.7.1.3. The setup_timers Table"><code class="literal">setup_timers</code></a>
      tables:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM setup_timers;</code></strong>
+------+------------+
| NAME | TIMER_NAME |
+------+------------+
| wait | CYCLE      |
+------+------------+
</pre><p>
      <a href="performance-schema.html#setup-instruments-table" title="20.7.1.2. The setup_instruments Table"><code class="literal">setup_instruments</code></a> lists the set of
      instruments for which events can be collected and shows which of
      them are enabled:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM setup_instruments;</code></strong>
+------------------------------------------------------------+---------+-------+
| NAME                                                       | ENABLED | TIMED |
+------------------------------------------------------------+---------+-------+
...
| wait/synch/mutex/sql/LOCK_global_read_lock                 | YES     | YES   |
| wait/synch/mutex/sql/LOCK_global_system_variables          | YES     | YES   |
| wait/synch/mutex/sql/LOCK_lock_db                          | YES     | YES   |
| wait/synch/mutex/sql/LOCK_manager                          | YES     | YES   |
...
| wait/synch/rwlock/sql/LOCK_grant                           | YES     | YES   |
| wait/synch/rwlock/sql/LOGGER::LOCK_logger                  | YES     | YES   |
| wait/synch/rwlock/sql/LOCK_sys_init_connect                | YES     | YES   |
| wait/synch/rwlock/sql/LOCK_sys_init_slave                  | YES     | YES   |
...
| wait/io/file/sql/binlog                                    | YES     | YES   |
| wait/io/file/sql/binlog_index                              | YES     | YES   |
| wait/io/file/sql/casetest                                  | YES     | YES   |
| wait/io/file/sql/dbopt                                     | YES     | YES   |
...
</pre><p>
      To understand how to interpret instrument names, see
      <a href="performance-schema.html#performance-schema-instrument-naming" title="20.4. Performance Schema Instrument Naming Conventions">Section 20.4, “Performance Schema Instrument Naming Conventions”</a>.
    </p><p>
      To control whether events are collected for an instrument, set its
      <code class="literal">ENABLED</code> value to <code class="literal">YES</code> or
      <code class="literal">NO</code>. For example:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE setup_instruments SET ENABLED = 'NO'</code></strong>
    -&gt; <strong class="userinput"><code>WHERE NAME = 'wait/synch/mutex/sql/LOCK_mysql_create_db';</code></strong>
</pre><p>
      The Performance Schema uses collected events to update tables in
      the <code class="literal">performance_schema</code> database, which act as
      “<span class="quote">consumers</span>” of event information. The
      <a href="performance-schema.html#setup-consumers-table" title="20.7.1.1. The setup_consumers Table"><code class="literal">setup_consumers</code></a> table lists the
      available consumers and shows which of them are enabled:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM setup_consumers;</code></strong>
+----------------------------------------------+---------+
| NAME                                         | ENABLED |
+----------------------------------------------+---------+
| events_waits_current                         | YES     |
| events_waits_history                         | YES     |
| events_waits_history_long                    | YES     |
| events_waits_summary_by_thread_by_event_name | YES     |
| events_waits_summary_by_event_name           | YES     |
| events_waits_summary_by_instance             | YES     |
| file_summary_by_event_name                   | YES     |
| file_summary_by_instance                     | YES     |
+----------------------------------------------+---------+
</pre><p>
      To control whether the Performance Schema maintains a consumer as
      a destination for event information, set its
      <code class="literal">ENABLED</code> value.
    </p><p>
      For more information about the setup tables and how to use them to
      control event collection, see
      <a href="performance-schema.html#performance-schema-filtering" title="20.2.3.2. Performance Schema Event Filtering">Section 20.2.3.2, “Performance Schema Event Filtering”</a>.
    </p><p>
      There are some miscellaneous tables that do not fall into any of
      the previous groups. For example,
      <a href="performance-schema.html#performance-timers-table" title="20.7.5.1. The performance_timers Table"><code class="literal">performance_timers</code></a> lists the
      available event timers and their characteristics. For information
      about timers, see <a href="performance-schema.html#performance-schema-timing" title="20.2.3.1. Performance Schema Event Timing">Section 20.2.3.1, “Performance Schema Event Timing”</a>.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-schema-configuration"></a>20.2. Performance Schema Configuration</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="performance-schema.html#performance-schema-build-configuration">20.2.1. Performance Schema Build Configuration</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-startup-configuration">20.2.2. Performance Schema Startup Configuration</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-runtime-configuration">20.2.3. Performance Schema Runtime Configuration</a></span></dt></dl></div><p>
      To use the MySQL Performance Schema, these configuration
      considerations apply:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
          The Performance Schema must be configured into MySQL Server at
          build time to make it available. Performance Schema support is
          included in binary MySQL distributions. If you are building
          from source, you must ensure that it is configured into the
          build as described in
          <a href="performance-schema.html#performance-schema-build-configuration" title="20.2.1. Performance Schema Build Configuration">Section 20.2.1, “Performance Schema Build Configuration”</a>.
        </p></li><li><p>
          The Performance Schema must be enabled at server startup to
          enable event collection to occur. Specific Performance Schema
          features can be enabled at server startup or at runtime to
          control which types of event collection occur. See
          <a href="performance-schema.html#performance-schema-startup-configuration" title="20.2.2. Performance Schema Startup Configuration">Section 20.2.2, “Performance Schema Startup Configuration”</a>,
          <a href="performance-schema.html#performance-schema-runtime-configuration" title="20.2.3. Performance Schema Runtime Configuration">Section 20.2.3, “Performance Schema Runtime Configuration”</a>,
          and <a href="performance-schema.html#performance-schema-filtering" title="20.2.3.2. Performance Schema Event Filtering">Section 20.2.3.2, “Performance Schema Event Filtering”</a>.
        </p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-schema-build-configuration"></a>20.2.1. Performance Schema Build Configuration</h3></div></div></div><p>
        For the Performance Schema to be available, it must be
        configured into the MySQL server at build time. Binary MySQL
        distributions provided by Oracle Corporation are configured to
        support the Performance Schema. If you use a binary MySQL
        distribution from another provider, check with the provider
        whether the distribution has been appropriately configured.
      </p><p>
        If you build MySQL from a source distribution, enable the
        Performance Schema by running <span><strong class="command">CMake</strong></span> with the
        <a href="installing.html#option_cmake_storage_engine_options"><code class="option">WITH_PERFSCHEMA_STORAGE_ENGINE</code></a>
        option enabled:
      </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>cmake . -DWITH_PERFSCHEMA_STORAGE_ENGINE=1</code></strong>
</pre><p>
        Configuring MySQL with the
        <a href="installing.html#option_cmake_storage_engine_options"><code class="option">-DWITHOUT_PERFSCHEMA_STORAGE_ENGINE=1</code></a>
        option prevents inclusion of the Performance Schema, so if you
        want it included, do not use this option. See
        <a href="installing.html#source-configuration-options" title="2.9.4. MySQL Source-Configuration Options">Section 2.9.4, “MySQL Source-Configuration Options”</a>.
      </p><p>
        If you install MySQL over a previous installation that was
        configured without the Performance Schema (or with an older
        version of the Performance Schema that may not have all the
        current tables), run <a href="programs.html#mysql-upgrade" title="4.4.7. mysql_upgrade — Check Tables for MySQL Upgrade"><span><strong class="command">mysql_upgrade</strong></span></a> after
        starting the server to ensure that the
        <code class="literal">performance_schema</code> database exists with all
        current tables. Then restart the server. One indication that you
        need to do this is the presence of messages such as the
        following in the error log:
      </p><pre class="programlisting">[ERROR] Native table 'performance_schema'.'events_waits_history'
has the wrong structure
[ERROR] Native table 'performance_schema'.'events_waits_history_long'
has the wrong structure
...</pre><p>
        To verify whether a server was built with Performance Schema
        support, check its help output. If the Performance Schema is
        available, the output will mention several variables with names
        that begin with <code class="literal">performance_schema</code>:
      </p><pre class="programlisting">shell&gt; <strong class="userinput"><code>mysqld --verbose --help</code></strong>
...
  --performance_schema
                      Enable the performance schema.
  --performance_schema_events_waits_history_long_size=#
                      Number of rows in events_waits_history_long.
...
</pre><p>
        You can also connect to the server and look for a line that
        names the <a href="performance-schema.html" title="Chapter 20. MySQL Performance Schema"><code class="literal">PERFORMANCE_SCHEMA</code></a>
        storage engine in the output from <a href="sql-syntax.html#show-engines" title="12.7.5.17. SHOW ENGINES Syntax"><code class="literal">SHOW
        ENGINES</code></a>:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW ENGINES\G</code></strong>
...
      Engine: PERFORMANCE_SCHEMA
     Support: YES
     Comment: Performance Schema
Transactions: NO
          XA: NO
  Savepoints: NO
...
</pre><p>
        If the Performance Schema was not configured into the server at
        build time, no row for
        <a href="performance-schema.html" title="Chapter 20. MySQL Performance Schema"><code class="literal">PERFORMANCE_SCHEMA</code></a> will appear in
        the output from <a href="sql-syntax.html#show-engines" title="12.7.5.17. SHOW ENGINES Syntax"><code class="literal">SHOW ENGINES</code></a>. You
        might see <code class="literal">performance_schema</code> listed in the
        output from <a href="sql-syntax.html#show-databases" title="12.7.5.15. SHOW DATABASES Syntax"><code class="literal">SHOW DATABASES</code></a>, but
        it will have no tables and you will not be able to use it.
      </p><p>
        A line for <a href="performance-schema.html" title="Chapter 20. MySQL Performance Schema"><code class="literal">PERFORMANCE_SCHEMA</code></a> in
        the <a href="sql-syntax.html#show-engines" title="12.7.5.17. SHOW ENGINES Syntax"><code class="literal">SHOW ENGINES</code></a> output means
        that the Performance Schema is available, not that it is
        enabled. To enable it, you must do so at server startup, as
        described in the next section.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-schema-startup-configuration"></a>20.2.2. Performance Schema Startup Configuration</h3></div></div></div><p>
        The Performance Schema is disabled by default. To enable it,
        start the server with the
        <a href="performance-schema.html#sysvar_performance_schema"><code class="literal">performance_schema</code></a> variable
        enabled. For example, use these lines in your
        <code class="filename">my.cnf</code> file:
      </p><pre class="programlisting">[mysqld]
performance_schema</pre><p>
        When the server starts, it writes Performance Schema status
        information to the error log:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <code class="literal">Performance schema enabled</code> indicates
            successful initialization.
          </p></li><li><p>
            <code class="literal">Performance schema disabled (reason: start
            parameters)</code> indicates that you did not enable the
            Performance Schema by enabling the
            <a href="performance-schema.html#sysvar_performance_schema"><code class="literal">performance_schema</code></a>
            variable.
          </p></li><li><p>
            <code class="literal">Performance schema disabled (reason: init
            failed)</code> indicates that you enabled
            <a href="performance-schema.html#sysvar_performance_schema"><code class="literal">performance_schema</code></a> but some
            kind of error occurred that prevented the Performance Schema
            from initializing successfully. For example, you may have
            specified other Performance Schema variables with values too
            large for memory allocation to succeed.
          </p></li></ul></div><p>
        If the server is unable to allocate any internal buffer during
        Performance Schema initialization, the Performance Schema
        disables itself and sets
        <a href="performance-schema.html#sysvar_performance_schema"><code class="literal">performance_schema</code></a> to
        <code class="literal">OFF</code>, and the server runs without
        instrumentation.
      </p><p>
        The Performance Schema includes several system variables that
        provide configuration information:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'perf%';</code></strong>
+---------------------------------------------------+---------+
| Variable_name                                     | Value   |
+---------------------------------------------------+---------+
| performance_schema                                | ON      |
| performance_schema_events_waits_history_long_size | 10000   |
| performance_schema_events_waits_history_size      | 10      |
| performance_schema_max_cond_classes               | 80      |
| performance_schema_max_cond_instances             | 1000    |
| performance_schema_max_file_classes               | 50      |
| performance_schema_max_file_handles               | 32768   |
| performance_schema_max_file_instances             | 10000   |
| performance_schema_max_mutex_classes              | 200     |
| performance_schema_max_mutex_instances            | 1000000 |
| performance_schema_max_rwlock_classes             | 30      |
| performance_schema_max_rwlock_instances           | 1000000 |
| performance_schema_max_table_handles              | 100000  |
| performance_schema_max_table_instances            | 50000   |
| performance_schema_max_thread_classes             | 50      |
| performance_schema_max_thread_instances           | 1000    |
+---------------------------------------------------+---------+
</pre><p>
        The <a href="performance-schema.html#sysvar_performance_schema"><code class="literal">performance_schema</code></a> variable
        is <code class="literal">ON</code> or <code class="literal">OFF</code> to indicate
        whether the Performance Schema is enabled or disabled. The other
        variables indicate table sizes (number of rows) or memory
        allocation values.
      </p><a class="indexterm" name="id1435769"></a><a class="indexterm" name="id1435781"></a><div xmlns="http://www.w3.org/1999/xhtml" class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><div class="admon-title">Note</div><p xmlns="">
          With the Performance Schema enabled, the number of Performance
          Schema instances affects the server memory footprint, perhaps
          to a large extent. It may be necessary to tune the values of
          Performance Schema system variables to find the number of
          instances that balances insufficient instrumentation against
          excessive memory consumption.
        </p></div><p>
        To change the value of Performance Schema system variables, set
        them at server startup. For example, put the following lines in
        a <code class="filename">my.cnf</code> file to change the sizes of the
        history tables:
      </p><pre class="programlisting">[mysqld]
performance_schema
performance_schema_events_waits_history_size=20
performance_schema_events_waits_history_long_size=15000</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-schema-runtime-configuration"></a>20.2.3. Performance Schema Runtime Configuration</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="performance-schema.html#performance-schema-timing">20.2.3.1. Performance Schema Event Timing</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-filtering">20.2.3.2. Performance Schema Event Filtering</a></span></dt></dl></div><p>
        Performance Schema setup tables contain information about
        monitoring configuration:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES</code></strong>
    -&gt; <strong class="userinput"><code>WHERE TABLE_SCHEMA = 'performance_schema'</code></strong>
    -&gt; <strong class="userinput"><code>AND TABLE_NAME LIKE 'setup%';</code></strong>
+-------------------+
| TABLE_NAME        |
+-------------------+
| setup_consumers   |
| setup_instruments |
| setup_timers      |
+-------------------+
</pre><p>
        You can examine the contents of these tables to obtain
        information about Performance Schema monitoring characteristics.
        If you have the <a href="server-administration.html#priv_update"><code class="literal">UPDATE</code></a> privilege,
        you can change Performance Schema operation by modifying setup
        tables to affect how monitoring occurs. For additional details
        about these tables, see
        <a href="performance-schema.html#performance-schema-setup-tables" title="20.7.1. Performance Schema Setup Tables">Section 20.7.1, “Performance Schema Setup Tables”</a>.
      </p><p>
        To see which event timer is selected, query the
        <a href="performance-schema.html#setup-timers-table" title="20.7.1.3. The setup_timers Table"><code class="literal">setup_timers</code></a> tables:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM setup_timers;</code></strong>
+------+------------+
| NAME | TIMER_NAME |
+------+------------+
| wait | CYCLE      |
+------+------------+
</pre><p>
        The <code class="literal">NAME</code> value indicates the type of
        instrument to which the timer applies, and
        <code class="literal">TIMER_NAME</code> indicates which timer applies to
        those instruments. The timer applies to instruments where their
        name begins with a component matching the
        <code class="literal">NAME</code> value. Currently, there are only
        “<span class="quote">wait</span>” instruments, so this table has only one row
        and the timer applies to all instruments.
      </p><p>
        To change the timer, update the <code class="literal">NAME</code> value.
        For example, to use the <code class="literal">NANOSECOND</code> timer:
      </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE setup_timers SET TIMER_NAME = 'NANOSECOND'</code></strong>
    -&gt; <strong class="userinput"><code>WHERE NAME = 'wait';</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT * FROM setup_timers;</code></strong>
+------+------------+
| NAME | TIMER_NAME |
+------+------------+
| wait | NANOSECOND |
+------+------------+
</pre><p>
        For discussion of timers, see
        <a href="performance-schema.html#performance-schema-timing" title="20.2.3.1. Performance Schema Event Timing">Section 20.2.3.1, “Performance Schema Event Timing”</a>.
      </p><p>
        The <a href="performance-schema.html#setup-instruments-table" title="20.7.1.2. The setup_instruments Table"><code class="literal">setup_instruments</code></a> and
        <a href="performance-schema.html#setup-consumers-table" title="20.7.1.1. The setup_consumers Table"><code class="literal">setup_consumers</code></a> tables list the
        instruments for which events can be collected and the types of
        consumers for which event information actually is collected,
        respectively. <a href="performance-schema.html#performance-schema-filtering" title="20.2.3.2. Performance Schema Event Filtering">Section 20.2.3.2, “Performance Schema Event Filtering”</a>,
        discusses how you can modify these tables to affect event
        collection.
      </p><p>
        If there are Performance Schema configuration changes that must
        be made at runtime using SQL statements and you would like to
        these changes take effect each time the server starts, put the
        statements in a file and start the server with the
        <a href="server-administration.html#option_mysqld_init-file"><code class="option">--init-file=<em class="replaceable"><code>file_name</code></em></code></a>
        option. This strategy can also be useful if you have multiple
        monitoring configurations, each tailored to produce a different
        kind of monitoring, such as casual server health monitoring,
        incident investigation, application behavior troubleshooting,
        and so forth. Put the statements for each monitoring
        configuration into their own file and specify the appropriate
        file as the <a href="server-administration.html#option_mysqld_init-file"><code class="option">--init-file</code></a> argument
        when you start the server.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="performance-schema-timing"></a>20.2.3.1. Performance Schema Event Timing</h4></div></div></div><p>
          Events are collected by means of instrumentation added to the
          server source code. Instruments time events, which is how the
          Performance Schema provides an idea of how long events take.
          It is also possible to configure instruments not to collect
          timing information. This section discusses the available
          timers and their characteristics, and how timing values are
          represented in events.
        </p><p>
          Two tables provide timer information:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <a href="performance-schema.html#performance-timers-table" title="20.7.5.1. The performance_timers Table"><code class="literal">performance_timers</code></a> lists the
              available timers and their characteristics.
            </p></li><li><p>
              <a href="performance-schema.html#setup-timers-table" title="20.7.1.3. The setup_timers Table"><code class="literal">setup_timers</code></a> indicates which
              timers are used for which instruments.
            </p></li></ul></div><p>
          Each timer row in <a href="performance-schema.html#setup-timers-table" title="20.7.1.3. The setup_timers Table"><code class="literal">setup_timers</code></a>
          must refer to one of the timers listed in
          <a href="performance-schema.html#performance-timers-table" title="20.7.5.1. The performance_timers Table"><code class="literal">performance_timers</code></a>.
        </p><p>
          Timers vary in precision and the amount of overhead they
          involve. To see what timers are available and their
          characteristics, check the
          <a href="performance-schema.html#performance-timers-table" title="20.7.5.1. The performance_timers Table"><code class="literal">performance_timers</code></a> table:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_timers;</code></strong>
+-------------+-----------------+------------------+----------------+
| TIMER_NAME  | TIMER_FREQUENCY | TIMER_RESOLUTION | TIMER_OVERHEAD |
+-------------+-----------------+------------------+----------------+
| CYCLE       |      2389029850 |                1 |             72 |
| NANOSECOND  |            NULL |             NULL |           NULL |
| MICROSECOND |         1000000 |                1 |            585 |
| MILLISECOND |            1035 |                1 |            738 |
| TICK        |             101 |                1 |            630 |
+-------------+-----------------+------------------+----------------+
</pre><p>
          The <code class="literal">TIMER_NAME</code> column shows the names of
          the available timers. <code class="literal">CYCLE</code> refers to the
          timer that is based on the CPU (processor) cycle counter. If
          the values associated with a given timer name are
          <code class="literal">NULL</code>, that timer is not supported on your
          platform. The rows that do not have <code class="literal">NULL</code>
          indicate which timers you can use in
          <a href="performance-schema.html#setup-timers-table" title="20.7.1.3. The setup_timers Table"><code class="literal">setup_timers</code></a>.
        </p><p>
          <code class="literal">TIMER_FREQUENCY</code> indicates the number of
          timer units per second. For a cycle timer, the frequency is
          generally related to the CPU speed. The value shown was
          obtained on a system with a 2.4GHz processor. The other timers
          are based on fixed fractions of seconds. For
          <code class="literal">TICK</code>, the frequency may vary by platform
          (for example, some use 100 ticks/second, others 1000
          ticks/second).
        </p><p>
          <code class="literal">TIMER_RESOLUTION</code> indicates the number of
          timer units by which timer values increase at a time. If a
          timer has a resolution of 10, its value increases by 10 each
          time.
        </p><p>
          <code class="literal">TIMER_OVERHEAD</code> is the minimal number of
          cycles of overhead to obtain one timing with the given timer.
          The overhead per event is twice the value displayed because
          the timer is invoked at the beginning and end of the event.
        </p><p>
          To see which timer is in effect or to change the timer, access
          the <a href="performance-schema.html#setup-timers-table" title="20.7.1.3. The setup_timers Table"><code class="literal">setup_timers</code></a> table:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM setup_timers;</code></strong>
+------+------------+
| NAME | TIMER_NAME |
+------+------------+
| wait | CYCLE      |
+------+------------+

mysql&gt; <strong class="userinput"><code>UPDATE setup_timers SET TIMER_NAME = 'MICROSECOND'</code></strong>
    -&gt; <strong class="userinput"><code>WHERE NAME = 'wait';</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT * FROM setup_timers;</code></strong>
+------+-------------+
| NAME | TIMER_NAME  |
+------+-------------+
| wait | MICROSECOND |
+------+-------------+
</pre><p>
          By default, the Performance Schema uses the best timer
          available for each instrument type, but you can select a
          different one. Generally the best timer is
          <code class="literal">CYCLE</code>, which uses the CPU cycle counter
          whenever possible to provide high precision and low overhead.
        </p><p>
          The precision offered by the cycle counter depends on
          processor speed. If the processor runs at 1 GHz (one billion
          cycles/second) or higher, the cycle counter delivers
          sub-nanosecond precision. Using the cycle counter is much
          cheaper than getting the actual time of day. For example, the
          standard <code class="literal">gettimeofday()</code> function can take
          hundreds of cycles, which is an unacceptable overhead for data
          gathering that may occur thousands or millions of times per
          second.
        </p><p>
          Cycle counters also have disadvantages:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              End users expect to see timings in wall-clock units, such
              as fractions of a second. Converting from cycles to
              fractions of seconds can be expensive. For this reason,
              the conversion is a quick and fairly rough multiplication
              operation.
            </p></li><li><p>
              Processor cycle rate might change, such as when a laptop
              goes into power-saving mode or when a CPU slows down to
              reduce heat generation. If a processor's cycle rate
              fluctuates, conversion from cycles to real-time units is
              subject to error.
            </p></li><li><p>
              Cycle counters might be unreliable or unavailable
              depending on the processor or the operating system. For
              example, on Pentiums, the instruction is
              <code class="literal">RDTSC</code> (an assembly-language rather than
              a C instruction) and it is theoretically possible for the
              operating system to prevent user-mode programs from using
              it.
            </p></li><li><p>
              Some processor details related to out-of-order execution
              or multiprocessor synchronization might cause the counter
              to seem fast or slow by up to 1000 cycles.
            </p></li></ul></div><p>
          Currently, MySQL works with cycle counters on x386 (Windows,
          Mac OS X, Linux, Solaris, and other Unix flavors), PowerPC,
          and IA-64.
        </p><p>
          The <a href="performance-schema.html#setup-instruments-table" title="20.7.1.2. The setup_instruments Table"><code class="literal">setup_instruments</code></a> table has
          an <code class="literal">ENABLED</code> column to indicate the
          instruments for which to collect events. The table also has a
          <code class="literal">TIMED</code> column to indicate which instruments
          are timed. If an instrument is not enabled, it produces no
          events. If an enabled instrument is not timed, events produced
          by the instrument have <code class="literal">NULL</code> for the
          <code class="literal">TIMER_START</code>, <code class="literal">TIMER_END</code>,
          and <code class="literal">TIMER_WAIT</code> timer values. This in turn
          causes those values to be ignored when calculating the sum,
          minimum, maximum, and average time values in summary tables.
        </p><p>
          Within events, times are stored in picoseconds (trillionths of
          a second) to normalize them to a standard unit, regardless of
          which timer is selected. The timer used for an event is the
          one in effect when event timing begins. This timer is used to
          convert start and end values to picoseconds for storage in the
          event.
        </p><p>
          Modifications to the <a href="performance-schema.html#setup-timers-table" title="20.7.1.3. The setup_timers Table"><code class="literal">setup_timers</code></a>
          table affect monitoring immediately. Events already in
          progress use the original timer for the begin time and the new
          timer for the end time, which leads to unpredictable results.
          If you make timer changes, you may want to use
          <a href="sql-syntax.html#truncate-table" title="12.1.33. TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> to reset
          Performance Schema statistics.
        </p><p>
          The timer baseline (“<span class="quote">time zero</span>”) occurs at
          Performance Schema initialization during server startup.
          <code class="literal">TIMER_START</code> and
          <code class="literal">TIMER_END</code> values in events represent
          picoseconds since the baseline. <code class="literal">TIMER_WAIT</code>
          values are durations in picoseconds.
        </p><p>
          Picosecond values in events are approximate. Their accuracy is
          subject to the usual forms of error associated with conversion
          from one unit to another. If the <code class="literal">CYCLE</code>
          timer is used and the processor rate varies, there might be
          drift. For these reasons, it is not reasonable to look at the
          <code class="literal">TIMER_START</code> value for an event as an
          accurate measure of time elapsed since server startup. On the
          other hand, it is reasonable to use
          <code class="literal">TIMER_START</code> or
          <code class="literal">TIMER_WAIT</code> values in <code class="literal">ORDER
          BY</code> clauses to order events by start time or
          duration.
        </p><p>
          The choice of picoseconds in events rather than a value such
          as microseconds has a performance basis. One implementation
          goal was to show results in a uniform time unit, regardless of
          the timer. In an ideal world this time unit would look like a
          wall-clock unit and be reasonably precise; in other words,
          microseconds. But to convert cycles or nanoseconds to
          microseconds, it would be necessary to perform a division for
          every instrumentation. Division is expensive on many
          platforms. Multiplication is not expensive, so that is what is
          used. Therefore, the time unit is an integer multiple of the
          highest possible <code class="literal">TIMER_FREQUENCY</code> value,
          using a multiplier large enough to ensure that there is no
          major precision loss. The result is that the time unit is
          “<span class="quote">picoseconds.</span>” This precision is spurious, but
          the decision enables overhead to be minimized.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="performance-schema-filtering"></a>20.2.3.2. Performance Schema Event Filtering</h4></div></div></div><div class="toc"><dl><dt><span class="section"><a href="performance-schema.html#performance-schema-pre-filtering">20.2.3.2.1. Event Pre-Filtering</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-filtering-names">20.2.3.2.2. Naming Instruments or Consumers for Filtering Operations</a></span></dt></dl></div><a class="indexterm" name="id1436501"></a><a class="indexterm" name="id1436513"></a><a class="indexterm" name="id1436526"></a><p>
          Events are processed in a producer/consumer fashion:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              Instrumented code is the source for events and produces
              events to be collected. The
              <a href="performance-schema.html#setup-instruments-table" title="20.7.1.2. The setup_instruments Table"><code class="literal">setup_instruments</code></a> table lists
              the instruments for which events can be collected, whether
              they are enabled, and whether to collect timing
              information:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM setup_instruments;</code></strong>
+------------------------------------------------------------+---------+-------+
| NAME                                                       | ENABLED | TIMED |
+------------------------------------------------------------+---------+-------+
...
| wait/synch/mutex/sql/LOCK_global_read_lock                 | YES     | YES   |
| wait/synch/mutex/sql/LOCK_global_system_variables          | YES     | YES   |
| wait/synch/mutex/sql/LOCK_lock_db                          | YES     | YES   |
| wait/synch/mutex/sql/LOCK_manager                          | YES     | YES   |
...
| wait/synch/rwlock/sql/LOCK_grant                           | YES     | YES   |
| wait/synch/rwlock/sql/LOGGER::LOCK_logger                  | YES     | YES   |
| wait/synch/rwlock/sql/LOCK_sys_init_connect                | YES     | YES   |
| wait/synch/rwlock/sql/LOCK_sys_init_slave                  | YES     | YES   |
...
| wait/io/file/sql/binlog                                    | YES     | YES   |
| wait/io/file/sql/binlog_index                              | YES     | YES   |
| wait/io/file/sql/casetest                                  | YES     | YES   |
| wait/io/file/sql/dbopt                                     | YES     | YES   |
...
</pre></li><li><p>
              Performance Schema tables are the destinations for events
              and consume events. The
              <a href="performance-schema.html#setup-consumers-table" title="20.7.1.1. The setup_consumers Table"><code class="literal">setup_consumers</code></a> table lists
              the types of consumers to which event information can be
              sent:
            </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM setup_consumers;</code></strong>
+----------------------------------------------+---------+
| NAME                                         | ENABLED |
+----------------------------------------------+---------+
| events_waits_current                         | YES     |
| events_waits_history                         | YES     |
| events_waits_history_long                    | YES     |
| events_waits_summary_by_thread_by_event_name | YES     |
| events_waits_summary_by_event_name           | YES     |
| events_waits_summary_by_instance             | YES     |
| file_summary_by_event_name                   | YES     |
| file_summary_by_instance                     | YES     |
+----------------------------------------------+---------+
</pre></li></ul></div><p>
          Filtering can be done at different stages of performance
          monitoring:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <span class="bold"><strong>Pre-filtering.</strong></span> This is
              done by modifying Performance Schema configuration so that
              only certain types of events are collected from producers,
              and collected events update only certain consumers. This
              type of filtering is done by the Performance Schema and
              has a global effect that applies to all users.
            </p><p>
              Reasons to use pre-filtering:
            </p><div class="itemizedlist"><ul type="circle"><li><p>
                  Pre-filtering reduces overhead. The overhead should be
                  minimal even with all instruments enabled, but perhaps
                  you want to reduce it further. Or you do not care
                  about timing events and want to disable the timing
                  code to eliminate timing overhead.
                </p></li><li><p>
                  You can avoid filling the current-events or history
                  tables with events in which you have no interest.
                  Pre-filtering leaves more “<span class="quote">room</span>” in these
                  tables for instances of rows for enabled instrument
                  types. If you enable only file instruments with
                  pre-filtering, no rows are collected for nonfile
                  instruments. With post-filtering, nonfile events are
                  collected, leaving fewer rows for file events.
                </p></li><li><p>
                  You can avoid maintaining some kinds of event tables.
                  If you disable a consumer, the server does not spend
                  time maintaining it. For example, if you do not care
                  about event histories, you can disable the history
                  table consumers to improve performance.
                </p></li></ul></div></li><li><p>
              <span class="bold"><strong>Post-filtering.</strong></span> This
              involves the use of <code class="literal">WHERE</code> clauses in
              queries that select information from Performance Schema
              tables, to specify which of the available events you want
              to see. This type of filtering is performed on a per-user
              basis because individual users select which of the
              available events are of interest.
            </p><p>
              Reasons to use post-filtering:
            </p><div class="itemizedlist"><ul type="circle"><li><p>
                  To avoid making decisions for individual users about
                  which event information is of interest.
                </p></li><li><p>
                  To use the Performance Schema to investigate a
                  performance issue when the restrictions to impose
                  using pre-filtering are not known in advance.
                </p></li></ul></div></li></ul></div><p>
          The following sections provide more detail about pre-filtering
          and provide guidelines for naming instruments or consumers in
          filtering operations. For information about writing queries to
          retrieve information (post-filtering), see
          <a href="performance-schema.html#performance-schema-queries" title="20.3. Performance Schema Queries">Section 20.3, “Performance Schema Queries”</a>.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="performance-schema-pre-filtering"></a>20.2.3.2.1. Event Pre-Filtering</h5></div></div></div><p>
            Pre-filtering is done by modifying Performance Schema
            configuration so that only certain types of events are
            collected from producers, and collected events update only
            certain consumers. This type of filtering is done by the
            Performance Schema and has a global effect that applies to
            all users.
          </p><p>
            Pre-filtering can be applied to either the producer or
            consumer stage of event processing:
          </p><div class="itemizedlist"><ul type="disc"><li><p>
                To affect pre-filtering at the producer stage, modify
                the <a href="performance-schema.html#setup-instruments-table" title="20.7.1.2. The setup_instruments Table"><code class="literal">setup_instruments</code></a>
                table. An instrument can be enabled or disabled by
                setting its <code class="literal">ENABLED</code> value to
                <code class="literal">YES</code> or <code class="literal">NO</code>. An
                instrument can be configured whether to collect timing
                information by setting its <code class="literal">TIMED</code>
                value to <code class="literal">YES</code> or
                <code class="literal">NO</code>.
              </p></li><li><p>
                To affect pre-filtering at the consumer stage, modify
                the <a href="performance-schema.html#setup-consumers-table" title="20.7.1.1. The setup_consumers Table"><code class="literal">setup_consumers</code></a> table.
                A consumer can be enabled or disabled by setting its
                <code class="literal">ENABLED</code> value to
                <code class="literal">YES</code> or <code class="literal">NO</code>.
              </p></li></ul></div><p>
            Here are some examples that show the types of pre-filtering
            operations available:
          </p><div class="itemizedlist"><ul type="disc"><li><p>
                Disable all instruments:
              </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE setup_instruments SET ENABLED = 'NO';</code></strong>
</pre><p>
                Now no events will be collected. This change, like other
                pre-filtering operations, affects other users as well,
                even if they want to see event information.
              </p></li><li><p>
                Disable all file instruments, adding them to the current
                set of disabled instruments:
              </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE setup_instruments SET ENABLED = 'NO'</code></strong>
    -&gt; <strong class="userinput"><code>WHERE NAME LIKE 'wait/io/file/%';</code></strong>
</pre></li><li><p>
                Disable only file instruments, enable all other
                instruments:
              </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE setup_instruments</code></strong>
    -&gt; <strong class="userinput"><code>SET ENABLED = IF(NAME LIKE 'wait/io/file/%', 'NO', 'YES');</code></strong>
</pre><p>
                The preceding queries use the
                <a href="functions.html#operator_like"><code class="literal">LIKE</code></a> operator and the
                pattern <code class="literal">'wait/io/file/%'</code> to match all
                instrument names that begin with
                <code class="literal">'wait/io/file/</code>. For additional
                information about specifying patterns to select
                instruments, see
                <a href="performance-schema.html#performance-schema-filtering-names" title="20.2.3.2.2. Naming Instruments or Consumers for Filtering Operations">Section 20.2.3.2.2, “Naming Instruments or Consumers for Filtering Operations”</a>.
              </p></li><li><p>
                Enable all but those instruments in the
                <code class="literal">mysys</code> library:
              </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE setup_instruments</code></strong>
    -&gt; <strong class="userinput"><code>SET ENABLED = CASE WHEN NAME LIKE '%/mysys/%' THEN 'YES' ELSE 'NO' END;</code></strong>
</pre></li><li><p>
                Disable a specific instrument:
              </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE setup_instruments SET ENABLED = 'NO'</code></strong>
    -&gt; <strong class="userinput"><code>WHERE NAME = 'wait/synch/mutex/mysys/TMPDIR_mutex';</code></strong>
</pre></li><li><p>
                To toggle the state of an instrument,
                “<span class="quote">flip</span>” its <code class="literal">ENABLED</code>
                value:
              </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE setup_instruments</code></strong>
    -&gt; <strong class="userinput"><code>SET ENABLED = IF(ENABLED = 'YES', 'NO', 'YES')</code></strong>
    -&gt; <strong class="userinput"><code>WHERE NAME = 'wait/synch/mutex/mysys/TMPDIR_mutex';</code></strong>
</pre></li><li><p>
                Disable timing for all events:
              </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE setup_instruments SET TIMED = 'NO';</code></strong>
</pre></li></ul></div><p>
            Setting the <code class="literal">TIMED</code> column for instruments
            affects Performance Schema table contents as described in
            <a href="performance-schema.html#performance-schema-timing" title="20.2.3.1. Performance Schema Event Timing">Section 20.2.3.1, “Performance Schema Event Timing”</a>.
          </p><p>
            When you change the monitoring configuration, the
            Performance Schema does not flush the history tables. Events
            already collected remain in the current-events and history
            tables until displaced by newer events. If you disable
            instruments, you might need to wait a while before events
            for them are displaced by newer events of interest.
            Alternatively, use <a href="sql-syntax.html#truncate-table" title="12.1.33. TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE
            TABLE</code></a> to empty the history tables.
          </p><p>
            After making instrumentation changes, you might want to
            truncate the summary tables as well to clear aggregate
            information for previously collected events. The effect of
            <a href="sql-syntax.html#truncate-table" title="12.1.33. TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> for summary
            tables is to reset the summary columns to 0 or
            <code class="literal">NULL</code>, not to remove rows.
          </p><p>
            If you disable a consumer, the server does not spend time
            maintaining it. For example, you can disable the history
            table consumers if you do not care about historical event
            information:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE setup_consumers</code></strong>
    -&gt; <strong class="userinput"><code>SET ENABLED = 'NO' WHERE NAME LIKE '%history%';</code></strong>
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="performance-schema-filtering-names"></a>20.2.3.2.2. Naming Instruments or Consumers for Filtering Operations</h5></div></div></div><p>
            Names given for filtering operations can be as specific or
            general as required. To indicate a single instrument or
            consumer, specify its name in full:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE setup_instruments</code></strong>
    -&gt; <strong class="userinput"><code>SET ENABLED = 'NO'</code></strong>
    -&gt; <strong class="userinput"><code>WHERE NAME = 'wait/synch/mutex/myisammrg/MYRG_INFO::mutex';</code></strong>

mysql&gt; <strong class="userinput"><code>UPDATE setup_consumers</code></strong>
    -&gt; <strong class="userinput"><code>SET ENABLED = 'NO' WHERE NAME = 'file_summary_by_instance';</code></strong>
</pre><p>
            To specify a group of instruments or consumers, use a
            pattern that matches the group members:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>UPDATE setup_instruments</code></strong>
    -&gt; <strong class="userinput"><code>SET ENABLED = 'NO'</code></strong>
    -&gt; <strong class="userinput"><code>WHERE NAME LIKE 'wait/synch/mutex/%';</code></strong>

mysql&gt; <strong class="userinput"><code>UPDATE setup_consumers</code></strong>
    -&gt; <strong class="userinput"><code>SET ENABLED = 'NO' WHERE NAME LIKE '%history%';</code></strong>
</pre><p>
            If you use a pattern, it should be chosen so that it matches
            all the items of interest and no others. For example, to
            select all file I/O instruments, it is better to use a
            pattern that includes the entire instrument name prefix:
          </p><pre class="programlisting">... WHERE NAME LIKE 'wait/io/file/%';</pre><p>
            A pattern of <code class="literal">'%/file/%'</code> will match other
            instruments that have a component of
            <code class="literal">'/file/'</code> anywhere in the name. Even less
            suitable is the pattern <code class="literal">'%file%'</code> because
            it will match instruments with <code class="literal">'file'</code>
            anywhere in the name, such as
            <code class="literal">wait/synch/mutex/sql/LOCK_des_key_file</code>.
          </p><p>
            To check which instrument or consumer names a pattern
            matches, perform a simple test:
          </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT NAME FROM setup_instruments WHERE NAME LIKE '<em class="replaceable"><code>pattern</code></em>';</code></strong>

mysql&gt; <strong class="userinput"><code>SELECT NAME FROM setup_consumers WHERE NAME LIKE '<em class="replaceable"><code>pattern</code></em>';</code></strong>
</pre></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-schema-queries"></a>20.3. Performance Schema Queries</h2></div></div></div><p>
      Pre-filtering limits which event information is collected and is
      independent of any particular user. By contrast, post-filtering is
      performed by individual users through the use of queries with
      appropriate <code class="literal">WHERE</code> clauses that restrict what
      event information to select from the events available after
      pre-filtering has been applied.
    </p><p>
      In <a href="performance-schema.html#performance-schema-pre-filtering" title="20.2.3.2.1. Event Pre-Filtering">Section 20.2.3.2.1, “Event Pre-Filtering”</a>, an example
      showed how to pre-filter for file instruments. If the event tables
      contain both file and nonfile information, post-filtering is
      another way to see information only for file events. Add a
      <code class="literal">WHERE</code> clause to queries to restrict event
      selection appropriately:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT THREAD_ID, NUMBER_OF_BYTES</code></strong>
    -&gt; <strong class="userinput"><code>FROM events_waits_history</code></strong>
    -&gt; <strong class="userinput"><code>WHERE EVENT_NAME LIKE 'wait/io/file/%'</code></strong>
    -&gt; <strong class="userinput"><code>AND NUMBER_OF_BYTES IS NOT NULL;</code></strong>
+-----------+-----------------+
| THREAD_ID | NUMBER_OF_BYTES |
+-----------+-----------------+
|        11 |              66 |
|        11 |              47 |
|        11 |             139 |
|         5 |              24 |
|         5 |             834 |
+-----------+-----------------+
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-schema-instrument-naming"></a>20.4. Performance Schema Instrument Naming Conventions</h2></div></div></div><p>
      An instrument name consists of a sequence of components separated
      by <code class="literal">'/'</code> characters. Example names:
    </p><pre class="programlisting">wait/io/file/myisam/log
wait/io/file/mysys/charset
wait/synch/cond/mysys/COND_alarm
wait/synch/cond/sql/BINLOG::update_cond
wait/synch/mutex/mysys/BITMAP_mutex
wait/synch/mutex/sql/LOCK_delete
wait/synch/rwlock/innodb/trx_sys_lock
wait/synch/rwlock/sql/Query_cache_query::lock</pre><p>
      The instrument name space has a tree-like structure. The
      components of an instrument name from left to right provide a
      progression from more general to more specific. The number of
      components a name has depends on the type of instrument.
    </p><p>
      The interpretation of a given component in a name depends on the
      components to the left of it. For example,
      <code class="literal">myisam</code> appears in both of the following names,
      but <code class="literal">myisam</code> in the first name is related to file
      I/O, whereas in the second it is related to a synchronization
      instrument:
    </p><pre class="programlisting">wait/io/file/myisam/log
wait/synch/cond/myisam/MI_SORT_INFO::cond</pre><p>
      Instrument names consist of a prefix with a structure defined by
      the Performance Schema implementation and a suffix defined by the
      developer implementing the instrument code. The top-level
      component of an instrument prefix indicates the type of
      instrument. This component also determines which event timer in
      the <code class="literal">setup_timers</code> table applies to the
      instrument. For the prefix part of instrument names, the top level
      indicates the type of instrument.
    </p><p>
      The suffix part of instrument names comes from the code for the
      instruments themselves. Suffixes may include levels such as these:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
          A name for the major component (a server module such as
          <code class="literal">myisam</code>, <code class="literal">innodb</code>,
          <code class="literal">mysys</code>, or <code class="literal">sql</code>) or a
          plugin name.
        </p></li><li><p>
          The name of a variable in the code, in the form
          <em class="replaceable"><code>XXX</code></em> (a global variable) or
          <code class="literal"><em class="replaceable"><code>CCC</code></em>:<em class="replaceable"><code>MMM</code></em></code>
          (a member <em class="replaceable"><code>MMM</code></em> in class
          <em class="replaceable"><code>CCC</code></em>). Examples:
          <code class="literal">COND_thread_cache</code>,
          <code class="literal">THR_LOCK_myisam</code>,
          <code class="literal">BINLOG::LOCK_index</code>.
        </p></li></ul></div><p>
      In MySQL 5.5, there is a single top-level component,
      <code class="literal">wait</code>, indicating a wait instrument. The naming
      tree for wait instruments has this structure:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
          <code class="literal">wait/io</code>
        </p><p>
          An instrumented I/O operation.
        </p><div class="itemizedlist"><ul type="circle"><li><p>
              <code class="literal">wait/io/file</code>
            </p><p>
              An instrumented file I/O operation. For files, the wait is
              the time waiting for the file operation to complete (for
              example, a call to <code class="literal">fwrite()</code>). Due to
              caching, the physical file I/O on the disk might not
              happen within this call.
            </p></li></ul></div></li><li><p>
          <code class="literal">wait/sync</code>
        </p><p>
          An instrumented synchronization object. For synchronization
          objects, the <code class="literal">TIMER_WAIT</code> time includes the
          amount of time blocked while attempting to acquire a lock on
          the object, if any.
        </p><div class="itemizedlist"><ul type="circle"><li><p>
              <code class="literal">wait/sync/cond</code>
            </p><p>
              A condition is used by one thread to signal to other
              threads that something they were waiting for has happened.
              If a single thread was waiting for a condition, it can
              wake up and proceed with its execution. If several threads
              were waiting, they can all wake up and compete for the
              resource for which they were waiting.
            </p></li><li><p>
              <code class="literal">wait/sync/mutex</code>
            </p><p>
              A mutual exclusion object used to permit access to a
              resource (such as a section of executable code) while
              preventing other threads from accessing the resource.
            </p></li><li><p>
              <code class="literal">wait/sync/rwlock</code>
            </p><p>
              A read/write lock object used to lock a specific variable
              for access while preventing its use by other threads. A
              shared read lock can be acquired simultaneously by
              multiple threads. An exclusive write lock can be acquired
              by only one thread at a time.
            </p></li></ul></div></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-schema-status-monitoring"></a>20.5. Performance Schema Status Monitoring</h2></div></div></div><p>
      There are several status variables associated with the Performance
      Schema:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'perf%';</code></strong>
+------------------------------------------+-------+
| Variable_name                            | Value |
+------------------------------------------+-------+
| Performance_schema_cond_classes_lost     | 0     |
| Performance_schema_cond_instances_lost   | 0     |
| Performance_schema_file_classes_lost     | 0     |
| Performance_schema_file_handles_lost     | 0     |
| Performance_schema_file_instances_lost   | 0     |
| Performance_schema_locker_lost           | 0     |
| Performance_schema_mutex_classes_lost    | 0     |
| Performance_schema_mutex_instances_lost  | 0     |
| Performance_schema_rwlock_classes_lost   | 0     |
| Performance_schema_rwlock_instances_lost | 0     |
| Performance_schema_table_handles_lost    | 0     |
| Performance_schema_table_instances_lost  | 0     |
| Performance_schema_thread_classes_lost   | 0     |
| Performance_schema_thread_instances_lost | 0     |
+------------------------------------------+-------+
</pre><p>
      The Performance Schema status variables provide information about
      instrumentation that could not be loaded or created due to memory
      constraints. Names for these variables have several forms:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
          <code class="literal">Performance_schema_<em class="replaceable"><code>xxx</code></em>_classes_lost</code>
          indicates how many instruments of type
          <em class="replaceable"><code>xxx</code></em> could not be loaded.
        </p></li><li><p>
          <code class="literal">Performance_schema_<em class="replaceable"><code>xxx</code></em>_instances_lost</code>
          indicates how many instances of object type
          <em class="replaceable"><code>xxx</code></em> could not be created.
        </p></li><li><p>
          <code class="literal">Performance_schema_<em class="replaceable"><code>xxx</code></em>_handles_lost</code>
          indicates how many instances of object type
          <em class="replaceable"><code>xxx</code></em> could not be opened.
        </p></li><li><p>
          <code class="literal">Performance_schema_locker_lost</code> indicates
          how many events are “<span class="quote">lost</span>” or not recorded.
        </p></li></ul></div><p>
      For example, if a mutex is instrumented in the server source but
      the server cannot allocate memory for the instrumentation at
      runtime, it increments
      <a href="performance-schema.html#statvar_Performance_schema_xxx_classes_lost"><code class="literal">Performance_schema_mutex_classes_lost</code></a>.
      The mutex still functions as a synchronization object (that is,
      the server continues to function normally), but performance data
      for it will not be collected. If the instrument can be allocated,
      it can be used for initializing instrumented mutex instances. For
      a singleton mutex such as a global mutex, there will be only one
      instance. Other mutexes have an instance per connection, or per
      page in various caches and data buffers, so the number of
      instances varies over time. Increasing the maximum number of
      connections or the maximum size of some buffers will increase the
      maximum number of instances that might be allocated at once. If
      the server cannot create a given instrumented mutex instance, it
      increments
      <a href="performance-schema.html#statvar_Performance_schema_xxx_instances_lost"><code class="literal">Performance_schema_mutex_instances_lost</code></a>.
    </p><p>
      Suppose that the following conditions hold:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
          The server was started with the
          <a href="performance-schema.html#sysvar_performance_schema_max_mutex_classes"><code class="option">--performance_schema_max_mutex_classes=200</code></a>
          option and thus has room for 200 mutex instruments.
        </p></li><li><p>
          150 mutex instruments have been loaded already.
        </p></li><li><p>
          The plugin named <code class="literal">plugin_a</code> contains 40 mutex
          instruments.
        </p></li><li><p>
          The plugin named <code class="literal">plugin_b</code> contains 20 mutex
          instruments.
        </p></li></ul></div><p>
      The server allocates mutex instruments for the plugins depending
      on how many they need and how many are available, as illustrated
      by the following sequence of statements:
    </p><pre class="programlisting">INSTALL PLUGIN plugin_a</pre><p>
      The server now has 150+40 = 190 mutex instruments.
    </p><pre class="programlisting">UNINSTALL PLUGIN plugin_a;</pre><p>
      The server still has 190 instruments. All the historical data
      generated by the plugin code is still available, but new events
      for the instruments are not collected.
    </p><pre class="programlisting">INSTALL PLUGIN plugin_a;</pre><p>
      The server detects that the 40 instruments are already defined, so
      no new instruments are created, and previously assigned internal
      memory buffers are reused. The server still has 190 instruments.
    </p><pre class="programlisting">INSTALL PLUGIN plugin_b;</pre><p>
      The server has room for 200-190 = 10 instruments (in this case,
      mutex classes), and sees that the plugin contains 20 new
      instruments. 10 instruments are loaded, and 10 are discarded or
      “<span class="quote">lost.</span>” The
      <a href="performance-schema.html#statvar_Performance_schema_xxx_classes_lost"><code class="literal">Performance_schema_mutex_classes_lost</code></a>
      indicates the number of instruments (mutex classes) lost:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE "perf%mutex_classes_lost";</code></strong>
+---------------------------------------+-------+
| Variable_name                         | Value |
+---------------------------------------+-------+
| Performance_schema_mutex_classes_lost | 10    |
+---------------------------------------+-------+
1 row in set (0.10 sec)
</pre><p>
      The instrumentation still works and collects (partial) data for
      <code class="literal">plugin_b</code>.
    </p><p>
      When the server cannot create a mutex instrument, these results
      occur:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
          No row for the instrument is inserted into the
          <a href="performance-schema.html#setup-instruments-table" title="20.7.1.2. The setup_instruments Table"><code class="literal">setup_instruments</code></a> table.
        </p></li><li><p>
          <a href="performance-schema.html#statvar_Performance_schema_xxx_classes_lost"><code class="literal">Performance_schema_mutex_classes_lost</code></a>
          increases by 1.
        </p></li><li><p>
          <a href="performance-schema.html#statvar_Performance_schema_xxx_instances_lost"><code class="literal">Performance_schema_mutex_instances_lost</code></a>
          does not change. (When the mutex instrument is not created, it
          cannot be used to create instrumented mutex instances later.)
        </p></li></ul></div><p>
      The pattern just described applies to all types of instruments,
      not just mutexes.
    </p><p>
      A value of
      <a href="performance-schema.html#statvar_Performance_schema_xxx_classes_lost"><code class="literal">Performance_schema_mutex_classes_lost</code></a>
      greater than 0 can happen in two cases:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
          To save a few bytes of memory, you start the server with
          <a href="performance-schema.html#sysvar_performance_schema_max_mutex_classes"><code class="option">--performance_schema_max_mutex_classes=<em class="replaceable"><code>N</code></em></code></a>,
          where <em class="replaceable"><code>N</code></em> is less than the default
          value. The default value is chosen to be sufficient to load
          all the plugins provided in the MySQL distribution, but this
          can be reduced if some plugins are never loaded. For example,
          you might choose not to load some of the storage engines in
          the distribution.
        </p></li><li><p>
          You load a third-party plugin that is instrumented for the
          Performance Schema but do not allow for the plugin's
          instrumentation memory requirements when you start the server.
          Because it comes from a third party, the instrument memory
          consumption of this engine is not accounted for in the default
          value chosen for
          <a href="performance-schema.html#sysvar_performance_schema_max_mutex_classes"><code class="literal">performance_schema_max_mutex_classes</code></a>.
        </p><p>
          If the server has insufficient resources for the plugin's
          instruments and you do not explicitly allocate more using
          <a href="performance-schema.html#sysvar_performance_schema_max_mutex_classes"><code class="option">--performance_schema_max_mutex_classes=<em class="replaceable"><code>N</code></em></code></a>,
          loading the plugin leads to starvation of instruments.
        </p></li></ul></div><p>
      If the value chosen for
      <a href="performance-schema.html#sysvar_performance_schema_max_mutex_classes"><code class="literal">performance_schema_max_mutex_classes</code></a>
      is too small, no error is reported in the error log and there is
      no failure at runtime. However, the content of the tables in the
      <code class="literal">performance_schema</code> database will miss events.
      The
      <a href="performance-schema.html#statvar_Performance_schema_xxx_classes_lost"><code class="literal">Performance_schema_mutex_classes_lost</code></a>
      status variable is the only visible sign to indicate that some
      events were dropped internally due to failure to create
      instruments.
    </p><p>
      If an instrument is not lost, it is known to the Performance
      Schema, and is used when instrumenting instances. For example,
      <code class="literal">wait/synch/mutex/sql/LOCK_delete</code> is the name of
      a mutex instrument in the
      <a href="performance-schema.html#setup-instruments-table" title="20.7.1.2. The setup_instruments Table"><code class="literal">setup_instruments</code></a> table. This single
      instrument is used when creating in the code (in
      <code class="literal">THD::LOCK_delete</code>) however many instances of the
      mutex are needed as the server runs. In this case,
      <code class="literal">LOCK_delete</code> is a mutex that is per connection
      (<code class="literal">THD</code>), so if a server has 1000 connections,
      there are 1000 threads, and 1000 instrumented
      <code class="literal">LOCK_delete</code> mutex instances
      (<code class="literal">THD::LOCK_delete</code>).
    </p><p>
      If the server does not have room for all these 1000 instrumented
      mutexes (instances), some mutexes are created with
      instrumentation, and some are created without instrumentation. If
      the server can create only 800 instances, 200 instances are lost.
      The server continues to run, but increments
      <a href="performance-schema.html#statvar_Performance_schema_xxx_instances_lost"><code class="literal">Performance_schema_mutex_instances_lost</code></a>
      by 200 to indicate that instances could not be created.
    </p><p>
      A value of
      <a href="performance-schema.html#statvar_Performance_schema_xxx_instances_lost"><code class="literal">Performance_schema_mutex_instances_lost</code></a>
      greater than 0 can happen when the code initializes more mutexes
      at runtime than were allocated for
      <a href="performance-schema.html#sysvar_performance_schema_max_mutex_instances"><code class="option">--performance_schema_max_mutex_instances=<em class="replaceable"><code>N</code></em></code></a>.
    </p><p>
      The bottom line is that if
      <a href="sql-syntax.html#show-status" title="12.7.5.36. SHOW STATUS Syntax"><code class="literal">SHOW STATUS LIKE
      'perf%'</code></a> says that nothing was lost (all values are
      zero), the Performance Schema data is accurate and can be relied
      upon. If something was lost, the data is incomplete, and the
      Performance Schema could not record everything given the
      insufficient amount of memory it was given to use. In this case,
      the specific
      <code class="literal">Performance_schema_<em class="replaceable"><code>xxx</code></em>_lost</code>
      variable indicates the problem area.
    </p><p>
      It might be appropriate in some cases to cause deliberate
      instrument starvation. For example, if you do not care about
      performance data for file I/O, you can start the server with all
      Performance Schema parameters related to file I/O set to 0. No
      memory will be allocated for file-related classes, instances, or
      handles, and all file events will be lost.
    </p><p>
      Use <a href="sql-syntax.html#show-engine" title="12.7.5.16. SHOW ENGINE Syntax"><code class="literal">SHOW ENGINE
      PERFORMANCE_SCHEMA STATUS</code></a> to inspect the internal
      operation of the Performance Schema code:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW ENGINE PERFORMANCE_SCHEMA STATUS\G</code></strong>
...
*************************** 3. row ***************************
  Type: performance_schema
  Name: events_waits_history.row_size
Status: 76
*************************** 4. row ***************************
  Type: performance_schema
  Name: events_waits_history.row_count
Status: 10000
*************************** 5. row ***************************
  Type: performance_schema
  Name: events_waits_history.memory
Status: 760000
...
*************************** 57. row ***************************
  Type: performance_schema
  Name: performance_schema.memory
Status: 26459600
...
</pre><p>
      The intent of this statement is to help the DBA to understand the
      effects that different options have on memory requirements. For a
      description of the field meanings, see
      <a href="sql-syntax.html#show-engine" title="12.7.5.16. SHOW ENGINE Syntax">Section 12.7.5.16, “<code class="literal">SHOW ENGINE</code> Syntax”</a>.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-schema-table-characteristics"></a>20.6. Performance Schema General Table Characteristics</h2></div></div></div><p>
      The name of the <code class="literal">performance_schema</code> database is
      lowercase, as are the names of tables within it. Queries should
      specify the names in lowercase.
    </p><a class="indexterm" name="id1438279"></a><a class="indexterm" name="id1438292"></a><p>
      Most tables in the <code class="literal">performance_schema</code> database
      are read only and cannot be modified. Some of the setup tables
      have columns that can be modified to affect Performance Schema
      operation. Truncation is permitted to clear collected events, so
      <a href="sql-syntax.html#truncate-table" title="12.1.33. TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> can be used on
      tables containing those kinds of information, such as tables named
      with a prefix of <code class="literal">events_waits_</code>.
    </p><p>
      <a href="sql-syntax.html#truncate-table" title="12.1.33. TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> can also be used
      with summary tables, but the effect is to reset the summary
      columns to 0 or <code class="literal">NULL</code>, not to remove rows.
    </p><p>
      Privileges are as for other databases and tables:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
          To retrieve from <code class="literal">performance_schema</code> tables,
          you must have the <a href="server-administration.html#priv_select"><code class="literal">SELECT</code></a>
          privilege.
        </p></li><li><p>
          To change those columns that can be modified, you must have
          the <a href="server-administration.html#priv_update"><code class="literal">UPDATE</code></a> privilege.
        </p></li><li><p>
          To truncate tables that can be truncated, you must have the
          <a href="server-administration.html#priv_drop"><code class="literal">DROP</code></a> privilege.
        </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-schema-table-descriptions"></a>20.7. Performance Schema Table Descriptions</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="performance-schema.html#performance-schema-setup-tables">20.7.1. Performance Schema Setup Tables</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-instance-tables">20.7.2. Performance Schema Instance Tables</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-waits-tables">20.7.3. Performance Schema Wait Event Tables</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-summary-tables">20.7.4. Performance Schema Summary Tables</a></span></dt><dt><span class="section"><a href="performance-schema.html#performance-schema-miscellaneous-tables">20.7.5. Performance Schema Miscellaneous Tables</a></span></dt></dl></div><p>
      Tables in the <code class="literal">performance_schema</code> database can
      be grouped as follows:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
          Setup tables. These tables are used to configure and display
          monitoring characteristics.
        </p></li><li><p>
          Current events table. The
          <a href="performance-schema.html#events-waits-current-table" title="20.7.3.1. The events_waits_current Table"><code class="literal">events_waits_current</code></a> table
          contains the most recent event for each thread.
        </p></li><li><p>
          History tables. These tables have the same structure as
          <a href="performance-schema.html#events-waits-current-table" title="20.7.3.1. The events_waits_current Table"><code class="literal">events_waits_current</code></a> but contain
          more rows. The
          <a href="performance-schema.html#events-waits-history-table" title="20.7.3.2. The events_waits_history Table"><code class="literal">events_waits_history</code></a> table
          contains the most recent 10 events per thread.
          <a href="performance-schema.html#events-waits-history-long-table" title="20.7.3.3. The events_waits_history_long Table"><code class="literal">events_waits_history_long</code></a>
          contains the most recent 10,000 events.
        </p><p>
          To change the sizes of these tables, set the
          <a href="performance-schema.html#sysvar_performance_schema_events_waits_history_size"><code class="literal">performance_schema_events_waits_history_size</code></a>
          and
          <a href="performance-schema.html#sysvar_performance_schema_events_waits_history_long_size"><code class="literal">performance_schema_events_waits_history_long_size</code></a>
          system variables at server startup.
        </p></li><li><p>
          Summary tables. These tables contain information aggregated
          over groups of events, including those that have been
          discarded from the history tables.
        </p></li><li><p>
          Instance tables. These tables document what types of objects
          are instrumented. An instrumented object, when used by the
          server, produces an event. These tables provide event names
          and explanatory notes or status information.
        </p></li><li><p>
          Miscellaneous tables. These do not fall into any of the other
          table groups.
        </p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-schema-setup-tables"></a>20.7.1. Performance Schema Setup Tables</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="performance-schema.html#setup-consumers-table">20.7.1.1. The <code class="literal">setup_consumers</code> Table</a></span></dt><dt><span class="section"><a href="performance-schema.html#setup-instruments-table">20.7.1.2. The <code class="literal">setup_instruments</code> Table</a></span></dt><dt><span class="section"><a href="performance-schema.html#setup-timers-table">20.7.1.3. The <code class="literal">setup_timers</code> Table</a></span></dt></dl></div><p>
        The setup tables provide information about the current
        instrumentation and enable the monitoring configuration to be
        changed. For this reason, some columns in these tables can be
        changed if you have the <a href="server-administration.html#priv_update"><code class="literal">UPDATE</code></a>
        privilege.
      </p><p>
        The use of tables rather than individual variables for setup
        information provides a high degree of flexibility in modifying
        Performance Schema configuration. For example, you can use a
        single statement with standard SQL syntax to make multiple
        simultaneous configuration changes.
      </p><p>
        These setup tables are available:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <a href="performance-schema.html#setup-consumers-table" title="20.7.1.1. The setup_consumers Table"><code class="literal">setup_consumers</code></a>: The types of
            consumers for which event information can be stored
          </p></li><li><p>
            <a href="performance-schema.html#setup-instruments-table" title="20.7.1.2. The setup_instruments Table"><code class="literal">setup_instruments</code></a>: The classes
            of instrumented objects for which events can be collected
          </p></li><li><p>
            <a href="performance-schema.html#setup-timers-table" title="20.7.1.3. The setup_timers Table"><code class="literal">setup_timers</code></a>: The current event
            timer
          </p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="setup-consumers-table"></a>20.7.1.1. The <code class="literal">setup_consumers</code> Table</h4></div></div></div><a class="indexterm" name="id1438608"></a><a class="indexterm" name="id1438621"></a><p>
          The <a href="performance-schema.html#setup-consumers-table" title="20.7.1.1. The setup_consumers Table"><code class="literal">setup_consumers</code></a> table lists
          the types of consumers for which event information can be
          stored:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM setup_consumers;</code></strong>
+----------------------------------------------+---------+
| NAME                                         | ENABLED |
+----------------------------------------------+---------+
| events_waits_current                         | YES     |
| events_waits_history                         | YES     |
| events_waits_history_long                    | YES     |
| events_waits_summary_by_thread_by_event_name | YES     |
| events_waits_summary_by_event_name           | YES     |
| events_waits_summary_by_instance             | YES     |
| file_summary_by_event_name                   | YES     |
| file_summary_by_instance                     | YES     |
+----------------------------------------------+---------+
</pre><p>
          The <a href="performance-schema.html#setup-consumers-table" title="20.7.1.1. The setup_consumers Table"><code class="literal">setup_consumers</code></a> table has
          these columns:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <code class="literal">NAME</code>
            </p><p>
              The consumer name.
            </p></li><li><p>
              <code class="literal">ENABLED</code>
            </p><p>
              Whether the consumer is enabled. This column can be
              modified. If you disable a consumer, the server does not
              spend time adding event information to it.
            </p></li></ul></div><p>
          Disabling the <code class="literal">events_waits_current</code> consumer
          disables everything else that depends on waits, such as the
          <a href="performance-schema.html#events-waits-history-table" title="20.7.3.2. The events_waits_history Table"><code class="literal">events_waits_history</code></a> and
          <a href="performance-schema.html#events-waits-history-long-table" title="20.7.3.3. The events_waits_history_long Table"><code class="literal">events_waits_history_long</code></a> tables,
          and all summary tables.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="setup-instruments-table"></a>20.7.1.2. The <code class="literal">setup_instruments</code> Table</h4></div></div></div><a class="indexterm" name="id1438747"></a><a class="indexterm" name="id1438759"></a><p>
          The <a href="performance-schema.html#setup-instruments-table" title="20.7.1.2. The setup_instruments Table"><code class="literal">setup_instruments</code></a> table lists
          classes of instrumented objects for which events can be
          collected:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM setup_instruments;</code></strong>
+------------------------------------------------------------+---------+-------+
| NAME                                                       | ENABLED | TIMED |
+------------------------------------------------------------+---------+-------+
...
| wait/synch/mutex/sql/LOCK_global_read_lock                 | YES     | YES   |
| wait/synch/mutex/sql/LOCK_global_system_variables          | YES     | YES   |
| wait/synch/mutex/sql/LOCK_lock_db                          | YES     | YES   |
| wait/synch/mutex/sql/LOCK_manager                          | YES     | YES   |
...
| wait/synch/rwlock/sql/LOCK_grant                           | YES     | YES   |
| wait/synch/rwlock/sql/LOGGER::LOCK_logger                  | YES     | YES   |
| wait/synch/rwlock/sql/LOCK_sys_init_connect                | YES     | YES   |
| wait/synch/rwlock/sql/LOCK_sys_init_slave                  | YES     | YES   |
...
| wait/io/file/sql/binlog                                    | YES     | YES   |
| wait/io/file/sql/binlog_index                              | YES     | YES   |
| wait/io/file/sql/casetest                                  | YES     | YES   |
| wait/io/file/sql/dbopt                                     | YES     | YES   |
...
</pre><p>
          Each instrument added to the source code provides a row for
          this table, even when the instrumented code is not executed.
          When an instrument is enabled and executed, instrumented
          instances are created, which are visible in the
          <code class="literal">*_instances</code> tables.
        </p><p>
          The <a href="performance-schema.html#setup-instruments-table" title="20.7.1.2. The setup_instruments Table"><code class="literal">setup_instruments</code></a> table has
          these columns:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <code class="literal">NAME</code>
            </p><p>
              The instrument name. Instrument names have multiple parts
              and form a hierarchy, as discussed in
              <a href="performance-schema.html#performance-schema-instrument-naming" title="20.4. Performance Schema Instrument Naming Conventions">Section 20.4, “Performance Schema Instrument Naming Conventions”</a>.
              Events produced from execution of an instrument have an
              <code class="literal">EVENT_NAME</code> value that is taken from the
              instrument <code class="literal">NAME</code> value. (Events do not
              really have a “<span class="quote">name,</span>” but this provides a way
              to associate events with instruments.)
            </p></li><li><p>
              <code class="literal">ENABLED</code>
            </p><p>
              Whether the instrument is enabled. This column can be
              modified. A disabled instrument produces no events.
            </p></li><li><p>
              <code class="literal">TIMED</code>
            </p><p>
              Whether the instrument is timed. This column can be
              modified.
            </p><p>
              If an enabled instrument is not timed, the instrument code
              is enabled, but the timer is not. Events produced by the
              instrument have <code class="literal">NULL</code> for the
              <code class="literal">TIMER_START</code>,
              <code class="literal">TIMER_END</code>, and
              <code class="literal">TIMER_WAIT</code> timer values. This in turn
              causes those values to be ignored when calculating the
              sum, minimum, maximum, and average time values in summary
              tables.
            </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="setup-timers-table"></a>20.7.1.3. The <code class="literal">setup_timers</code> Table</h4></div></div></div><a class="indexterm" name="id1438956"></a><a class="indexterm" name="id1438968"></a><p>
          The <a href="performance-schema.html#setup-timers-table" title="20.7.1.3. The setup_timers Table"><code class="literal">setup_timers</code></a> table shows the
          currently selected event timer:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM setup_timers;</code></strong>
+------+------------+
| NAME | TIMER_NAME |
+------+------------+
| wait | CYCLE      |
+------+------------+
</pre><p>
          The <code class="literal">setup_timers.TIMER_NAME</code> value can be
          changed to select a different timer. The value can be any of
          the values in the
          <code class="literal">performance_timers.TIMER_NAME</code> column. For
          an explanation of how event timing occurs, see
          <a href="performance-schema.html#performance-schema-timing" title="20.2.3.1. Performance Schema Event Timing">Section 20.2.3.1, “Performance Schema Event Timing”</a>.
        </p><p>
          The <a href="performance-schema.html#setup-timers-table" title="20.7.1.3. The setup_timers Table"><code class="literal">setup_timers</code></a> table has these
          columns:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <code class="literal">NAME</code>
            </p><p>
              The type of instrument the timer is used for.
            </p></li><li><p>
              <code class="literal">TIMER_NAME</code>
            </p><p>
              The timer that applies to the instrument type. This column
              can be modified.
            </p></li></ul></div><p>
          The <code class="literal">setup_timers.TIMER_NAME</code> value can be
          changed to select a different timer. The value can be any of
          the values in the
          <code class="literal">performance_timers.TIMER_NAME</code> column. For
          an explanation of how event timing occurs, see
          <a href="performance-schema.html#performance-schema-timing" title="20.2.3.1. Performance Schema Event Timing">Section 20.2.3.1, “Performance Schema Event Timing”</a>.
        </p><p>
          Modifications to the <a href="performance-schema.html#setup-timers-table" title="20.7.1.3. The setup_timers Table"><code class="literal">setup_timers</code></a>
          table affect monitoring immediately. Events already in
          progress use the original timer for the begin time and the new
          timer for the end time, which leads to unpredictable results.
          If you make timer changes, you may want to use
          <a href="sql-syntax.html#truncate-table" title="12.1.33. TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> to reset
          Performance Schema statistics.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-schema-instance-tables"></a>20.7.2. Performance Schema Instance Tables</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="performance-schema.html#cond-instances-table">20.7.2.1. The <code class="literal">cond_instances</code> Table</a></span></dt><dt><span class="section"><a href="performance-schema.html#file-instances-table">20.7.2.2. The <code class="literal">file_instances</code> Table</a></span></dt><dt><span class="section"><a href="performance-schema.html#mutex-instances-table">20.7.2.3. The <code class="literal">mutex_instances</code> Table</a></span></dt><dt><span class="section"><a href="performance-schema.html#rwlock-instances-table">20.7.2.4. The <code class="literal">rwlock_instances</code> Table</a></span></dt></dl></div><p>
        Instance tables document what types of objects are instrumented.
        They provide event names and explanatory notes or status
        information:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <a href="performance-schema.html#cond-instances-table" title="20.7.2.1. The cond_instances Table"><code class="literal">cond_instances</code></a>: Condition
            synchronization object instances
          </p></li><li><p>
            <a href="performance-schema.html#file-instances-table" title="20.7.2.2. The file_instances Table"><code class="literal">file_instances</code></a>: File instances
          </p></li><li><p>
            <a href="performance-schema.html#mutex-instances-table" title="20.7.2.3. The mutex_instances Table"><code class="literal">mutex_instances</code></a>: Mutex
            synchronization object instances
          </p></li><li><p>
            <a href="performance-schema.html#rwlock-instances-table" title="20.7.2.4. The rwlock_instances Table"><code class="literal">rwlock_instances</code></a>: Lock
            synchronization object instances
          </p></li></ul></div><p>
        These tables list instrumented synchronization objects and
        files. There are three types of synchronization objects:
        <code class="literal">cond</code>, <code class="literal">mutex</code>, and
        <code class="literal">rwlock</code>. Each instance table has an
        <code class="literal">EVENT_NAME</code> or <code class="literal">NAME</code> column
        to indicate the instrument associated with each row. Instrument
        names have multiple parts and form a hierarchy, as discussed in
        <a href="performance-schema.html#performance-schema-instrument-naming" title="20.4. Performance Schema Instrument Naming Conventions">Section 20.4, “Performance Schema Instrument Naming Conventions”</a>.
      </p><p>
        The <code class="literal">mutex_instances.LOCKED_BY_THREAD_ID</code> and
        <code class="literal">rwlock_instances.WRITE_LOCKED_BY_THREAD_ID</code>
        columns are extremely important for investigating performance
        bottlenecks or deadlocks. For examples of how to use them for
        this purpose, see <a href="performance-schema.html#performance-schema-examples" title="20.11. Using the Performance Schema to Diagnose Problems">Section 20.11, “Using the Performance Schema to Diagnose Problems”</a>
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="cond-instances-table"></a>20.7.2.1. The <code class="literal">cond_instances</code> Table</h4></div></div></div><a class="indexterm" name="id1439262"></a><a class="indexterm" name="id1439274"></a><p>
          The <a href="performance-schema.html#cond-instances-table" title="20.7.2.1. The cond_instances Table"><code class="literal">cond_instances</code></a> table lists
          all the conditions seen by the Performance Schema while the
          server executes. A condition is a synchronization mechanism
          used in the code to signal that a specific event has happened,
          so that a thread waiting for this condition can resume work.
        </p><p>
          When a thread is waiting for something to happen, the
          condition name is an indication of what the thread is waiting
          for, but there is no immediate way to tell which other thread,
          or threads, will cause the condition to happen.
        </p><p>
          The <a href="performance-schema.html#cond-instances-table" title="20.7.2.1. The cond_instances Table"><code class="literal">cond_instances</code></a> table has
          these columns:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <code class="literal">NAME</code>
            </p><p>
              The instrument name associated with the condition.
            </p></li><li><p>
              <code class="literal">OBJECT_INSTANCE_BEGIN</code>
            </p><p>
              The address in memory of the condition that was
              instrumented.
            </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="file-instances-table"></a>20.7.2.2. The <code class="literal">file_instances</code> Table</h4></div></div></div><a class="indexterm" name="id1439364"></a><a class="indexterm" name="id1439376"></a><p>
          The <a href="performance-schema.html#file-instances-table" title="20.7.2.2. The file_instances Table"><code class="literal">file_instances</code></a> table lists
          all the files seen by the Performance Schema when executing
          file I/O instrumentation. If a file on disk has never been
          opened, it will not be in
          <a href="performance-schema.html#file-instances-table" title="20.7.2.2. The file_instances Table"><code class="literal">file_instances</code></a>. When a file is
          deleted from the disk, it is also removed from the
          <a href="performance-schema.html#file-instances-table" title="20.7.2.2. The file_instances Table"><code class="literal">file_instances</code></a> table.
        </p><p>
          The <a href="performance-schema.html#file-instances-table" title="20.7.2.2. The file_instances Table"><code class="literal">file_instances</code></a> table has
          these columns:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <code class="literal">FILE_NAME</code>
            </p><p>
              The file name.
            </p></li><li><p>
              <code class="literal">EVENT_NAME</code>
            </p><p>
              The instrument name associated with the file.
            </p></li><li><p>
              <code class="literal">OPEN_COUNT</code>
            </p><p>
              The count of open handles on the file. If a file was
              opened and then closed, it was opened 1 time, but
              <code class="literal">OPEN_COUNT</code> will be 0. To list all the
              files currently opened by the server, use <code class="literal">WHERE
              OPEN_COUNT &gt; 0</code>.
            </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mutex-instances-table"></a>20.7.2.3. The <code class="literal">mutex_instances</code> Table</h4></div></div></div><a class="indexterm" name="id1439504"></a><a class="indexterm" name="id1439516"></a><p>
          The <a href="performance-schema.html#mutex-instances-table" title="20.7.2.3. The mutex_instances Table"><code class="literal">mutex_instances</code></a> table lists
          all the mutexes seen by the Performance Schema while the
          server executes. A mutex is a synchronization mechanism used
          in the code to enforce that only one thread at a given time
          can have access to some common resource. The resource is said
          to be “<span class="quote">protected</span>” by the mutex.
        </p><p>
          When two threads executing in the server (for example, two
          user sessions executing a query simultaneously) do need to
          access the same resource (a file, a buffer, or some piece of
          data), these two threads will compete against each other, so
          that the first query to obtain a lock on the mutex will cause
          the other query to wait until the first is done and unlocks
          the mutex.
        </p><p>
          The work performed while holding a mutex is said to be in a
          “<span class="quote">critical section,</span>” and multiple queries do
          execute this critical section in a serialized way (one at a
          time), which is a potential bottleneck.
        </p><p>
          The <a href="performance-schema.html#mutex-instances-table" title="20.7.2.3. The mutex_instances Table"><code class="literal">mutex_instances</code></a> table has
          these columns:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <code class="literal">NAME</code>
            </p><p>
              The instrument name associated with the mutex.
            </p></li><li><p>
              <code class="literal">OBJECT_INSTANCE_BEGIN</code>
            </p><p>
              The address in memory of the mutex that was instrumented.
            </p></li><li><p>
              <code class="literal">LOCKED_BY_THREAD_ID</code>
            </p><p>
              When a thread currently has a mutex locked,
              <code class="literal">LOCKED_BY_THREAD_ID</code> is the
              <code class="literal">THREAD_ID</code> of the locking thread,
              otherwise it is <code class="literal">NULL</code>.
            </p></li></ul></div><p>
          For every mutex instrumented in the code, the Performance
          Schema provides the following information.
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              The <a href="performance-schema.html#setup-instruments-table" title="20.7.1.2. The setup_instruments Table"><code class="literal">setup_instruments</code></a> table
              lists the name of the instrumentation point, with the
              prefix <code class="literal">wait/synch/mutex/</code>.
            </p></li><li><p>
              When some code creates a mutex, a row is added to the
              <a href="performance-schema.html#mutex-instances-table" title="20.7.2.3. The mutex_instances Table"><code class="literal">mutex_instances</code></a> table. The
              <code class="literal">OBJECT_INSTANCE_BEGIN</code> column is a
              property that uniquely identifies the mutex.
            </p></li><li><p>
              When a thread attempts to lock a mutex, the
              <a href="performance-schema.html#events-waits-current-table" title="20.7.3.1. The events_waits_current Table"><code class="literal">events_waits_current</code></a> table
              shows a row for that thread, indicating that it is waiting
              on a mutex (in the <code class="literal">EVENT_NAME</code> column),
              and indicating which mutex is waited on (in the
              <code class="literal">OBJECT_INSTANCE_BEGIN</code> column).
            </p></li><li><p>
              When a thread succeeds in locking a mutex:
            </p><div class="itemizedlist"><ul type="circle"><li><p>
                  <a href="performance-schema.html#events-waits-current-table" title="20.7.3.1. The events_waits_current Table"><code class="literal">events_waits_current</code></a>
                  shows that the wait on the mutex is completed (in the
                  <code class="literal">TIMER_END</code> and
                  <code class="literal">TIMER_WAIT</code> columns)
                </p></li><li><p>
                  The completed wait event is added to the
                  <a href="performance-schema.html#events-waits-history-table" title="20.7.3.2. The events_waits_history Table"><code class="literal">events_waits_history</code></a> and
                  <a href="performance-schema.html#events-waits-history-long-table" title="20.7.3.3. The events_waits_history_long Table"><code class="literal">events_waits_history_long</code></a>
                  tables
                </p></li><li><p>
                  <a href="performance-schema.html#mutex-instances-table" title="20.7.2.3. The mutex_instances Table"><code class="literal">mutex_instances</code></a> shows
                  that the mutex is now owned by the thread (in the
                  <code class="literal">THREAD_ID</code> column).
                </p></li></ul></div></li><li><p>
              When a thread unlocks a mutex,
              <a href="performance-schema.html#mutex-instances-table" title="20.7.2.3. The mutex_instances Table"><code class="literal">mutex_instances</code></a> shows that
              the mutex now has no owner (the
              <code class="literal">THREAD_ID</code> column is
              <code class="literal">NULL</code>).
            </p></li><li><p>
              When a mutex object is destroyed, the corresponding row is
              removed from <a href="performance-schema.html#mutex-instances-table" title="20.7.2.3. The mutex_instances Table"><code class="literal">mutex_instances</code></a>.
            </p></li></ul></div><p>
          By performing queries on both of the following tables, a
          monitoring application or a DBA can detect bottlenecks or
          deadlocks between threads that involve mutexes:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <a href="performance-schema.html#events-waits-current-table" title="20.7.3.1. The events_waits_current Table"><code class="literal">events_waits_current</code></a>, to see
              what mutex a thread is waiting for
            </p></li><li><p>
              <a href="performance-schema.html#mutex-instances-table" title="20.7.2.3. The mutex_instances Table"><code class="literal">mutex_instances</code></a>, to see which
              other thread currently owns a mutex
            </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="rwlock-instances-table"></a>20.7.2.4. The <code class="literal">rwlock_instances</code> Table</h4></div></div></div><a class="indexterm" name="id1439888"></a><a class="indexterm" name="id1439900"></a><p>
          The <a href="performance-schema.html#rwlock-instances-table" title="20.7.2.4. The rwlock_instances Table"><code class="literal">rwlock_instances</code></a> table lists
          all the <code class="literal">rwlock</code> instances (read write locks)
          seen by the Performance Schema while the server executes. An
          <code class="literal">rwlock</code> is a synchronization mechanism used
          in the code to enforce that threads at a given time can have
          access to some common resource following certain rules. The
          resource is said to be “<span class="quote">protected</span>” by the
          <code class="literal">rwlock</code>. The access is either shared (many
          threads can have a read lock at the same time) or exclusive
          (only one thread can have a write lock at a given time).
        </p><p>
          Depending on how many threads are requesting a lock, and the
          nature of the locks requested, access can be either granted in
          shared mode, granted in exclusive mode, or not granted at all,
          waiting for other threads to finish first.
        </p><p>
          The <a href="performance-schema.html#rwlock-instances-table" title="20.7.2.4. The rwlock_instances Table"><code class="literal">rwlock_instances</code></a> table has
          these columns:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <code class="literal">NAME</code>
            </p><p>
              The instrument name associated with the lock.
            </p></li><li><p>
              <code class="literal">OBJECT_INSTANCE_BEGIN</code>
            </p><p>
              The address in memory of the lock that was instrumented.
            </p></li><li><p>
              <code class="literal">WRITE_LOCKED_BY_THREAD_ID</code>
            </p><p>
              When a thread currently has an <code class="literal">rwlock</code>
              locked in exclusive (write) mode,
              <code class="literal">WRITE_LOCKED_BY_THREAD_ID</code> is the
              <code class="literal">THREAD_ID</code> of the locking thread,
              otherwise it is <code class="literal">NULL</code>.
            </p></li><li><p>
              <code class="literal">READ_LOCKED_BY_COUNT</code>
            </p><p>
              When a thread currently has an <code class="literal">rwlock</code>
              locked in shared (read) mode,
              <code class="literal">READ_LOCKED_BY_COUNT</code> is incremented by
              1. This is a counter only, so it cannot be used directly
              to find which thread holds a read lock, but it can be used
              to see whether there is a read contention on an
              <code class="literal">rwlock</code>, and see how many readers are
              currently active.
            </p></li></ul></div><p>
          By performing queries on both of the following tables, a
          monitoring application or a DBA may detect some bottlenecks or
          deadlocks between threads that involve locks:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <a href="performance-schema.html#events-waits-current-table" title="20.7.3.1. The events_waits_current Table"><code class="literal">events_waits_current</code></a>, to see
              what <code class="literal">rwlock</code> a thread is waiting for
            </p></li><li><p>
              <a href="performance-schema.html#rwlock-instances-table" title="20.7.2.4. The rwlock_instances Table"><code class="literal">rwlock_instances</code></a>, to see
              which other thread currently owns an
              <code class="literal">rwlock</code>
            </p></li></ul></div><p>
          There is a limitation: The
          <a href="performance-schema.html#rwlock-instances-table" title="20.7.2.4. The rwlock_instances Table"><code class="literal">rwlock_instances</code></a> can be used only
          to identify the thread holding a write lock, but not the
          threads holding a read lock.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-schema-waits-tables"></a>20.7.3. Performance Schema Wait Event Tables</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="performance-schema.html#events-waits-current-table">20.7.3.1. The <code class="literal">events_waits_current</code> Table</a></span></dt><dt><span class="section"><a href="performance-schema.html#events-waits-history-table">20.7.3.2. The <code class="literal">events_waits_history</code> Table</a></span></dt><dt><span class="section"><a href="performance-schema.html#events-waits-history-long-table">20.7.3.3. The <code class="literal">events_waits_history_long</code> Table</a></span></dt></dl></div><p>
        These tables store wait events:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <a href="performance-schema.html#events-waits-current-table" title="20.7.3.1. The events_waits_current Table"><code class="literal">events_waits_current</code></a>: Current
            wait events
          </p></li><li><p>
            <a href="performance-schema.html#events-waits-history-table" title="20.7.3.2. The events_waits_history Table"><code class="literal">events_waits_history</code></a>: The most
            recent wait events for each thread
          </p></li><li><p>
            <a href="performance-schema.html#events-waits-history-long-table" title="20.7.3.3. The events_waits_history_long Table"><code class="literal">events_waits_history_long</code></a>: The
            most recent wait events overall
          </p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="events-waits-current-table"></a>20.7.3.1. The <code class="literal">events_waits_current</code> Table</h4></div></div></div><a class="indexterm" name="id1440208"></a><a class="indexterm" name="id1440221"></a><p>
          The <a href="performance-schema.html#events-waits-current-table" title="20.7.3.1. The events_waits_current Table"><code class="literal">events_waits_current</code></a> table
          contains current wait events, one row per thread showing the
          current status of the thread's most recent monitored wait
          event.
        </p><p>
          The <a href="performance-schema.html#events-waits-current-table" title="20.7.3.1. The events_waits_current Table"><code class="literal">events_waits_current</code></a> table
          can be truncated with <a href="sql-syntax.html#truncate-table" title="12.1.33. TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE
          TABLE</code></a>.
        </p><p>
          Of the tables that contain wait event rows,
          <a href="performance-schema.html#events-waits-current-table" title="20.7.3.1. The events_waits_current Table"><code class="literal">events_waits_current</code></a> is the most
          fundamental. Other tables that contain wait event rows are
          logically derived from the current events. For example, the
          <a href="performance-schema.html#events-waits-history-table" title="20.7.3.2. The events_waits_history Table"><code class="literal">events_waits_history</code></a> and
          <a href="performance-schema.html#events-waits-history-long-table" title="20.7.3.3. The events_waits_history_long Table"><code class="literal">events_waits_history_long</code></a> tables
          are collections of the most recent wait events, up to a fixed
          number of rows.
        </p><p>
          The <a href="performance-schema.html#events-waits-current-table" title="20.7.3.1. The events_waits_current Table"><code class="literal">events_waits_current</code></a> table
          has these columns:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <code class="literal">THREAD_ID</code>
            </p><p>
              The thread associated with the event. The
              <code class="literal">THREAD_ID</code> and
              <code class="literal">EVENT_ID</code> values taken together form a
              primary key that uniquely identifies the row. No two rows
              will have the same pair of values.
            </p></li><li><p>
              <code class="literal">EVENT_ID</code>
            </p><p>
              The thread current event number when the event starts.
            </p></li><li><p>
              <code class="literal">EVENT_NAME</code>
            </p><p>
              The name of the instrument that produced the event. This
              is a <code class="literal">setup_instruments.NAME</code> value.
              Instrument names have multiple parts and form a hierarchy,
              as discussed in
              <a href="performance-schema.html#performance-schema-instrument-naming" title="20.4. Performance Schema Instrument Naming Conventions">Section 20.4, “Performance Schema Instrument Naming Conventions”</a>.
            </p></li><li><p>
              <code class="literal">SOURCE</code>
            </p><p>
              The name of the source file containing the instrumented
              code that produced the event and the line number in the
              file at which the instrumentation occurs. This enables you
              to check the source to determine exactly what code is
              involved. For example, if a mutex or lock is being
              blocked, you can check the context in which this occurs.
            </p></li><li><p>
              <code class="literal">TIMER_START</code>,
              <code class="literal">TIMER_END</code>,
              <code class="literal">TIMER_WAIT</code>
            </p><p>
              Timing information for the event. The unit for these
              values is picoseconds (trillionths of a second). The
              <code class="literal">TIMER_START</code> and
              <code class="literal">TIMER_END</code> values indicate when event
              timing started and ended. <code class="literal">TIMER_WAIT</code> is
              the event elapsed time (duration).
            </p><p>
              If an event has not finished, <code class="literal">TIMER_END</code>
              and <code class="literal">TIMER_WAIT</code> are
              <code class="literal">NULL</code>.
            </p><p>
              If an event is produced from an instrument that has
              <code class="literal">TIMED = NO</code>, timing information is not
              collected, and <code class="literal">TIMER_START</code>,
              <code class="literal">TIMER_END</code>, and
              <code class="literal">TIMER_WAIT</code> are all
              <code class="literal">NULL</code>.
            </p><p>
              For discussion of picoseconds as the unit for event times
              and factors that affect time values, see
              <a href="performance-schema.html#performance-schema-timing" title="20.2.3.1. Performance Schema Event Timing">Section 20.2.3.1, “Performance Schema Event Timing”</a>.
            </p></li><li><p>
              <code class="literal">SPINS</code>
            </p><p>
              For a mutex, the number of spin rounds. If the value is
              <code class="literal">NULL</code>, the code does not use spin rounds
              or spinning is not instrumented.
            </p></li><li><p>
              <code class="literal">OBJECT_SCHEMA</code>,
              <code class="literal">OBJECT_NAME</code>,
              <code class="literal">OBJECT_TYPE</code>,
              <code class="literal">OBJECT_INSTANCE_BEGIN</code>
            </p><p>
              These columns identify the object “<span class="quote">being acted
              on.</span>” What that means depends on the object type.
            </p><p>
              For a synchronization object (<code class="literal">cond</code>,
              <code class="literal">mutex</code>, <code class="literal">rwlock</code>):
            </p><div class="itemizedlist"><ul type="circle"><li><p>
                  <code class="literal">OBJECT_SCHEMA</code>,
                  <code class="literal">OBJECT_NAME</code>, and
                  <code class="literal">OBJECT_TYPE</code> are
                  <code class="literal">NULL</code>.
                </p></li><li><p>
                  <code class="literal">OBJECT_INSTANCE_BEGIN</code> is the
                  address of the synchronization object in memory.
                </p></li></ul></div><p>
              For a file I/O object:
            </p><div class="itemizedlist"><ul type="circle"><li><p>
                  <code class="literal">OBJECT_SCHEMA</code> is
                  <code class="literal">NULL</code>.
                </p></li><li><p>
                  <code class="literal">OBJECT_NAME</code> is the file name.
                </p></li><li><p>
                  <code class="literal">OBJECT_TYPE</code> is
                  <code class="literal">FILE</code>.
                </p></li><li><p>
                  <code class="literal">OBJECT_INSTANCE_BEGIN</code> is an address
                  in memory.
                </p></li></ul></div><p>
              An <code class="literal">OBJECT_INSTANCE_BEGIN</code> value itself
              has no meaning, except that different values indicate
              different objects.
              <code class="literal">OBJECT_INSTANCE_BEGIN</code> can be used for
              debugging. For example, it can be used with <code class="literal">GROUP
              BY OBJECT_INSTANCE_BEGIN</code> to see whether the load
              on 1,000 mutexes (that protect, say, 1,000 pages or blocks
              of data) is spread evenly or just hitting a few
              bottlenecks. This can help you correlate with other
              sources of information if you see the same object address
              in a log file or another debugging or performance tool.
            </p></li><li><p>
              <code class="literal">NESTING_EVENT_ID</code>
            </p><p>
              Currently <code class="literal">NULL</code>.
            </p></li><li><p>
              <code class="literal">OPERATION</code>
            </p><p>
              The type of operation performed, such as
              <code class="literal">lock</code>, <code class="literal">read</code>, or
              <code class="literal">write</code>.
            </p></li><li><p>
              <code class="literal">NUMBER_OF_BYTES</code>
            </p><p>
              The number of bytes read or written by the operation.
            </p></li><li><p>
              <code class="literal">FLAGS</code>
            </p><p>
              Reserved for future use.
            </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="events-waits-history-table"></a>20.7.3.2. The <code class="literal">events_waits_history</code> Table</h4></div></div></div><a class="indexterm" name="id1440835"></a><a class="indexterm" name="id1440848"></a><p>
          The <a href="performance-schema.html#events-waits-history-table" title="20.7.3.2. The events_waits_history Table"><code class="literal">events_waits_history</code></a> table
          contains the most recent 10 wait events per thread. The table
          size may be changed by modifying the
          <a href="performance-schema.html#sysvar_performance_schema_events_waits_history_size"><code class="literal">performance_schema_events_waits_history_size</code></a>
          system variable at server startup. As new events are added to
          the table, older events are discarded if the table is full.
          Events are not added to the table until they have ended.
        </p><p>
          The <a href="performance-schema.html#events-waits-history-table" title="20.7.3.2. The events_waits_history Table"><code class="literal">events_waits_history</code></a> table
          has the same structure as
          <a href="performance-schema.html#events-waits-current-table" title="20.7.3.1. The events_waits_current Table"><code class="literal">events_waits_current</code></a>. See
          <a href="performance-schema.html#events-waits-current-table" title="20.7.3.1. The events_waits_current Table">Section 20.7.3.1, “The <code class="literal">events_waits_current</code> Table”</a>.
        </p><p>
          The <a href="performance-schema.html#events-waits-history-table" title="20.7.3.2. The events_waits_history Table"><code class="literal">events_waits_history</code></a> table
          can be truncated with <a href="sql-syntax.html#truncate-table" title="12.1.33. TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE
          TABLE</code></a>.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="events-waits-history-long-table"></a>20.7.3.3. The <code class="literal">events_waits_history_long</code> Table</h4></div></div></div><a class="indexterm" name="id1440935"></a><a class="indexterm" name="id1440948"></a><p>
          The <a href="performance-schema.html#events-waits-history-long-table" title="20.7.3.3. The events_waits_history_long Table"><code class="literal">events_waits_history_long</code></a>
          table contains the most recent 10,000 wait events. The table
          size may be changed by modifying the
          <a href="performance-schema.html#sysvar_performance_schema_events_waits_history_long_size"><code class="literal">performance_schema_events_waits_history_long_size</code></a>
          system variable at server startup. As new events are added to
          the table, older events are discarded if the table is full.
          Events are not added to the table until they have ended.
        </p><p>
          The <a href="performance-schema.html#events-waits-history-long-table" title="20.7.3.3. The events_waits_history_long Table"><code class="literal">events_waits_history_long</code></a>
          table has the same structure as
          <a href="performance-schema.html#events-waits-current-table" title="20.7.3.1. The events_waits_current Table"><code class="literal">events_waits_current</code></a>. See
          <a href="performance-schema.html#events-waits-current-table" title="20.7.3.1. The events_waits_current Table">Section 20.7.3.1, “The <code class="literal">events_waits_current</code> Table”</a>.
        </p><p>
          The <a href="performance-schema.html#events-waits-history-long-table" title="20.7.3.3. The events_waits_history_long Table"><code class="literal">events_waits_history_long</code></a>
          table can be truncated with <a href="sql-syntax.html#truncate-table" title="12.1.33. TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE
          TABLE</code></a>.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-schema-summary-tables"></a>20.7.4. Performance Schema Summary Tables</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="performance-schema.html#event-wait-summary-tables">20.7.4.1. Event Wait Summary Tables</a></span></dt><dt><span class="section"><a href="performance-schema.html#file-summary-tables">20.7.4.2. File I/O Summary Tables</a></span></dt></dl></div><p>
        Summary tables provide aggregate information for terminated
        events over time. The tables in this group summarize event data
        in different ways.
      </p><p>
        <span class="bold"><strong>Event Wait Summaries:</strong></span>
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <a href="performance-schema.html#event-wait-summary-tables" title="20.7.4.1. Event Wait Summary Tables"><code class="literal">events_waits_summary_global_by_event_name</code></a>:
            Wait events summarized per event name
          </p></li><li><p>
            <a href="performance-schema.html#event-wait-summary-tables" title="20.7.4.1. Event Wait Summary Tables"><code class="literal">events_waits_summary_by_instance</code></a>:
            Wait events summarized per instance
          </p></li><li><p>
            <a href="performance-schema.html#event-wait-summary-tables" title="20.7.4.1. Event Wait Summary Tables"><code class="literal">events_waits_summary_by_thread_by_event_name</code></a>:
            Wait events summarized per thread and event name
          </p></li></ul></div><p>
        <span class="bold"><strong>File I/O Summaries:</strong></span>
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <a href="performance-schema.html#file-summary-tables" title="20.7.4.2. File I/O Summary Tables"><code class="literal">file_summary_by_event_name</code></a>:
            File events summarized per event name
          </p></li><li><p>
            <a href="performance-schema.html#file-summary-tables" title="20.7.4.2. File I/O Summary Tables"><code class="literal">file_summary_by_instance</code></a>: File
            events summarized per file instance
          </p></li></ul></div><p>
        The <code class="literal">events_waits_summary_global_by_event_name</code>
        table was named
        <code class="literal">EVENTS_WAITS_SUMMARY_BY_EVENT_NAME</code> before
        MySQL 5.5.7.
      </p><p>
        Each summary table has grouping columns that determine how to
        group the data to be aggregated, and summary columns that
        contain the aggregated values. Tables that summarize events in
        similar ways often have similar sets of summary columns and
        differ only in the grouping columns used to determine how events
        are aggregated.
      </p><p>
        Summary tables can be truncated with
        <a href="sql-syntax.html#truncate-table" title="12.1.33. TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a>. The effect is to
        reset the summary columns to 0 or <code class="literal">NULL</code>, not
        to remove rows. This enables you to clear collected values and
        restart aggregation. That might be useful, for example, after
        you have made a runtime configuration change.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="event-wait-summary-tables"></a>20.7.4.1. Event Wait Summary Tables</h4></div></div></div><a class="indexterm" name="id1441183"></a><a class="indexterm" name="id1441195"></a><a class="indexterm" name="id1441208"></a><a class="indexterm" name="id1441220"></a><a class="indexterm" name="id1441233"></a><a class="indexterm" name="id1441246"></a><p>
          The event waits summary tables aggregate general information
          about event waits:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <a href="performance-schema.html#event-wait-summary-tables" title="20.7.4.1. Event Wait Summary Tables"><code class="literal">events_waits_summary_global_by_event_name</code></a>:
              Wait events summarized per event name
            </p></li><li><p>
              <a href="performance-schema.html#event-wait-summary-tables" title="20.7.4.1. Event Wait Summary Tables"><code class="literal">events_waits_summary_by_instance</code></a>:
              Wait events summarized per instance
            </p></li><li><p>
              <a href="performance-schema.html#event-wait-summary-tables" title="20.7.4.1. Event Wait Summary Tables"><code class="literal">events_waits_summary_by_thread_by_event_name</code></a>:
              Wait events summarized per thread and event name
            </p></li></ul></div><p>
          For example:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM events_waits_summary_global_by_event_name\G</code></strong>
...
*************************** 6. row ***************************
    EVENT_NAME: wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_index
    COUNT_STAR: 8
SUM_TIMER_WAIT: 2119302
MIN_TIMER_WAIT: 196092
AVG_TIMER_WAIT: 264912
MAX_TIMER_WAIT: 569421
...
*************************** 9. row ***************************
    EVENT_NAME: wait/synch/mutex/sql/hash_filo::lock
    COUNT_STAR: 69
SUM_TIMER_WAIT: 16848828
MIN_TIMER_WAIT: 0
AVG_TIMER_WAIT: 244185
MAX_TIMER_WAIT: 735345
...
</pre><p>
          <a href="sql-syntax.html#truncate-table" title="12.1.33. TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> is permitted for
          summary tables. It resets the counters to zero rather than
          removing rows.
        </p><p>
          The event wait summary tables have these grouping columns to
          indicate how events are aggregated:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <a href="performance-schema.html#event-wait-summary-tables" title="20.7.4.1. Event Wait Summary Tables"><code class="literal">events_waits_summary_global_by_event_name</code></a>
              has an <code class="literal">EVENT_NAME</code> column. Each row
              summarizes events for a given instrument. An instrument
              might be used to create multiple instances of the
              instrumented object. For example, if there is an
              instrument for a mutex that is created for each
              connection, there are as many instances as there are
              connections. The summary row for the instrument summarizes
              over all these instances.
            </p></li><li><p>
              <a href="performance-schema.html#event-wait-summary-tables" title="20.7.4.1. Event Wait Summary Tables"><code class="literal">events_waits_summary_by_instance</code></a>
              has <code class="literal">EVENT_NAME</code> and
              <code class="literal">OBJECT_INSTANCE_BEGIN</code> columns. Each row
              summarizes events for a given instrument instance. If an
              instrument is used to create multiple instances, each
              instance has a unique
              <code class="literal">OBJECT_INSTANCE_BEGIN</code> value, so these
              instances are summarized separately in this table.
            </p></li><li><p>
              <a href="performance-schema.html#event-wait-summary-tables" title="20.7.4.1. Event Wait Summary Tables"><code class="literal">events_waits_summary_by_thread_by_event_name</code></a>
              has <code class="literal">THREAD_ID</code> and
              <code class="literal">EVENT_NAME</code> columns. Each row summarizes
              events for a given thread and instrument.
            </p></li></ul></div><p>
          The event waits summary tables have these summary columns
          containing aggregated values:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <code class="literal">COUNT_STAR</code>
            </p><p>
              The number of summarized events. This value includes all
              events, whether timed or not.
            </p></li><li><p>
              <code class="literal">SUM_TIMER_WAIT</code>
            </p><p>
              The total wait time of the summarized timed events. This
              value is calculated only for timed events because nontimed
              events have a wait time of <code class="literal">NULL</code>. The
              same is true for the other
              <code class="literal"><em class="replaceable"><code>xxx</code></em>_TIMER_WAIT</code>
              values.
            </p></li><li><p>
              <code class="literal">MIN_TIMER_WAIT</code>
            </p><p>
              The minimum wait time of the summarized timed events.
            </p></li><li><p>
              <code class="literal">AVG_TIMER_WAIT</code>
            </p><p>
              The average wait time of the summarized timed events.
            </p></li><li><p>
              <code class="literal">MAX_TIMER_WAIT</code>
            </p><p>
              The maximum wait time of the summarized timed events.
            </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="file-summary-tables"></a>20.7.4.2. File I/O Summary Tables</h4></div></div></div><a class="indexterm" name="id1441544"></a><a class="indexterm" name="id1441557"></a><a class="indexterm" name="id1441569"></a><a class="indexterm" name="id1441582"></a><p>
          The file I/O summary tables aggregate information about I/O
          operations:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <a href="performance-schema.html#file-summary-tables" title="20.7.4.2. File I/O Summary Tables"><code class="literal">file_summary_by_event_name</code></a>:
              File events summarized per event name
            </p></li><li><p>
              <a href="performance-schema.html#file-summary-tables" title="20.7.4.2. File I/O Summary Tables"><code class="literal">file_summary_by_instance</code></a>:
              File events summarized per file instance
            </p></li></ul></div><p>
          For example:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM file_summary_by_instance\G</code></strong>
...
*************************** 2. row ***************************
                FILE_NAME: /var/mysql/share/english/errmsg.sys
               EVENT_NAME: wait/io/file/sql/ERRMSG
               COUNT_READ: 3
              COUNT_WRITE: 0
 SUM_NUMBER_OF_BYTES_READ: 42211
SUM_NUMBER_OF_BYTES_WRITE: 0
...
*************************** 6. row ***************************
                FILE_NAME: /var/mysql/data/binlog.000001
               EVENT_NAME: wait/io/file/sql/binlog
               COUNT_READ: 0
              COUNT_WRITE: 0
 SUM_NUMBER_OF_BYTES_READ: 0
SUM_NUMBER_OF_BYTES_WRITE: 0
...
</pre><p>
          <a href="sql-syntax.html#truncate-table" title="12.1.33. TRUNCATE TABLE Syntax"><code class="literal">TRUNCATE TABLE</code></a> is permitted for
          summary tables. It resets the counters to zero rather than
          removing rows.
        </p><p>
          The file I/O summary tables have these grouping columns to
          indicate how events are aggregated:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <a href="performance-schema.html#file-summary-tables" title="20.7.4.2. File I/O Summary Tables"><code class="literal">file_summary_by_event_name</code></a>
              has an <code class="literal">EVENT_NAME</code> column. Each row
              summarizes events for a given instrument.
            </p></li><li><p>
              <a href="performance-schema.html#file-summary-tables" title="20.7.4.2. File I/O Summary Tables"><code class="literal">file_summary_by_instance</code></a> has
              <code class="literal">FILE_NAME</code> and
              <code class="literal">EVENT_NAME</code> columns. Each row summarizes
              events for a given file instrument instance.
            </p></li></ul></div><p>
          The file I/O summary tables have these summary columns
          containing aggregated values:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <code class="literal">COUNT_READ</code>
            </p><p>
              The number of read operations in the summarized events.
            </p></li><li><p>
              <code class="literal">COUNT_WRITE</code>
            </p><p>
              The number of write operations in the summarized events.
            </p></li><li><p>
              <code class="literal">SUM_NUMBER_OF_BYTES_READ</code>
            </p><p>
              The number of bytes read in the summarized events.
            </p></li><li><p>
              <code class="literal">SUM_NUMBER_OF_BYTES_WRITE</code>
            </p><p>
              The number of bytes written in the summarized events.
            </p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="performance-schema-miscellaneous-tables"></a>20.7.5. Performance Schema Miscellaneous Tables</h3></div></div></div><div class="toc"><dl><dt><span class="section"><a href="performance-schema.html#performance-timers-table">20.7.5.1. The <code class="literal">performance_timers</code> Table</a></span></dt><dt><span class="section"><a href="performance-schema.html#threads-table">20.7.5.2. The <code class="literal">threads</code> Table</a></span></dt></dl></div><p>
        The following sections describe tables that do not fall into the
        table categories discussed in the preceding sections:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            <a href="performance-schema.html#performance-timers-table" title="20.7.5.1. The performance_timers Table"><code class="literal">performance_timers</code></a>: Which event
            timers are available.
          </p></li><li><p>
            <a href="performance-schema.html#threads-table" title="20.7.5.2. The threads Table"><code class="literal">threads</code></a>: Information about
            server threads.
          </p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="performance-timers-table"></a>20.7.5.1. The <code class="literal">performance_timers</code> Table</h4></div></div></div><a class="indexterm" name="id1441845"></a><a class="indexterm" name="id1441858"></a><p>
          The <a href="performance-schema.html#performance-timers-table" title="20.7.5.1. The performance_timers Table"><code class="literal">performance_timers</code></a> table
          shows which event timers are available:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM performance_timers;</code></strong>
+-------------+-----------------+------------------+----------------+
| TIMER_NAME  | TIMER_FREQUENCY | TIMER_RESOLUTION | TIMER_OVERHEAD |
+-------------+-----------------+------------------+----------------+
| CYCLE       |      2389029850 |                1 |             72 |
| NANOSECOND  |            NULL |             NULL |           NULL |
| MICROSECOND |         1000000 |                1 |            585 |
| MILLISECOND |            1035 |                1 |            738 |
| TICK        |             101 |                1 |            630 |
+-------------+-----------------+------------------+----------------+
</pre><p>
          If the values associated with a given timer name are
          <code class="literal">NULL</code>, that timer is not supported on your
          platform. The rows that do not contain <code class="literal">NULL</code>
          indicate which timers you can use in
          <a href="performance-schema.html#setup-timers-table" title="20.7.1.3. The setup_timers Table"><code class="literal">setup_timers</code></a>.
        </p><p>
          The <a href="performance-schema.html#performance-timers-table" title="20.7.5.1. The performance_timers Table"><code class="literal">performance_timers</code></a> table has
          these columns:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <code class="literal">TIMER_NAME</code>
            </p><p>
              The name by which to refer to the timer when configuring
              the <a href="performance-schema.html#setup-timers-table" title="20.7.1.3. The setup_timers Table"><code class="literal">setup_timers</code></a> table.
            </p></li><li><p>
              <code class="literal">TIMER_FREQUENCY</code>
            </p><p>
              The number of timer units per second. For a cycle timer,
              the frequency is generally related to the CPU speed. For
              example, on a system with a 2.4GHz processor, the
              <code class="literal">CYCLE</code> may be close to 2400000000.
            </p></li><li><p>
              <code class="literal">TIMER_RESOLUTION</code>
            </p><p>
              Indicates the number of timer units by which timer values
              increase. If a timer has a resolution of 10, its value
              increases by 10 each time.
            </p></li><li><p>
              <code class="literal">TIMER_OVERHEAD</code>
            </p><p>
              The minimal number of cycles of overhead to obtain one
              timing with the given timer. The Performance Schema
              determines this value by invoking the timer 20 times
              during initialization and picking the smallest value. The
              total overhead really is twice this amount because the
              instrumentation invokes the timer at the start and end of
              each event. The timer code is called only for timed
              events, so this overhead does not apply for nontimed
              events.
            </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="threads-table"></a>20.7.5.2. The <code class="literal">threads</code> Table</h4></div></div></div><a class="indexterm" name="id1442033"></a><a class="indexterm" name="id1442046"></a><p>
          The <a href="performance-schema.html#threads-table" title="20.7.5.2. The threads Table"><code class="literal">threads</code></a> table contains a row
          for each server thread:
        </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SELECT * FROM threads;</code></strong>
+-----------+----------------+----------------------------------------+
| THREAD_ID | PROCESSLIST_ID | NAME                                   |
+-----------+----------------+----------------------------------------+
|         0 |              0 | thread/sql/main                        |
|         1 |              0 | thread/innodb/io_handler_thread        |
|        16 |              0 | thread/sql/signal_handler              |
|        23 |              7 | thread/sql/one_connection              |
|         5 |              0 | thread/innodb/io_handler_thread        |
|        12 |              0 | thread/innodb/srv_lock_timeout_thread  |
|        22 |              6 | thread/sql/one_connection              |
...
</pre><p>
          If you have the <a href="server-administration.html#priv_process"><code class="literal">PROCESS</code></a>
          privilege, you can see all threads. Otherwise, you can see
          only your own threads (that is, threads associated with the
          MySQL account that you are using).
        </p><p>
          The <a href="performance-schema.html#threads-table" title="20.7.5.2. The threads Table"><code class="literal">threads</code></a> table has these
          columns:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              <code class="literal">THREAD_ID</code>
            </p><p>
              This is the unique identifier of an instrumented thread.
            </p></li><li><p>
              <code class="literal">PROCESSLIST_ID</code>
            </p><p>
              For threads that are displayed in
              <a href="information-schema.html#processlist-table" title="19.15. The INFORMATION_SCHEMA PROCESSLIST Table"><code class="literal">INFORMATION_SCHEMA.PROCESSLIST</code></a>,
              this is the <code class="literal">INFORMATION_SCHEMA.ID</code>
              value, which is also the value that
              <a href="functions.html#function_connection-id"><code class="literal">CONNECTION_ID()</code></a> would
              return within that thread. For background threads (threads
              not associated with a user connection),
              <code class="literal">PROCESSLIST_ID</code> is 0, so the values are
              not unique.
            </p><p>
              This column was named <code class="literal">ID</code> before MySQL
              5.5.8.
            </p></li><li><p>
              <code class="literal">NAME</code>
            </p><p>
              <code class="literal">NAME</code> is the name associated with the
              instrumentation of the code in the server. For example,
              <code class="literal">thread/sql/one_connection</code> corresponds
              to the thread function in the code responsible for
              handling a user connection, and
              <code class="literal">thread/sql/main</code> stands for the
              <code class="literal">main()</code> function of the server.
            </p></li></ul></div><p>
          The <a href="performance-schema.html#threads-table" title="20.7.5.2. The threads Table"><code class="literal">threads</code></a> table was named
          <code class="literal">PROCESSLIST</code> before MySQL 5.5.6.
        </p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-schema-system-variables"></a>20.8. Performance Schema System Variables</h2></div></div></div><p>
      The Performance Schema implements several system variables that
      provide configuration information:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW VARIABLES LIKE 'perf%';</code></strong>
+---------------------------------------------------+---------+
| Variable_name                                     | Value   |
+---------------------------------------------------+---------+
| performance_schema                                | ON      |
| performance_schema_events_waits_history_long_size | 10000   |
| performance_schema_events_waits_history_size      | 10      |
| performance_schema_max_cond_classes               | 80      |
| performance_schema_max_cond_instances             | 1000    |
| performance_schema_max_file_classes               | 50      |
| performance_schema_max_file_handles               | 32768   |
| performance_schema_max_file_instances             | 10000   |
| performance_schema_max_mutex_classes              | 200     |
| performance_schema_max_mutex_instances            | 1000000 |
| performance_schema_max_rwlock_classes             | 30      |
| performance_schema_max_rwlock_instances           | 1000000 |
| performance_schema_max_table_handles              | 100000  |
| performance_schema_max_table_instances            | 50000   |
| performance_schema_max_thread_classes             | 50      |
| performance_schema_max_thread_instances           | 1000    |
+---------------------------------------------------+---------+
</pre><div class="table"><a name="id1442279"></a><p class="title"><b>Table 20.1. Performance Schema Variable Reference</b></p><table summary="Performance Schema Variable Reference" border="1"><colgroup><col><col><col><col><col><col><col></colgroup><thead><tr><th>Name</th><th>Cmd-Line</th><th>Option file</th><th>System Var</th><th>Status Var</th><th>Var Scope</th><th>Dynamic</th></tr></thead><tbody><tr><td><a href="performance-schema.html#sysvar_performance_schema">performance_schema</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td> </td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#statvar_Performance_schema_xxx_classes_lost">Performance_schema_cond_classes_lost</a></td><td> </td><td> </td><td> </td><td>Yes</td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#statvar_Performance_schema_xxx_instances_lost">Performance_schema_cond_instances_lost</a></td><td> </td><td> </td><td> </td><td>Yes</td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#sysvar_performance_schema_events_waits_history_long_size">performance_schema_events_waits_history_long_size</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td> </td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#sysvar_performance_schema_events_waits_history_size">performance_schema_events_waits_history_size</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td> </td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#statvar_Performance_schema_xxx_classes_lost">Performance_schema_file_classes_lost</a></td><td> </td><td> </td><td> </td><td>Yes</td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#statvar_Performance_schema_xxx_handles_lost">Performance_schema_file_handles_lost</a></td><td> </td><td> </td><td> </td><td>Yes</td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#statvar_Performance_schema_xxx_instances_lost">Performance_schema_file_instances_lost</a></td><td> </td><td> </td><td> </td><td>Yes</td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#statvar_Performance_schema_locker_lost">Performance_schema_locker_lost</a></td><td> </td><td> </td><td> </td><td>Yes</td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#sysvar_performance_schema_max_cond_classes">performance_schema_max_cond_classes</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td> </td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#sysvar_performance_schema_max_cond_instances">performance_schema_max_cond_instances</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td> </td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#sysvar_performance_schema_max_file_classes">performance_schema_max_file_classes</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td> </td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#sysvar_performance_schema_max_file_handles">performance_schema_max_file_handles</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td> </td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#sysvar_performance_schema_max_file_instances">performance_schema_max_file_instances</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td> </td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#sysvar_performance_schema_max_mutex_classes">performance_schema_max_mutex_classes</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td> </td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#sysvar_performance_schema_max_mutex_instances">performance_schema_max_mutex_instances</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td> </td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#sysvar_performance_schema_max_rwlock_classes">performance_schema_max_rwlock_classes</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td> </td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#sysvar_performance_schema_max_rwlock_instances">performance_schema_max_rwlock_instances</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td> </td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#sysvar_performance_schema_max_table_handles">performance_schema_max_table_handles</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td> </td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#sysvar_performance_schema_max_table_instances">performance_schema_max_table_instances</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td> </td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#sysvar_performance_schema_max_thread_classes">performance_schema_max_thread_classes</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td> </td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#sysvar_performance_schema_max_thread_instances">performance_schema_max_thread_instances</a></td><td>Yes</td><td>Yes</td><td>Yes</td><td> </td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#statvar_Performance_schema_xxx_classes_lost">Performance_schema_mutex_classes_lost</a></td><td> </td><td> </td><td> </td><td>Yes</td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#statvar_Performance_schema_xxx_instances_lost">Performance_schema_mutex_instances_lost</a></td><td> </td><td> </td><td> </td><td>Yes</td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#statvar_Performance_schema_xxx_classes_lost">Performance_schema_rwlock_classes_lost</a></td><td> </td><td> </td><td> </td><td>Yes</td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#statvar_Performance_schema_xxx_instances_lost">Performance_schema_rwlock_instances_lost</a></td><td> </td><td> </td><td> </td><td>Yes</td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#statvar_Performance_schema_xxx_handles_lost">Performance_schema_table_handles_lost</a></td><td> </td><td> </td><td> </td><td>Yes</td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#statvar_Performance_schema_xxx_instances_lost">Performance_schema_table_instances_lost</a></td><td> </td><td> </td><td> </td><td>Yes</td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#statvar_Performance_schema_xxx_classes_lost">Performance_schema_thread_classes_lost</a></td><td> </td><td> </td><td> </td><td>Yes</td><td>Global</td><td>No</td></tr><tr><td><a href="performance-schema.html#statvar_Performance_schema_xxx_instances_lost">Performance_schema_thread_instances_lost</a></td><td> </td><td> </td><td> </td><td>Yes</td><td>Global</td><td>No</td></tr></tbody></table></div><p>
      The variables have the following meanings:
    </p><div class="itemizedlist"><ul type="disc"><li><p><a name="sysvar_performance_schema"></a>
          <a class="indexterm" name="id1443167"></a>

          <a class="indexterm" name="id1443176"></a>

          <a href="performance-schema.html#sysvar_performance_schema"><code class="literal">performance_schema</code></a>
        </p><p>
          The value of this variable is <code class="literal">ON</code> or
          <code class="literal">OFF</code> to indicate whether the Performance
          Schema is enabled. By default, the value is
          <code class="literal">OFF</code>. At server startup, you can specify
          this variable with no value or a value of 1 to enable it, or
          with a value of 0 to disable it.
        </p></li><li><p><a name="sysvar_performance_schema_events_waits_history_long_size"></a>
          <a class="indexterm" name="id1443227"></a>

          <a class="indexterm" name="id1443236"></a>

          <a href="performance-schema.html#sysvar_performance_schema_events_waits_history_long_size"><code class="literal">performance_schema_events_waits_history_long_size</code></a>
        </p><p>
          The number of rows in the
          <a href="performance-schema.html#events-waits-history-long-table" title="20.7.3.3. The events_waits_history_long Table"><code class="literal">events_waits_history_long</code></a> table.
        </p></li><li><p><a name="sysvar_performance_schema_events_waits_history_size"></a>
          <a class="indexterm" name="id1443276"></a>

          <a class="indexterm" name="id1443286"></a>

          <a href="performance-schema.html#sysvar_performance_schema_events_waits_history_size"><code class="literal">performance_schema_events_waits_history_size</code></a>
        </p><p>
          The number of rows per thread in the
          <a href="performance-schema.html#events-waits-history-table" title="20.7.3.2. The events_waits_history Table"><code class="literal">events_waits_history</code></a> table.
        </p></li><li><p><a name="sysvar_performance_schema_max_cond_classes"></a>
          <a class="indexterm" name="id1443326"></a>

          <a class="indexterm" name="id1443335"></a>

          <a href="performance-schema.html#sysvar_performance_schema_max_cond_classes"><code class="literal">performance_schema_max_cond_classes</code></a>
        </p><p>
          The maximum number of condition instruments.
        </p></li><li><p><a name="sysvar_performance_schema_max_cond_instances"></a>
          <a class="indexterm" name="id1443367"></a>

          <a class="indexterm" name="id1443377"></a>

          <a href="performance-schema.html#sysvar_performance_schema_max_cond_instances"><code class="literal">performance_schema_max_cond_instances</code></a>
        </p><p>
          The maximum number of instrumented condition objects.
        </p></li><li><p><a name="sysvar_performance_schema_max_file_classes"></a>
          <a class="indexterm" name="id1443409"></a>

          <a class="indexterm" name="id1443418"></a>

          <a href="performance-schema.html#sysvar_performance_schema_max_file_classes"><code class="literal">performance_schema_max_file_classes</code></a>
        </p><p>
          The maximum number of file instruments.
        </p></li><li><p><a name="sysvar_performance_schema_max_file_handles"></a>
          <a class="indexterm" name="id1443451"></a>

          <a class="indexterm" name="id1443460"></a>

          <a href="performance-schema.html#sysvar_performance_schema_max_file_handles"><code class="literal">performance_schema_max_file_handles</code></a>
        </p><p>
          The maximum number of opened file objects.
        </p><p>
          The value of
          <a href="performance-schema.html#sysvar_performance_schema_max_file_handles"><code class="literal">performance_schema_max_file_handles</code></a>
          should be greater than the value of
          <a href="server-administration.html#sysvar_open_files_limit"><code class="literal">open_files_limit</code></a>:
          <a href="server-administration.html#sysvar_open_files_limit"><code class="literal">open_files_limit</code></a> affects the
          maximum number of open file handles the server can support and
          <a href="performance-schema.html#sysvar_performance_schema_max_file_handles"><code class="literal">performance_schema_max_file_handles</code></a>
          affects how many of these file handles can be instrumented.
        </p></li><li><p><a name="sysvar_performance_schema_max_file_instances"></a>
          <a class="indexterm" name="id1443527"></a>

          <a class="indexterm" name="id1443536"></a>

          <a href="performance-schema.html#sysvar_performance_schema_max_file_instances"><code class="literal">performance_schema_max_file_instances</code></a>
        </p><p>
          The maximum number of instrumented file objects.
        </p></li><li><p><a name="sysvar_performance_schema_max_mutex_classes"></a>
          <a class="indexterm" name="id1443569"></a>

          <a class="indexterm" name="id1443578"></a>

          <a href="performance-schema.html#sysvar_performance_schema_max_mutex_classes"><code class="literal">performance_schema_max_mutex_classes</code></a>
        </p><p>
          The maximum number of mutex instruments.
        </p></li><li><p><a name="sysvar_performance_schema_max_mutex_instances"></a>
          <a class="indexterm" name="id1443610"></a>

          <a class="indexterm" name="id1443620"></a>

          <a href="performance-schema.html#sysvar_performance_schema_max_mutex_instances"><code class="literal">performance_schema_max_mutex_instances</code></a>
        </p><p>
          The maximum number of instrumented mutex objects.
        </p></li><li><p><a name="sysvar_performance_schema_max_rwlock_classes"></a>
          <a class="indexterm" name="id1443652"></a>

          <a class="indexterm" name="id1443661"></a>

          <a href="performance-schema.html#sysvar_performance_schema_max_rwlock_classes"><code class="literal">performance_schema_max_rwlock_classes</code></a>
        </p><p>
          The maximum number of rwlock instruments.
        </p></li><li><p><a name="sysvar_performance_schema_max_rwlock_instances"></a>
          <a class="indexterm" name="id1443694"></a>

          <a class="indexterm" name="id1443703"></a>

          <a href="performance-schema.html#sysvar_performance_schema_max_rwlock_instances"><code class="literal">performance_schema_max_rwlock_instances</code></a>
        </p><p>
          The maximum number of instrumented rwlock objects.
        </p></li><li><p><a name="sysvar_performance_schema_max_table_handles"></a>
          <a class="indexterm" name="id1443736"></a>

          <a class="indexterm" name="id1443745"></a>

          <a href="performance-schema.html#sysvar_performance_schema_max_table_handles"><code class="literal">performance_schema_max_table_handles</code></a>
        </p><p>
          The maximum number of opened table objects.
        </p></li><li><p><a name="sysvar_performance_schema_max_table_instances"></a>
          <a class="indexterm" name="id1443777"></a>

          <a class="indexterm" name="id1443787"></a>

          <a href="performance-schema.html#sysvar_performance_schema_max_table_instances"><code class="literal">performance_schema_max_table_instances</code></a>
        </p><p>
          The maximum number of instrumented table objects.
        </p></li><li><p><a name="sysvar_performance_schema_max_thread_classes"></a>
          <a class="indexterm" name="id1443819"></a>

          <a class="indexterm" name="id1443828"></a>

          <a href="performance-schema.html#sysvar_performance_schema_max_thread_classes"><code class="literal">performance_schema_max_thread_classes</code></a>
        </p><p>
          The maximum number of thread instruments.
        </p></li><li><p><a name="sysvar_performance_schema_max_thread_instances"></a>
          <a class="indexterm" name="id1443861"></a>

          <a class="indexterm" name="id1443870"></a>

          <a href="performance-schema.html#sysvar_performance_schema_max_thread_instances"><code class="literal">performance_schema_max_thread_instances</code></a>
        </p><p>
          The maximum number of instrumented thread objects.
        </p><p>
          The <a href="server-administration.html#sysvar_max_connections"><code class="literal">max_connections</code></a> and
          <a href="server-administration.html#sysvar_max_delayed_threads"><code class="literal">max_delayed_threads</code></a> system
          variables affect how many threads are run in the server.
          <a href="performance-schema.html#sysvar_performance_schema_max_thread_instances"><code class="literal">performance_schema_max_thread_instances</code></a>
          affects how many of these running threads can be instrumented.
          If you increase
          <a href="server-administration.html#sysvar_max_connections"><code class="literal">max_connections</code></a> or
          <a href="server-administration.html#sysvar_max_delayed_threads"><code class="literal">max_delayed_threads</code></a>, you
          should consider increasing
          <a href="performance-schema.html#sysvar_performance_schema_max_thread_instances"><code class="literal">performance_schema_max_thread_instances</code></a>
          so that
          <a href="performance-schema.html#sysvar_performance_schema_max_thread_instances"><code class="literal">performance_schema_max_thread_instances</code></a>
          is greater than the sum of
          <a href="server-administration.html#sysvar_max_connections"><code class="literal">max_connections</code></a> and
          <a href="server-administration.html#sysvar_max_delayed_threads"><code class="literal">max_delayed_threads</code></a>.
        </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-schema-status-variables"></a>20.9. Performance Schema Status Variables</h2></div></div></div><p>
      The Performance Schema implements several status variables that
      provide information about instrumentation that could not be loaded
      or created due to memory constraints:
    </p><pre class="programlisting">mysql&gt; <strong class="userinput"><code>SHOW STATUS LIKE 'perf%';</code></strong>
+------------------------------------------+-------+
| Variable_name                            | Value |
+------------------------------------------+-------+
| Performance_schema_cond_classes_lost     | 0     |
| Performance_schema_cond_instances_lost   | 0     |
| Performance_schema_file_classes_lost     | 0     |
| Performance_schema_file_handles_lost     | 0     |
| Performance_schema_file_instances_lost   | 0     |
| Performance_schema_locker_lost           | 0     |
| Performance_schema_mutex_classes_lost    | 0     |
| Performance_schema_mutex_instances_lost  | 0     |
| Performance_schema_rwlock_classes_lost   | 0     |
| Performance_schema_rwlock_instances_lost | 0     |
| Performance_schema_table_handles_lost    | 0     |
| Performance_schema_table_instances_lost  | 0     |
| Performance_schema_thread_classes_lost   | 0     |
| Performance_schema_thread_instances_lost | 0     |
+------------------------------------------+-------+
</pre><p>
      Names for these variables have several forms:
    </p><div class="itemizedlist"><ul type="disc"><li><p><a name="statvar_Performance_schema_xxx_classes_lost"></a>
          <code class="literal">Performance_schema_<em class="replaceable"><code>xxx</code></em>_classes_lost</code>
        </p><p>
          How many instruments of type <em class="replaceable"><code>xxx</code></em>
          could not be loaded.
        </p></li><li><p><a name="statvar_Performance_schema_xxx_instances_lost"></a>
          <code class="literal">Performance_schema_<em class="replaceable"><code>xxx</code></em>_instances_lost</code>
        </p><p>
          How many instances of object type
          <em class="replaceable"><code>xxx</code></em> could not be created.
        </p></li><li><p><a name="statvar_Performance_schema_xxx_handles_lost"></a>
          <code class="literal">Performance_schema_<em class="replaceable"><code>xxx</code></em>_handles_lost</code>
        </p><p>
          How many instances of object type
          <em class="replaceable"><code>xxx</code></em> could not be opened.
        </p></li><li><p><a name="statvar_Performance_schema_locker_lost"></a>
          <code class="literal">Performance_schema_locker_lost</code>
        </p><p>
          How many events are “<span class="quote">lost</span>” or not recorded, due
          to the following conditions:
        </p><div class="itemizedlist"><ul type="circle"><li><p>
              Events are recursive (for example, waiting for A caused a
              wait on B, which caused a wait on C).
            </p></li><li><p>
              The depth of the nested events stack is greater than the
              limit imposed by the implementation.
            </p></li></ul></div><p>
          Currently, events recorded by the Performance Schema are not
          recursive, so this variable should always be 0.
        </p></li></ul></div><p>
      For information on using these variables to check Performance
      Schema status, see
      <a href="performance-schema.html#performance-schema-status-monitoring" title="20.5. Performance Schema Status Monitoring">Section 20.5, “Performance Schema Status Monitoring”</a>.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-schema-and-plugins"></a>20.10. Performance Schema and Plugins</h2></div></div></div><p>
      Removing a plugin with <a href="sql-syntax.html#uninstall-plugin" title="12.7.3.4. UNINSTALL PLUGIN Syntax"><code class="literal">UNINSTALL
      PLUGIN</code></a> does not affect information already collected for
      code in that plugin. Time spent executing the code while the
      plugin was loaded was still spent even if the plugin is unloaded
      later. The associated event information, including aggregate
      information, remains readable in
      <code class="literal">performance_schema</code> database tables. For
      additional information about the effect of plugin installation and
      removal, see
      <a href="performance-schema.html#performance-schema-status-monitoring" title="20.5. Performance Schema Status Monitoring">Section 20.5, “Performance Schema Status Monitoring”</a>.
    </p><p>
      A plugin implementor who instruments plugin code should document
      its instrumentation characteristics to enable those who load the
      plugin to account for its requirements. For example, a third-party
      storage engine should include in its documentation how much memory
      the engine needs for mutex and other instruments.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="performance-schema-examples"></a>20.11. Using the Performance Schema to Diagnose Problems</h2></div></div></div><p>
      The Performance Schema is a tool to help a DBA do performance
      tuning by taking real measurements instead of “<span class="quote">wild
      guesses.</span>” This section demonstrates some ways to use the
      Performance Schema for this purpose. The discussion here relies on
      the use of event filtering, which is described in
      <a href="performance-schema.html#performance-schema-filtering" title="20.2.3.2. Performance Schema Event Filtering">Section 20.2.3.2, “Performance Schema Event Filtering”</a>.
    </p><p>
      The following example provides one methodology that you can use to
      analyze a repeatable problem, such as investigating a performance
      bottleneck. To begin, you should have a repeatable use case where
      performance is deemed “<span class="quote">too slow</span>” and needs
      optimization, and you should enable all instrumentation (no
      pre-filtering at all).
    </p><div class="orderedlist"><ol type="1"><li><p>
          Run the use case.
        </p></li><li><p>
          Using the Performance Schema tables, analyze the root cause of
          the performance problem. This analysis will rely heavily on
          post-filtering.
        </p></li><li><p>
          For problem areas that are ruled out, disable the
          corresponding instruments. For example, if analysis shows that
          the issue is not related to file I/O in a particular storage
          engine, disable the file I/O instruments for that engine. Then
          truncate the history and summary tables to remove previously
          collected events.
        </p></li><li><p>
          Repeat the process at step 1.
        </p><p>
          At each iteration, the Performance Schema output, particularly
          the <a href="performance-schema.html#events-waits-history-long-table" title="20.7.3.3. The events_waits_history_long Table"><code class="literal">events_waits_history_long</code></a>
          table, will contain less and less “<span class="quote">noise</span>” caused
          by nonsignificant instruments, and given that this table has a
          fixed size, will contain more and more data relevant to the
          analysis of the problem at hand.
        </p><p>
          At each iteration, investigation should lead closer and closer
          to the root cause of the problem, as the
          “<span class="quote">signal/noise</span>” ratio will improve, making
          analysis easier.
        </p></li><li><p>
          Once a root cause of performance bottleneck is identified,
          take the appropriate corrective action, such as:
        </p><div class="itemizedlist"><ul type="disc"><li><p>
              Tune the server parameters (cache sizes, memory, and so
              forth).
            </p></li><li><p>
              Tune a query by writing it differently,
            </p></li><li><p>
              Tune the database schema (tables, indexes, and so forth).
            </p></li><li><p>
              Tune the code (this applies to storage engine or server
              developers only).
            </p></li></ul></div></li><li><p>
          Start again at step 1, to see the effects of the changes on
          performance.
        </p></li></ol></div><p>
      The <code class="literal">mutex_instances.LOCKED_BY_THREAD_ID</code> and
      <code class="literal">rwlock_instances.WRITE_LOCKED_BY_THREAD_ID</code>
      columns are extremely important for investigating performance
      bottlenecks or deadlocks. This is made possible by Performance
      Schema instrumentation as follows:
    </p><div class="orderedlist"><ol type="1"><li><p>
          Suppose that thread 1 is stuck waiting for a mutex.
        </p></li><li><p>
          You can determine what the thread is waiting for:
        </p><pre class="programlisting">SELECT * FROM events_waits_current WHERE THREAD_ID = <em class="replaceable"><code>thread_1</code></em>;
</pre><p>
          Say the query result identifies that the thread is waiting for
          mutex A, found in
          <code class="literal">events_waits_current.OBJECT_INSTANCE_BEGIN</code>.
        </p></li><li><p>
          You can determine which thread is holding mutex A:
        </p><pre class="programlisting">SELECT * FROM mutex_instances WHERE OBJECT_INSTANCE_BEGIN = <em class="replaceable"><code>mutex_A</code></em>;
</pre><p>
          Say the query result identifies that it is thread 2 holding
          mutex A, as found in
          <code class="literal">mutex_instances.LOCKED_BY_THREAD_ID</code>.
        </p></li><li><p>
          You can see what thread 2 is doing:
        </p><pre class="programlisting">SELECT * FROM events_waits_current WHERE THREAD_ID = <em class="replaceable"><code>thread_2</code></em>;
</pre></li></ol></div></div></div><div class="copyright-footer">
    Copyright © 1997, 2012, Oracle and/or its affiliates. All
    rights reserved.
  <a href="preface.html#legalnotice">Legal Notices</a></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="information-schema.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="connectors-apis.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 19. <code class="literal">INFORMATION_SCHEMA</code> Tables </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 21. Connectors and APIs</td></tr></table></div></body></html>
