  <div id="fileHeader">
    <h1>text_helper.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>actionpack/lib/action_view/helpers/text_helper.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Wed Jan 24 11:08:37 -0800 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require File.dirname(__FILE__) + '/tag_helper'

module ActionView
  module Helpers #:nodoc:
    # The TextHelper Module provides a set of methods for filtering, formatting 
    # and transforming strings that can reduce the amount of inline Ruby code in 
    # your views. These helper methods extend ActionView making them callable 
    # within your template files as shown in the following example which truncates
    # the title of each post to 10 characters.
    #
    #   &lt;% @posts.each do |post| %&gt;
    #     # post == 'This is my title'
    #     Title: &lt;%= truncate(post.title, 10) %&gt;
    #   &lt;% end %&gt;
    #    =&gt; Title: This is my...
    module TextHelper      
      # The preferred method of outputting text in your views is to use the 
      # &lt;%= &quot;text&quot; %&gt; eRuby syntax. The regular _puts_ and _print_ methods 
      # do not operate as expected in an eRuby code block. If you absolutely must 
      # output text within a code block, you can use the concat method.
      #
      #   &lt;% concat &quot;hello&quot;, binding %&gt;
      # is equivalent to using:
      #   &lt;%= &quot;hello&quot; %&gt;
      def concat(string, binding)
        eval(&quot;_erbout&quot;, binding).concat(string)
      end

      # If +text+ is longer than +length+, +text+ will be truncated to the length of 
      # +length+ and the last three characters will be replaced with the +truncate_string+.
      #
      #   truncate(&quot;Once upon a time in a world far far away&quot;, 14)  
      #    =&gt; Once upon a...
      def truncate(text, length = 30, truncate_string = &quot;...&quot;)
        if text.nil? then return end
        l = length - truncate_string.chars.length
        text.chars.length &gt; length ? text.chars[0...l] + truncate_string : text
      end

      # Highlights +phrase+ everywhere it is found in +text+ by inserting it into
      # a +highlighter+ string. The highlighter can be specialized by passing +highlighter+ 
      # as a single-quoted string with \1 where the phrase is to be inserted.
      #
      #   highlight('You searched for: rails', 'rails')  
      #    =&gt; You searched for: &lt;strong class=&quot;highlight&quot;&gt;rails&lt;/strong&gt;
      def highlight(text, phrase, highlighter = '&lt;strong class=&quot;highlight&quot;&gt;\1&lt;/strong&gt;')
        if phrase.blank? then return text end
        text.gsub(/(#{Regexp.escape(phrase)})/i, highlighter) unless text.nil?
      end

      # Extracts an excerpt from +text+ that matches the first instance of +phrase+. 
      # The +radius+ expands the excerpt on each side of +phrase+ by the number of characters
      # defined in +radius+. If the excerpt radius overflows the beginning or end of the +text+,
      # then the +excerpt_string+ will be prepended/appended accordingly. If the +phrase+ 
      # isn't found, nil is returned.
      #
      #   excerpt('This is an example', 'an', 5) 
      #    =&gt; &quot;...s is an examp...&quot;
      #
      #   excerpt('This is an example', 'is', 5) 
      #    =&gt; &quot;This is an...&quot;
      def excerpt(text, phrase, radius = 100, excerpt_string = &quot;...&quot;)
        if text.nil? || phrase.nil? then return end
        phrase = Regexp.escape(phrase)

        if found_pos = text.chars =~ /(#{phrase})/i
          start_pos = [ found_pos - radius, 0 ].max
          end_pos   = [ found_pos + phrase.chars.length + radius, text.chars.length ].min

          prefix  = start_pos &gt; 0 ? excerpt_string : &quot;&quot;
          postfix = end_pos &lt; text.chars.length ? excerpt_string : &quot;&quot;

          prefix + text.chars[start_pos..end_pos].strip + postfix
        else
          nil
        end
      end

      # Attempts to pluralize the +singular+ word unless +count+ is 1. If +plural+
      # is supplied, it will use that when count is &gt; 1, if the ActiveSupport Inflector 
      # is loaded, it will use the Inflector to determine the plural form, otherwise 
      # it will just add an 's' to the +singular+ word.
      #
      #   pluralize(1, 'person')  =&gt; 1 person
      #   pluralize(2, 'person')  =&gt; 2 people
      #   pluralize(3, 'person', 'users')  =&gt; 3 users
      def pluralize(count, singular, plural = nil)
         &quot;#{count} &quot; + if count == 1 || count == '1'
          singular
        elsif plural
          plural
        elsif Object.const_defined?(&quot;Inflector&quot;)
          Inflector.pluralize(singular)
        else
          singular + &quot;s&quot;
        end
      end

      # Wraps the +text+ into lines no longer than +line_width+ width. This method
      # breaks on the first whitespace character that does not exceed +line_width+.
      #
      #   word_wrap('Once upon a time', 4)
      #    =&gt; Once\nupon\na\ntime
      def word_wrap(text, line_width = 80)
        text.gsub(/\n/, &quot;\n\n&quot;).gsub(/(.{1,#{line_width}})(\s+|$)/, &quot;\\1\n&quot;).strip
      end

      begin
        require_library_or_gem &quot;redcloth&quot; unless Object.const_defined?(:RedCloth)

        # Returns the text with all the Textile codes turned into HTML tags.
        # &lt;i&gt;This method is only available if RedCloth[http://whytheluckystiff.net/ruby/redcloth/]
        # is available&lt;/i&gt;.
        def textilize(text)
          if text.blank?
            &quot;&quot;
          else
            textilized = RedCloth.new(text, [ :hard_breaks ])
            textilized.hard_breaks = true if textilized.respond_to?(&quot;hard_breaks=&quot;)
            textilized.to_html
          end
        end

        # Returns the text with all the Textile codes turned into HTML tags, 
        # but without the bounding &lt;p&gt; tag that RedCloth adds.
        # &lt;i&gt;This method is only available if RedCloth[http://whytheluckystiff.net/ruby/redcloth/]
        # is available&lt;/i&gt;.
        def textilize_without_paragraph(text)
          textiled = textilize(text)
          if textiled[0..2] == &quot;&lt;p&gt;&quot; then textiled = textiled[3..-1] end
          if textiled[-4..-1] == &quot;&lt;/p&gt;&quot; then textiled = textiled[0..-5] end
          return textiled
        end
      rescue LoadError
        # We can't really help what's not there
      end

      begin
        require_library_or_gem &quot;bluecloth&quot; unless Object.const_defined?(:BlueCloth)

        # Returns the text with all the Markdown codes turned into HTML tags.
        # &lt;i&gt;This method is only available if BlueCloth[http://www.deveiate.org/projects/BlueCloth]
        # is available&lt;/i&gt;.
        def markdown(text)
          text.blank? ? &quot;&quot; : BlueCloth.new(text).to_html
        end
      rescue LoadError
        # We can't really help what's not there
      end
      
      # Returns +text+ transformed into HTML using simple formatting rules.
      # Two or more consecutive newlines(&lt;tt&gt;\n\n&lt;/tt&gt;) are considered as a 
      # paragraph and wrapped in &lt;tt&gt;&lt;p&gt;&lt;/tt&gt; tags. One newline (&lt;tt&gt;\n&lt;/tt&gt;) is
      # considered as a linebreak and a &lt;tt&gt;&lt;br /&gt;&lt;/tt&gt; tag is appended. This
      # method does not remove the newlines from the +text+. 
      def simple_format(text)
        content_tag 'p', text.to_s.
          gsub(/\r\n?/, &quot;\n&quot;).                    # \r\n and \r -&gt; \n
          gsub(/\n\n+/, &quot;&lt;/p&gt;\n\n&lt;p&gt;&quot;).           # 2+ newline  -&gt; paragraph
          gsub(/([^\n]\n)(?=[^\n])/, '\1&lt;br /&gt;')  # 1 newline   -&gt; br
      end

      # Turns all urls and email addresses into clickable links. The +link+ parameter 
      # will limit what should be linked. You can add html attributes to the links using
      # +href_options+. Options for +link+ are &lt;tt&gt;:all&lt;/tt&gt; (default), 
      # &lt;tt&gt;:email_addresses&lt;/tt&gt;, and &lt;tt&gt;:urls&lt;/tt&gt;.
      #
      #   auto_link(&quot;Go to http://www.rubyonrails.org and say hello to david@loudthinking.com&quot;) =&gt;
      #     Go to &lt;a href=&quot;http://www.rubyonrails.org&quot;&gt;http://www.rubyonrails.org&lt;/a&gt; and
      #     say hello to &lt;a href=&quot;mailto:david@loudthinking.com&quot;&gt;david@loudthinking.com&lt;/a&gt;
      #
      # If a block is given, each url and email address is yielded and the
      # result is used as the link text.
      #
      #   auto_link(post.body, :all, :target =&gt; '_blank') do |text|
      #     truncate(text, 15)
      #   end
      def auto_link(text, link = :all, href_options = {}, &amp;block)
        return '' if text.blank?
        case link
          when :all             then auto_link_urls(auto_link_email_addresses(text, &amp;block), href_options, &amp;block)
          when :email_addresses then auto_link_email_addresses(text, &amp;block)
          when :urls            then auto_link_urls(text, href_options, &amp;block)
        end
      end

      # Strips link tags from +text+ leaving just the link label.
      #
      #   strip_links('&lt;a href=&quot;http://www.rubyonrails.org&quot;&gt;Ruby on Rails&lt;/a&gt;')
      #    =&gt; Ruby on Rails
      def strip_links(text)
        text.gsub(/&lt;a\b.*?&gt;(.*?)&lt;\/a&gt;/mi, '\1')
      end

      # Try to require the html-scanner library
      begin
        require 'html/tokenizer'
        require 'html/node'
      rescue LoadError
        # if there isn't a copy installed, use the vendor version in
        # ActionController
        $:.unshift File.join(File.dirname(__FILE__), &quot;..&quot;, &quot;..&quot;,
                      &quot;action_controller&quot;, &quot;vendor&quot;, &quot;html-scanner&quot;)
        require 'html/tokenizer'
        require 'html/node'
      end

      VERBOTEN_TAGS = %w(form script plaintext) unless defined?(VERBOTEN_TAGS)
      VERBOTEN_ATTRS = /^on/i unless defined?(VERBOTEN_ATTRS)

      # Sanitizes the +html+ by converting &lt;form&gt; and &lt;script&gt; tags into regular
      # text, and removing all &quot;onxxx&quot; attributes (so that arbitrary Javascript
      # cannot be executed). It also removes href= and src= attributes that start with
      # &quot;javascript:&quot;. You can modify what gets sanitized by defining VERBOTEN_TAGS
      # and VERBOTEN_ATTRS before this Module is loaded.
      #
      #   sanitize('&lt;script&gt; do_nasty_stuff() &lt;/script&gt;')
      #    =&gt; &amp;lt;script&gt; do_nasty_stuff() &amp;lt;/script&gt;
      #   sanitize('&lt;a href=&quot;javascript: sucker();&quot;&gt;Click here for $100&lt;/a&gt;')
      #    =&gt; &lt;a&gt;Click here for $100&lt;/a&gt;
      def sanitize(html)
        # only do this if absolutely necessary
        if html.index(&quot;&lt;&quot;)
          tokenizer = HTML::Tokenizer.new(html)
          new_text = &quot;&quot;

          while token = tokenizer.next
            node = HTML::Node.parse(nil, 0, 0, token, false)
            new_text &lt;&lt; case node
              when HTML::Tag
                if VERBOTEN_TAGS.include?(node.name)
                  node.to_s.gsub(/&lt;/, &quot;&amp;lt;&quot;)
                else
                  if node.closing != :close
                    node.attributes.delete_if { |attr,v| attr =~ VERBOTEN_ATTRS }
                    %w(href src).each do |attr|
                      node.attributes.delete attr if node.attributes[attr] =~ /^javascript:/i
                    end
                  end
                  node.to_s
                end
              else
                node.to_s.gsub(/&lt;/, &quot;&amp;lt;&quot;)
            end
          end

          html = new_text
        end

        html
      end
      
      # Strips all HTML tags from the +html+, including comments.  This uses the 
      # html-scanner tokenizer and so its HTML parsing ability is limited by 
      # that of html-scanner.
      def strip_tags(html)     
        return html if html.blank?
        if html.index(&quot;&lt;&quot;)
          text = &quot;&quot;
          tokenizer = HTML::Tokenizer.new(html)

          while token = tokenizer.next
            node = HTML::Node.parse(nil, 0, 0, token, false)
            # result is only the content of any Text nodes
            text &lt;&lt; node.to_s if node.class == HTML::Text  
          end
          # strip any comments, and if they have a newline at the end (ie. line with
          # only a comment) strip that too
          text.gsub(/&lt;!--(.*?)--&gt;[\n]?/m, &quot;&quot;) 
        else
          html # already plain text
        end 
      end
      
      # Creates a Cycle object whose _to_s_ method cycles through elements of an
      # array every time it is called. This can be used for example, to alternate 
      # classes for table rows:
      #
      #   &lt;% @items.each do |item| %&gt;
      #     &lt;tr class=&quot;&lt;%= cycle(&quot;even&quot;, &quot;odd&quot;) -%&gt;&quot;&gt;
      #       &lt;td&gt;item&lt;/td&gt;
      #     &lt;/tr&gt;
      #   &lt;% end %&gt;
      #
      # You can use named cycles to allow nesting in loops.  Passing a Hash as 
      # the last parameter with a &lt;tt&gt;:name&lt;/tt&gt; key will create a named cycle.
      # You can manually reset a cycle by calling reset_cycle and passing the 
      # name of the cycle.
      #
      #   &lt;% @items.each do |item| %&gt;
      #     &lt;tr class=&quot;&lt;%= cycle(&quot;even&quot;, &quot;odd&quot;, :name =&gt; &quot;row_class&quot;)
      #       &lt;td&gt;
      #         &lt;% item.values.each do |value| %&gt;
      #           &lt;span style=&quot;color:&lt;%= cycle(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, :name =&gt; &quot;colors&quot;) -%&gt;&quot;&gt;
      #             value
      #           &lt;/span&gt;
      #         &lt;% end %&gt;
      #         &lt;% reset_cycle(&quot;colors&quot;) %&gt;
      #       &lt;/td&gt;
      #    &lt;/tr&gt;
      #  &lt;% end %&gt;
      def cycle(first_value, *values)
        if (values.last.instance_of? Hash)
          params = values.pop
          name = params[:name]
        else
          name = &quot;default&quot;
        end
        values.unshift(first_value)

        cycle = get_cycle(name)
        if (cycle.nil? || cycle.values != values)
          cycle = set_cycle(name, Cycle.new(*values))
        end
        return cycle.to_s
      end
      
      # Resets a cycle so that it starts from the first element the next time 
      # it is called. Pass in +name+ to reset a named cycle.
      def reset_cycle(name = &quot;default&quot;)
        cycle = get_cycle(name)
        cycle.reset unless cycle.nil?
      end

      class Cycle #:nodoc:
        attr_reader :values
        
        def initialize(first_value, *values)
          @values = values.unshift(first_value)
          reset
        end
        
        def reset
          @index = 0
        end

        def to_s
          value = @values[@index].to_s
          @index = (@index + 1) % @values.size
          return value
        end
      end
      
      private
        # The cycle helpers need to store the cycles in a place that is
        # guaranteed to be reset every time a page is rendered, so it
        # uses an instance variable of ActionView::Base.
        def get_cycle(name)
          @_cycles = Hash.new unless defined?(@_cycles)
          return @_cycles[name]
        end
        
        def set_cycle(name, cycle_object)
          @_cycles = Hash.new unless defined?(@_cycles)
          @_cycles[name] = cycle_object
        end

        AUTO_LINK_RE = %r{
                        (                          # leading text
                          &lt;\w+.*?&gt;|                # leading HTML tag, or
                          [^=!:'&quot;/]|               # leading punctuation, or 
                          ^                        # beginning of line
                        )
                        (
                          (?:https?://)|           # protocol spec, or
                          (?:www\.)                # www.*
                        ) 
                        (
                          [-\w]+                   # subdomain or domain
                          (?:\.[-\w]+)*            # remaining subdomains or domain
                          (?::\d+)?                # port
                          (?:/(?:(?:[~\w\+%-]|(?:[,.;:][^\s$]))+)?)* # path
                          (?:\?[\w\+%&amp;=.;-]+)?     # query string
                          (?:\#[\w\-]*)?           # trailing anchor
                        )
                        ([[:punct:]]|\s|&lt;|$)       # trailing text
                       }x unless const_defined?(:AUTO_LINK_RE)

        # Turns all urls into clickable links.  If a block is given, each url
        # is yielded and the result is used as the link text.
        def auto_link_urls(text, href_options = {})
          extra_options = tag_options(href_options.stringify_keys) || &quot;&quot;
          text.gsub(AUTO_LINK_RE) do
            all, a, b, c, d = $&amp;, $1, $2, $3, $4
            if a =~ /&lt;a\s/i # don't replace URL's that are already linked
              all
            else
              text = b + c
              text = yield(text) if block_given?
              %(#{a}&lt;a href=&quot;#{b==&quot;www.&quot;?&quot;http://www.&quot;:b}#{c}&quot;#{extra_options}&gt;#{text}&lt;/a&gt;#{d})
            end
          end
        end

        # Turns all email addresses into clickable links.  If a block is given,
        # each email is yielded and the result is used as the link text.
        def auto_link_email_addresses(text)
          text.gsub(/([\w\.!#\$%\-+.]+@[A-Za-z0-9\-]+(\.[A-Za-z0-9\-]+)+)/) do
            text = $1
            text = yield(text) if block_given?
            %{&lt;a href=&quot;mailto:#{$1}&quot;&gt;#{text}&lt;/a&gt;}
          end
        end
    end
  end
end
</pre>
    </div>