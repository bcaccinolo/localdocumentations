  <div id="fileHeader">
    <h1>java_script_macros_helper.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>actionpack/lib/action_view/helpers/java_script_macros_helper.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Jan 05 12:12:45 -0800 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require File.dirname(__FILE__) + '/tag_helper'

module ActionView
  module Helpers
    # Provides a set of helpers for creating JavaScript macros that rely on and often bundle methods from JavaScriptHelper into
    # larger units. These macros also rely on counterparts in the controller that provide them with their backing. The in-place
    # editing relies on ActionController::Base.in_place_edit_for and the autocompletion relies on 
    # ActionController::Base.auto_complete_for.
    module JavaScriptMacrosHelper
      # DEPRECATION WARNING: This method will become a separate plugin when Rails 2.0 ships.
      #
      # Makes an HTML element specified by the DOM ID +field_id+ become an in-place
      # editor of a property.
      #
      # A form is automatically created and displayed when the user clicks the element,
      # something like this:
      #   &lt;form id=&quot;myElement-in-place-edit-form&quot; target=&quot;specified url&quot;&gt;
      #     &lt;input name=&quot;value&quot; text=&quot;The content of myElement&quot;/&gt;
      #     &lt;input type=&quot;submit&quot; value=&quot;ok&quot;/&gt;
      #     &lt;a onclick=&quot;javascript to cancel the editing&quot;&gt;cancel&lt;/a&gt;
      #   &lt;/form&gt;
      # 
      # The form is serialized and sent to the server using an AJAX call, the action on
      # the server should process the value and return the updated value in the body of
      # the reponse. The element will automatically be updated with the changed value
      # (as returned from the server).
      # 
      # Required +options+ are:
      # &lt;tt&gt;:url&lt;/tt&gt;::       Specifies the url where the updated value should
      #                       be sent after the user presses &quot;ok&quot;.
      # 
      # Addtional +options+ are:
      # &lt;tt&gt;:rows&lt;/tt&gt;::              Number of rows (more than 1 will use a TEXTAREA)
      # &lt;tt&gt;:cols&lt;/tt&gt;::              Number of characters the text input should span (works for both INPUT and TEXTAREA)
      # &lt;tt&gt;:size&lt;/tt&gt;::              Synonym for :cols when using a single line text input.
      # &lt;tt&gt;:cancel_text&lt;/tt&gt;::       The text on the cancel link. (default: &quot;cancel&quot;)
      # &lt;tt&gt;:save_text&lt;/tt&gt;::         The text on the save link. (default: &quot;ok&quot;)
      # &lt;tt&gt;:loading_text&lt;/tt&gt;::      The text to display while the data is being loaded from the server (default: &quot;Loading...&quot;)
      # &lt;tt&gt;:saving_text&lt;/tt&gt;::       The text to display when submitting to the server (default: &quot;Saving...&quot;)
      # &lt;tt&gt;:external_control&lt;/tt&gt;::  The id of an external control used to enter edit mode.
      # &lt;tt&gt;:load_text_url&lt;/tt&gt;::     URL where initial value of editor (content) is retrieved.
      # &lt;tt&gt;:options&lt;/tt&gt;::           Pass through options to the AJAX call (see prototype's Ajax.Updater)
      # &lt;tt&gt;:with&lt;/tt&gt;::              JavaScript snippet that should return what is to be sent
      #                               in the AJAX call, +form+ is an implicit parameter
      # &lt;tt&gt;:script&lt;/tt&gt;::            Instructs the in-place editor to evaluate the remote JavaScript response (default: false)
      # &lt;tt&gt;:click_to_edit_text&lt;/tt&gt;::The text shown during mouseover the editable text (default: &quot;Click to edit&quot;)
      def in_place_editor(field_id, options = {})
        function =  &quot;new Ajax.InPlaceEditor(&quot;
        function &lt;&lt; &quot;'#{field_id}', &quot;
        function &lt;&lt; &quot;'#{url_for(options[:url])}'&quot;

        js_options = {}
        js_options['cancelText'] = %('#{options[:cancel_text]}') if options[:cancel_text]
        js_options['okText'] = %('#{options[:save_text]}') if options[:save_text]
        js_options['loadingText'] = %('#{options[:loading_text]}') if options[:loading_text]
        js_options['savingText'] = %('#{options[:saving_text]}') if options[:saving_text]
        js_options['rows'] = options[:rows] if options[:rows]
        js_options['cols'] = options[:cols] if options[:cols]
        js_options['size'] = options[:size] if options[:size]
        js_options['externalControl'] = &quot;'#{options[:external_control]}'&quot; if options[:external_control]
        js_options['loadTextURL'] = &quot;'#{url_for(options[:load_text_url])}'&quot; if options[:load_text_url]        
        js_options['ajaxOptions'] = options[:options] if options[:options]
        js_options['evalScripts'] = options[:script] if options[:script]
        js_options['callback']   = &quot;function(form) { return #{options[:with]} }&quot; if options[:with]
        js_options['clickToEditText'] = %('#{options[:click_to_edit_text]}') if options[:click_to_edit_text]
        function &lt;&lt; (', ' + options_for_javascript(js_options)) unless js_options.empty?
        
        function &lt;&lt; ')'

        javascript_tag(function)
      end
      
      # DEPRECATION WARNING: This method will become a separate plugin when Rails 2.0 ships.
      #
      # Renders the value of the specified object and method with in-place editing capabilities.
      #
      # See the RDoc on ActionController::InPlaceEditing to learn more about this.
      def in_place_editor_field(object, method, tag_options = {}, in_place_editor_options = {})
        tag = ::ActionView::Helpers::InstanceTag.new(object, method, self)
        tag_options = {:tag =&gt; &quot;span&quot;, :id =&gt; &quot;#{object}_#{method}_#{tag.object.id}_in_place_editor&quot;, :class =&gt; &quot;in_place_editor_field&quot;}.merge!(tag_options)
        in_place_editor_options[:url] = in_place_editor_options[:url] || url_for({ :action =&gt; &quot;set_#{object}_#{method}&quot;, :id =&gt; tag.object.id })
        tag.to_content_tag(tag_options.delete(:tag), tag_options) +
        in_place_editor(tag_options[:id], in_place_editor_options)
      end
      
      # DEPRECATION WARNING: This method will become a separate plugin when Rails 2.0 ships.
      #
      # Adds AJAX autocomplete functionality to the text input field with the 
      # DOM ID specified by +field_id+.
      #
      # This function expects that the called action returns an HTML &lt;ul&gt; list,
      # or nothing if no entries should be displayed for autocompletion.
      #
      # You'll probably want to turn the browser's built-in autocompletion off,
      # so be sure to include an &lt;tt&gt;autocomplete=&quot;off&quot;&lt;/tt&gt; attribute with your text
      # input field.
      #
      # The autocompleter object is assigned to a Javascript variable named &lt;tt&gt;field_id&lt;/tt&gt;_auto_completer.
      # This object is useful if you for example want to trigger the auto-complete suggestions through
      # other means than user input (for that specific case, call the &lt;tt&gt;activate&lt;/tt&gt; method on that object). 
      # 
      # Required +options+ are:
      # &lt;tt&gt;:url&lt;/tt&gt;::                  URL to call for autocompletion results
      #                                  in url_for format.
      # 
      # Addtional +options+ are:
      # &lt;tt&gt;:update&lt;/tt&gt;::               Specifies the DOM ID of the element whose 
      #                                  innerHTML should be updated with the autocomplete
      #                                  entries returned by the AJAX request. 
      #                                  Defaults to &lt;tt&gt;field_id&lt;/tt&gt; + '_auto_complete'
      # &lt;tt&gt;:with&lt;/tt&gt;::                 A JavaScript expression specifying the
      #                                  parameters for the XMLHttpRequest. This defaults
      #                                  to 'fieldname=value'.
      # &lt;tt&gt;:frequency&lt;/tt&gt;::            Determines the time to wait after the last keystroke
      #                                  for the AJAX request to be initiated.
      # &lt;tt&gt;:indicator&lt;/tt&gt;::            Specifies the DOM ID of an element which will be
      #                                  displayed while autocomplete is running.
      # &lt;tt&gt;:tokens&lt;/tt&gt;::               A string or an array of strings containing
      #                                  separator tokens for tokenized incremental 
      #                                  autocompletion. Example: &lt;tt&gt;:tokens =&gt; ','&lt;/tt&gt; would
      #                                  allow multiple autocompletion entries, separated
      #                                  by commas.
      # &lt;tt&gt;:min_chars&lt;/tt&gt;::            The minimum number of characters that should be
      #                                  in the input field before an Ajax call is made
      #                                  to the server.
      # &lt;tt&gt;:on_hide&lt;/tt&gt;::              A Javascript expression that is called when the
      #                                  autocompletion div is hidden. The expression
      #                                  should take two variables: element and update.
      #                                  Element is a DOM element for the field, update
      #                                  is a DOM element for the div from which the
      #                                  innerHTML is replaced.
      # &lt;tt&gt;:on_show&lt;/tt&gt;::              Like on_hide, only now the expression is called
      #                                  then the div is shown.
      # &lt;tt&gt;:after_update_element&lt;/tt&gt;:: A Javascript expression that is called when the
      #                                  user has selected one of the proposed values. 
      #                                  The expression should take two variables: element and value.
      #                                  Element is a DOM element for the field, value
      #                                  is the value selected by the user.
      # &lt;tt&gt;:select&lt;/tt&gt;::               Pick the class of the element from which the value for 
      #                                  insertion should be extracted. If this is not specified,
      #                                  the entire element is used.
      def auto_complete_field(field_id, options = {})
        function =  &quot;var #{field_id}_auto_completer = new Ajax.Autocompleter(&quot;
        function &lt;&lt; &quot;'#{field_id}', &quot;
        function &lt;&lt; &quot;'&quot; + (options[:update] || &quot;#{field_id}_auto_complete&quot;) + &quot;', &quot;
        function &lt;&lt; &quot;'#{url_for(options[:url])}'&quot;
        
        js_options = {}
        js_options[:tokens] = array_or_string_for_javascript(options[:tokens]) if options[:tokens]
        js_options[:callback]   = &quot;function(element, value) { return #{options[:with]} }&quot; if options[:with]
        js_options[:indicator]  = &quot;'#{options[:indicator]}'&quot; if options[:indicator]
        js_options[:select]     = &quot;'#{options[:select]}'&quot; if options[:select]
        js_options[:paramName]  = &quot;'#{options[:param_name]}'&quot; if options[:param_name]
        js_options[:frequency]  = &quot;#{options[:frequency]}&quot; if options[:frequency]

        { :after_update_element =&gt; :afterUpdateElement, 
          :on_show =&gt; :onShow, :on_hide =&gt; :onHide, :min_chars =&gt; :minChars }.each do |k,v|
          js_options[v] = options[k] if options[k]
        end

        function &lt;&lt; (', ' + options_for_javascript(js_options) + ')')

        javascript_tag(function)
      end
      
      # DEPRECATION WARNING: This method will become a separate plugin when Rails 2.0 ships.
      #
      # Use this method in your view to generate a return for the AJAX autocomplete requests.
      #
      # Example action:
      #
      #   def auto_complete_for_item_title
      #     @items = Item.find(:all, 
      #       :conditions =&gt; [ 'LOWER(description) LIKE ?', 
      #       '%' + request.raw_post.downcase + '%' ])
      #     render :inline =&gt; &quot;&lt;%= auto_complete_result(@items, 'description') %&gt;&quot;
      #   end
      #
      # The auto_complete_result can of course also be called from a view belonging to the 
      # auto_complete action if you need to decorate it further.
      def auto_complete_result(entries, field, phrase = nil)
        return unless entries
        items = entries.map { |entry| content_tag(&quot;li&quot;, phrase ? highlight(entry[field], phrase) : h(entry[field])) }
        content_tag(&quot;ul&quot;, items.uniq)
      end
      
      # DEPRECATION WARNING: This method will become a separate plugin when Rails 2.0 ships.
      #
      # Wrapper for text_field with added AJAX autocompletion functionality.
      #
      # In your controller, you'll need to define an action called
      # auto_complete_for to respond the AJAX calls,
      # 
      # See the RDoc on ActionController::Macros::AutoComplete to learn more about this.
      def text_field_with_auto_complete(object, method, tag_options = {}, completion_options = {})
        (completion_options[:skip_style] ? &quot;&quot; : auto_complete_stylesheet) +
        text_field(object, method, tag_options) +
        content_tag(&quot;div&quot;, &quot;&quot;, :id =&gt; &quot;#{object}_#{method}_auto_complete&quot;, :class =&gt; &quot;auto_complete&quot;) +
        auto_complete_field(&quot;#{object}_#{method}&quot;, { :url =&gt; { :action =&gt; &quot;auto_complete_for_#{object}_#{method}&quot; } }.update(completion_options))
      end
      
      private
        def auto_complete_stylesheet
          content_tag('style', &lt;&lt;-EOT, :type =&gt; 'text/css')
            div.auto_complete {
              width: 350px;
              background: #fff;
            }
            div.auto_complete ul {
              border:1px solid #888;
              margin:0;
              padding:0;
              width:100%;
              list-style-type:none;
            }
            div.auto_complete ul li {
              margin:0;
              padding:3px;
            }
            div.auto_complete ul li.selected { 
              background-color: #ffb; 
            }
            div.auto_complete ul strong.highlight { 
              color: #800; 
              margin:0;
              padding:0;
            }
          EOT
        end
      
    end
  end
end
</pre>
    </div>