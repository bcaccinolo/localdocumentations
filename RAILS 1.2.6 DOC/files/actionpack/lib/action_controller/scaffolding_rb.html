  <div id="fileHeader">
    <h1>scaffolding.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>actionpack/lib/action_controller/scaffolding.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Sep 03 22:07:26 -0700 2006</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>module ActionController
  module Scaffolding # :nodoc:
    def self.included(base)
      base.extend(ClassMethods)
    end

    # Scaffolding is a way to quickly put an Active Record class online by providing a series of standardized actions
    # for listing, showing, creating, updating, and destroying objects of the class. These standardized actions come
    # with both controller logic and default templates that through introspection already know which fields to display
    # and which input types to use. Example:
    #
    #  class WeblogController &lt; ActionController::Base
    #    scaffold :entry
    #  end
    #
    # This tiny piece of code will add all of the following methods to the controller:
    #
    #  class WeblogController &lt; ActionController::Base
    #    verify :method =&gt; :post, :only =&gt; [ :destroy, :create, :update ],
    #           :redirect_to =&gt; { :action =&gt; :list }
    #
    #    def index
    #      list
    #    end
    #
    #    def list
    #      @entries = Entry.find(:all)
    #      render_scaffold &quot;list&quot;
    #    end
    #
    #    def show
    #      @entry = Entry.find(params[:id])
    #      render_scaffold
    #    end
    #
    #    def destroy
    #      Entry.find(params[:id]).destroy
    #      redirect_to :action =&gt; &quot;list&quot;
    #    end
    #
    #    def new
    #      @entry = Entry.new
    #      render_scaffold
    #    end
    #
    #    def create
    #      @entry = Entry.new(params[:entry])
    #      if @entry.save
    #        flash[:notice] = &quot;Entry was successfully created&quot;
    #        redirect_to :action =&gt; &quot;list&quot;
    #      else
    #        render_scaffold('new')
    #      end
    #    end
    #
    #    def edit
    #      @entry = Entry.find(params[:id])
    #      render_scaffold
    #    end
    #
    #    def update
    #      @entry = Entry.find(params[:id])
    #      @entry.attributes = params[:entry]
    #
    #      if @entry.save
    #        flash[:notice] = &quot;Entry was successfully updated&quot;
    #        redirect_to :action =&gt; &quot;show&quot;, :id =&gt; @entry
    #      else
    #        render_scaffold('edit')
    #      end
    #    end
    #  end
    #
    # The &lt;tt&gt;render_scaffold&lt;/tt&gt; method will first check to see if you've made your own template (like &quot;weblog/show.rhtml&quot; for
    # the show action) and if not, then render the generic template for that action. This gives you the possibility of using the
    # scaffold while you're building your specific application. Start out with a totally generic setup, then replace one template
    # and one action at a time while relying on the rest of the scaffolded templates and actions.
    module ClassMethods
      # Adds a swath of generic CRUD actions to the controller. The +model_id+ is automatically converted into a class name unless
      # one is specifically provide through &lt;tt&gt;options[:class_name]&lt;/tt&gt;. So &lt;tt&gt;scaffold :post&lt;/tt&gt; would use Post as the class
      # and @post/@posts for the instance variables.
      #
      # It's possible to use more than one scaffold in a single controller by specifying &lt;tt&gt;options[:suffix] = true&lt;/tt&gt;. This will
      # make &lt;tt&gt;scaffold :post, :suffix =&gt; true&lt;/tt&gt; use method names like list_post, show_post, and create_post
      # instead of just list, show, and post. If suffix is used, then no index method is added.
      def scaffold(model_id, options = {})
        options.assert_valid_keys(:class_name, :suffix)

        singular_name = model_id.to_s
        class_name    = options[:class_name] || singular_name.camelize
        plural_name   = singular_name.pluralize
        suffix        = options[:suffix] ? &quot;_#{singular_name}&quot; : &quot;&quot;

        unless options[:suffix]
          module_eval &lt;&lt;-&quot;end_eval&quot;, __FILE__, __LINE__
            def index
              list
            end
          end_eval
        end

        module_eval &lt;&lt;-&quot;end_eval&quot;, __FILE__, __LINE__

          verify :method =&gt; :post, :only =&gt; [ :destroy#{suffix}, :create#{suffix}, :update#{suffix} ],
                 :redirect_to =&gt; { :action =&gt; :list#{suffix} }


          def list#{suffix}
            @#{singular_name}_pages, @#{plural_name} = paginate :#{plural_name}, :per_page =&gt; 10
            render#{suffix}_scaffold &quot;list#{suffix}&quot;
          end

          def show#{suffix}
            @#{singular_name} = #{class_name}.find(params[:id])
            render#{suffix}_scaffold
          end

          def destroy#{suffix}
            #{class_name}.find(params[:id]).destroy
            redirect_to :action =&gt; &quot;list#{suffix}&quot;
          end

          def new#{suffix}
            @#{singular_name} = #{class_name}.new
            render#{suffix}_scaffold
          end

          def create#{suffix}
            @#{singular_name} = #{class_name}.new(params[:#{singular_name}])
            if @#{singular_name}.save
              flash[:notice] = &quot;#{class_name} was successfully created&quot;
              redirect_to :action =&gt; &quot;list#{suffix}&quot;
            else
              render#{suffix}_scaffold('new')
            end
          end

          def edit#{suffix}
            @#{singular_name} = #{class_name}.find(params[:id])
            render#{suffix}_scaffold
          end

          def update#{suffix}
            @#{singular_name} = #{class_name}.find(params[:id])
            @#{singular_name}.attributes = params[:#{singular_name}]

            if @#{singular_name}.save
              flash[:notice] = &quot;#{class_name} was successfully updated&quot;
              redirect_to :action =&gt; &quot;show#{suffix}&quot;, :id =&gt; @#{singular_name}
            else
              render#{suffix}_scaffold('edit')
            end
          end

          private
            def render#{suffix}_scaffold(action=nil)
              action ||= caller_method_name(caller)
              # logger.info (&quot;testing template:&quot; + &quot;\#{self.class.controller_path}/\#{action}&quot;) if logger

              if template_exists?(&quot;\#{self.class.controller_path}/\#{action}&quot;)
                render :action =&gt; action
              else
                @scaffold_class = #{class_name}
                @scaffold_singular_name, @scaffold_plural_name = &quot;#{singular_name}&quot;, &quot;#{plural_name}&quot;
                @scaffold_suffix = &quot;#{suffix}&quot;
                add_instance_variables_to_assigns

                @template.instance_variable_set(&quot;@content_for_layout&quot;, @template.render_file(scaffold_path(action.sub(/#{suffix}$/, &quot;&quot;)), false))

                if !active_layout.nil?
                  render :file =&gt; active_layout, :use_full_path =&gt; true
                else
                  render :file =&gt; scaffold_path('layout')
                end
              end
            end

            def scaffold_path(template_name)
              File.dirname(__FILE__) + &quot;/templates/scaffolds/&quot; + template_name + &quot;.rhtml&quot;
            end

            def caller_method_name(caller)
              caller.first.scan(/`(.*)'/).first.first # ' ruby-mode
            end
        end_eval
      end
    end
  end
end
</pre>
    </div>