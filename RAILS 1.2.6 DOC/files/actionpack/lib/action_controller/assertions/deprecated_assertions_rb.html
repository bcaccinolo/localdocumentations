  <div id="fileHeader">
    <h1>deprecated_assertions.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>actionpack/lib/action_controller/assertions/deprecated_assertions.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Wed Jan 17 22:23:03 -0800 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'rexml/document'

module ActionController #:nodoc:
  module Assertions #:nodoc:
    module DeprecatedAssertions #:nodoc:
      def assert_success(message=nil) #:nodoc:
        assert_response(:success, message)
      end
      deprecate :assert_success =&gt; &quot;use assert_response(:success)&quot;

      def assert_redirect(message=nil) #:nodoc:
        assert_response(:redirect, message)
      end
      deprecate :assert_redirect =&gt; &quot;use assert_response(:redirect)&quot;

      def assert_rendered_file(expected=nil, message=nil) #:nodoc:
        assert_template(expected, message)
      end
      deprecate :assert_rendered_file =&gt; :assert_template

      # ensure that the session has an object with the specified name
      def assert_session_has(key=nil, message=nil) #:nodoc:
        msg = build_message(message, &quot;&lt;?&gt; is not in the session &lt;?&gt;&quot;, key, @response.session)
        assert_block(msg) { @response.has_session_object?(key) }
      end
      deprecate :assert_session_has =&gt; &quot;use assert(@response.has_session_object?(key))&quot;

      # ensure that the session has no object with the specified name
      def assert_session_has_no(key=nil, message=nil) #:nodoc:
        msg = build_message(message, &quot;&lt;?&gt; is in the session &lt;?&gt;&quot;, key, @response.session)
        assert_block(msg) { !@response.has_session_object?(key) }
      end
      deprecate :assert_session_has_no =&gt; &quot;use assert(!@response.has_session_object?(key))&quot;

      def assert_session_equal(expected = nil, key = nil, message = nil) #:nodoc:
        msg = build_message(message, &quot;&lt;?&gt; expected in session['?'] but was &lt;?&gt;&quot;, expected, key, @response.session[key])
        assert_block(msg) { expected == @response.session[key] }
      end
      deprecate :assert_session_equal =&gt; &quot;use assert_equal(expected, @response[key])&quot;

      # -- cookie assertions ---------------------------------------------------

      def assert_no_cookie(key = nil, message = nil) #:nodoc:
        actual = @response.cookies[key]
        msg = build_message(message, &quot;&lt;?&gt; not expected in cookies['?']&quot;, actual, key)
        assert_block(msg) { actual.nil? or actual.empty? }
      end
      deprecate :assert_no_cookie =&gt; &quot;use assert(!@response.cookies.key?(key))&quot;
    
      def assert_cookie_equal(expected = nil, key = nil, message = nil) #:nodoc:
        actual = @response.cookies[key]
        actual = actual.first if actual
        msg = build_message(message, &quot;&lt;?&gt; expected in cookies['?'] but was &lt;?&gt;&quot;, expected, key, actual)
        assert_block(msg) { expected == actual }
      end
      deprecate :assert_cookie_equal =&gt; &quot;use assert(@response.cookies.key?(key))&quot;
    
      # -- flash assertions ---------------------------------------------------

      # ensure that the flash has an object with the specified name
      def assert_flash_has(key=nil, message=nil) #:nodoc:
        msg = build_message(message, &quot;&lt;?&gt; is not in the flash &lt;?&gt;&quot;, key, @response.flash)
        assert_block(msg) { @response.has_flash_object?(key) }
      end
      deprecate :assert_flash_has =&gt; &quot;use assert(@response.has_flash_object?(key))&quot;

      # ensure that the flash has no object with the specified name
      def assert_flash_has_no(key=nil, message=nil) #:nodoc:
        msg = build_message(message, &quot;&lt;?&gt; is in the flash &lt;?&gt;&quot;, key, @response.flash)
        assert_block(msg) { !@response.has_flash_object?(key) }
      end
      deprecate :assert_flash_has_no =&gt; &quot;use assert(!@response.has_flash_object?(key))&quot;

      # ensure the flash exists
      def assert_flash_exists(message=nil) #:nodoc:
        msg = build_message(message, &quot;the flash does not exist &lt;?&gt;&quot;, @response.session['flash'] )
        assert_block(msg) { @response.has_flash? }
      end
      deprecate :assert_flash_exists =&gt; &quot;use assert(@response.has_flash?)&quot;

      # ensure the flash does not exist
      def assert_flash_not_exists(message=nil) #:nodoc:
        msg = build_message(message, &quot;the flash exists &lt;?&gt;&quot;, @response.flash)
        assert_block(msg) { !@response.has_flash? }
      end
      deprecate :assert_flash_not_exists =&gt; &quot;use assert(!@response.has_flash?)&quot;
    
      # ensure the flash is empty but existent
      def assert_flash_empty(message=nil) #:nodoc:
        msg = build_message(message, &quot;the flash is not empty &lt;?&gt;&quot;, @response.flash)
        assert_block(msg) { !@response.has_flash_with_contents? }
      end
      deprecate :assert_flash_empty =&gt; &quot;use assert(!@response.has_flash_with_contents?)&quot;

      # ensure the flash is not empty
      def assert_flash_not_empty(message=nil) #:nodoc:
        msg = build_message(message, &quot;the flash is empty&quot;)
        assert_block(msg) { @response.has_flash_with_contents? }
      end
      deprecate :assert_flash_not_empty =&gt; &quot;use assert(@response.has_flash_with_contents?)&quot;
    
      def assert_flash_equal(expected = nil, key = nil, message = nil) #:nodoc:
        msg = build_message(message, &quot;&lt;?&gt; expected in flash['?'] but was &lt;?&gt;&quot;, expected, key, @response.flash[key])
        assert_block(msg) { expected == @response.flash[key] }
      end
      deprecate :assert_flash_equal =&gt; &quot;use assert_equal(expected, @response.flash[key])&quot;
    

      # ensure our redirection url is an exact match
      def assert_redirect_url(url=nil, message=nil) #:nodoc:
        assert_redirect(message)
        msg = build_message(message, &quot;&lt;?&gt; is not the redirected location &lt;?&gt;&quot;, url, @response.redirect_url)
        assert_block(msg) { @response.redirect_url == url }
      end
      deprecate :assert_redirect_url =&gt; &quot;use assert_equal(url, @response.redirect_url)&quot;

      # ensure our redirection url matches a pattern
      def assert_redirect_url_match(pattern=nil, message=nil) #:nodoc:
        assert_redirect(message)
        msg = build_message(message, &quot;&lt;?&gt; was not found in the location: &lt;?&gt;&quot;, pattern, @response.redirect_url)
        assert_block(msg) { @response.redirect_url_match?(pattern) }
      end
      deprecate :assert_redirect_url_match =&gt; &quot;use assert(@response.redirect_url_match?(pattern))&quot;

    
      # -- template assertions ------------------------------------------------

      # ensure that a template object with the given name exists
      def assert_template_has(key=nil, message=nil) #:nodoc:
        msg = build_message(message, &quot;&lt;?&gt; is not a template object&quot;, key )
        assert_block(msg) { @response.has_template_object?(key) }
      end
      deprecate :assert_template_has =&gt; &quot;use assert(@response.has_template_object?(key))&quot;

      # ensure that a template object with the given name does not exist
      def assert_template_has_no(key=nil,message=nil) #:nodoc:
        msg = build_message(message, &quot;&lt;?&gt; is a template object &lt;?&gt;&quot;, key, @response.template_objects[key])
        assert_block(msg) { !@response.has_template_object?(key) }
      end
      deprecate :assert_template_has_no =&gt; &quot;use assert(!@response.has_template_object?(key))&quot;

      # ensures that the object assigned to the template on +key+ is equal to +expected+ object.
      def assert_template_equal(expected = nil, key = nil, message = nil) #:nodoc:
        msg = build_message(message, &quot;&lt;?&gt; expected in assigns['?'] but was &lt;?&gt;&quot;, expected, key, @response.template.assigns[key.to_s])
        assert_block(msg) { expected == @response.template.assigns[key.to_s] }
      end
      alias_method :assert_assigned_equal, :assert_template_equal
      deprecate :assert_assigned_equal =&gt; &quot;use assert_equal(expected, @response.template.assigns[key.to_s])&quot;
      deprecate :assert_template_equal =&gt; &quot;use assert_equal(expected, @response.template.assigns[key.to_s])&quot;

      # Asserts that the template returns the +expected+ string or array based on the XPath +expression+.
      # This will only work if the template rendered a valid XML document.
      def assert_template_xpath_match(expression=nil, expected=nil, message=nil) #:nodoc:
        xml, matches = REXML::Document.new(@response.body), []
        xml.elements.each(expression) { |e| matches &lt;&lt; e.text }
        if matches.empty? then
          msg = build_message(message, &quot;&lt;?&gt; not found in document&quot;, expression)
          flunk(msg)
          return
        elsif matches.length &lt; 2 then
          matches = matches.first
        end

        msg = build_message(message, &quot;&lt;?&gt; found &lt;?&gt;, not &lt;?&gt;&quot;, expression, matches, expected)
        assert_block(msg) { matches == expected }
      end
      deprecate :assert_template_xpath_match =&gt; &quot;you should use assert_tag, instead&quot;

      # Assert the template object with the given name is an Active Record descendant and is valid.
      def assert_valid_record(key = nil, message = nil) #:nodoc:
        record = find_record_in_template(key)
        msg = build_message(message, &quot;Active Record is invalid &lt;?&gt;)&quot;, record.errors.full_messages)
        assert_block(msg) { record.valid? }
      end
      deprecate :assert_valid_record =&gt; &quot;use assert(assigns(key).valid?)&quot;

      # Assert the template object with the given name is an Active Record descendant and is invalid.
      def assert_invalid_record(key = nil, message = nil) #:nodoc:
        record = find_record_in_template(key)
        msg = build_message(message, &quot;Active Record is valid)&quot;)
        assert_block(msg) { !record.valid? }
      end
      deprecate :assert_invalid_record =&gt; &quot;use assert(!assigns(key).valid?)&quot;

      # Assert the template object with the given name is an Active Record descendant and the specified column(s) are valid.
      def assert_valid_column_on_record(key = nil, columns = &quot;&quot;, message = nil) #:nodoc:
        record = find_record_in_template(key)
        record.send(:validate)

        cols = glue_columns(columns)
        cols.delete_if { |col| !record.errors.invalid?(col) }
        msg = build_message(message, &quot;Active Record has invalid columns &lt;?&gt;)&quot;, cols.join(&quot;,&quot;) )
        assert_block(msg) { cols.empty? }
      end
      deprecate :assert_valid_column_on_record =&gt; &quot;use assert(!record.errors.invalid?(column)) instead&quot;

      # Assert the template object with the given name is an Active Record descendant and the specified column(s) are invalid.
      def assert_invalid_column_on_record(key = nil, columns = &quot;&quot;, message = nil) #:nodoc:
        record = find_record_in_template(key)
        record.send(:validate)

        cols = glue_columns(columns)
        cols.delete_if { |col| record.errors.invalid?(col) }
        msg = build_message(message, &quot;Active Record has valid columns &lt;?&gt;)&quot;, cols.join(&quot;,&quot;) )
        assert_block(msg) { cols.empty? }
      end
      deprecate :assert_invalid_column_on_record =&gt; &quot;use assert(record.errors.invalid?(column)) instead&quot;

      private
        def glue_columns(columns)
          cols = []
          cols &lt;&lt; columns if columns.class == String
          cols += columns if columns.class == Array
          cols
        end

        def find_record_in_template(key = nil)
          assert_not_nil assigns(key)
          record = @response.template_objects[key]

          assert_not_nil(record)
          assert_kind_of ActiveRecord::Base, record

          return record
        end
    end
  end
end
</pre>
    </div>