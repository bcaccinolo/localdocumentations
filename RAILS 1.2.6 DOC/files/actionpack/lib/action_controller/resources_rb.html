  <div id="fileHeader">
    <h1>resources.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>actionpack/lib/action_controller/resources.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Sep 30 23:44:07 -0700 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>module ActionController
  module Resources
    class Resource #:nodoc:
      attr_reader :collection_methods, :member_methods, :new_methods
      attr_reader :path_prefix, :new_name_prefix
      attr_reader :plural, :singular
      attr_reader :options

      def initialize(entities, options)
        @plural   = entities
        @singular = options[:singular] || plural.to_s.singularize

        @options = options

        arrange_actions
        add_default_actions
        set_prefixes
      end

      def controller
        @controller ||= (options[:controller] || plural).to_s
      end

      def path
        @path ||= &quot;#{path_prefix}/#{plural}&quot;
      end

      def new_path
        @new_path ||= &quot;#{path}/new&quot;
      end

      def member_path
        @member_path ||= &quot;#{path}/:id&quot;
      end

      def nesting_path_prefix
        @nesting_path_prefix ||= &quot;#{path}/:#{singular}_id&quot;
      end

      def deprecate_name_prefix?
        @name_prefix.blank? &amp;&amp; !@new_name_prefix.blank?
      end

      def name_prefix
        deprecate_name_prefix? ? @new_name_prefix : @name_prefix
      end

      def old_name_prefix
        @name_prefix
      end

      def nesting_name_prefix
        &quot;#{new_name_prefix}#{singular}_&quot;
      end

      def action_separator
        @action_separator ||= Base.resource_action_separator
      end

      protected
        def arrange_actions
          @collection_methods = arrange_actions_by_methods(options.delete(:collection))
          @member_methods     = arrange_actions_by_methods(options.delete(:member))
          @new_methods        = arrange_actions_by_methods(options.delete(:new))
        end

        def add_default_actions
          add_default_action(member_methods, :get, :edit)
          add_default_action(new_methods, :get, :new)
        end

        def set_prefixes
          @path_prefix = options.delete(:path_prefix)
          @name_prefix = options.delete(:name_prefix)
          @new_name_prefix = options.delete(:new_name_prefix)
        end

        def arrange_actions_by_methods(actions)
          (actions || {}).inject({}) do |flipped_hash, (key, value)|
            (flipped_hash[value] ||= []) &lt;&lt; key
            flipped_hash
          end
        end

        def add_default_action(collection, method, action)
          (collection[method] ||= []).unshift(action)
        end
    end

    class SingletonResource &lt; Resource #:nodoc:
      def initialize(entity, options)
        @plural = @singular = entity
        @options = options
        arrange_actions
        add_default_actions
        set_prefixes
      end

      alias_method :member_path,         :path
      alias_method :nesting_path_prefix, :path
    end

    # Creates named routes for implementing verb-oriented controllers. This is
    # useful for implementing REST API's, where a single resource has different
    # behavior based on the HTTP verb (method) used to access it.
    # 
    # Example:
    #
    #   map.resources :messages 
    #
    #   class MessagesController &lt; ActionController::Base
    #     # GET messages_url
    #     def index
    #       # return all messages
    #     end
    # 
    #     # GET new_message_url
    #     def new
    #       # return an HTML form for describing a new message
    #     end
    # 
    #     # POST messages_url
    #     def create
    #       # create a new message
    #     end
    # 
    #     # GET message_url(:id =&gt; 1)
    #     def show
    #       # find and return a specific message
    #     end
    # 
    #     # GET edit_message_url(:id =&gt; 1)
    #     def edit
    #       # return an HTML form for editing a specific message
    #     end
    # 
    #     # PUT message_url(:id =&gt; 1)
    #     def update
    #       # find and update a specific message
    #     end
    # 
    #     # DELETE message_url(:id =&gt; 1)
    #     def destroy
    #       # delete a specific message
    #     end
    #   end
    # 
    # The #resources method sets HTTP method restrictions on the routes it generates. For example, making an
    # HTTP POST on &lt;tt&gt;new_message_url&lt;/tt&gt; will raise a RoutingError exception. The default route in 
    # &lt;tt&gt;config/routes.rb&lt;/tt&gt; overrides this and allows invalid HTTP methods for resource routes.
    # 
    # Along with the routes themselves, #resources generates named routes for use in
    # controllers and views. &lt;tt&gt;map.resources :messages&lt;/tt&gt; produces the following named routes and helpers:
    # 
    #   Named Route   Helpers
    #   messages      messages_url, hash_for_messages_url, 
    #                 messages_path, hash_for_messages_path
    #   message       message_url(id), hash_for_message_url(id), 
    #                 message_path(id), hash_for_message_path(id)
    #   new_message   new_message_url, hash_for_new_message_url, 
    #                 new_message_path, hash_for_new_message_path
    #   edit_message  edit_message_url(id), hash_for_edit_message_url(id),
    #                 edit_message_path(id), hash_for_edit_message_path(id)
    #
    # You can use these helpers instead of #url_for or methods that take #url_for parameters:
    # 
    #   redirect_to :controller =&gt; 'messages', :action =&gt; 'index'
    #   # becomes
    #   redirect_to messages_url
    #
    #   &lt;%= link_to &quot;edit this message&quot;, :controller =&gt; 'messages', :action =&gt; 'edit', :id =&gt; @message.id %&gt;
    #   # becomes
    #   &lt;%= link_to &quot;edit this message&quot;, edit_message_url(@message) # calls @message.id automatically
    #
    # Since web browsers don't support the PUT and DELETE verbs, you will need to add a parameter '_method' to your
    # form tags. The form helpers make this a little easier. For an update form with a &lt;tt&gt;@message&lt;/tt&gt; object:
    #
    #   &lt;%= form_tag message_path(@message), :method =&gt; :put %&gt;
    #   
    # or 
    #   
    #   &lt;% form_for :message, @message, :url =&gt; message_path(@message), :html =&gt; {:method =&gt; :put} do |f| %&gt;
    # 
    # The #resources method accepts various options, too, to customize the resulting
    # routes:
    # * &lt;tt&gt;:controller&lt;/tt&gt; -- specify the controller name for the routes.
    # * &lt;tt&gt;:singular&lt;/tt&gt; -- specify the singular name used in the member routes.
    # * &lt;tt&gt;:path_prefix&lt;/tt&gt; -- set a prefix to the routes with required route variables.
    #   Weblog comments usually belong to a post, so you might use resources like:
    #
    #     map.resources :articles
    #     map.resources :comments, :path_prefix =&gt; '/articles/:article_id'
    #
    #   You can nest resources calls to set this automatically:
    #
    #     map.resources :articles do |article|
    #       article.resources :comments
    #     end
    #
    #   The comment resources work the same, but must now include a value for :article_id.
    #   
    #     article_comments_url(@article)
    #     article_comment_url(@article, @comment)
    #
    #     article_comments_url(:article_id =&gt; @article)
    #     article_comment_url(:article_id =&gt; @article, :id =&gt; @comment)
    #
    # * &lt;tt&gt;:name_prefix&lt;/tt&gt; -- define a prefix for all generated routes, usually ending in an underscore.
    #   Use this if you have named routes that may clash.
    #
    #     map.resources :tags, :path_prefix =&gt; '/books/:book_id', :name_prefix =&gt; 'book_'
    #     map.resources :tags, :path_prefix =&gt; '/toys/:toy_id',   :name_prefix =&gt; 'toy_'
    #
    # * &lt;tt&gt;:collection&lt;/tt&gt; -- add named routes for other actions that operate on the collection.
    #   Takes a hash of &lt;tt&gt;#{action} =&gt; #{method}&lt;/tt&gt;, where method is &lt;tt&gt;:get&lt;/tt&gt;/&lt;tt&gt;:post&lt;/tt&gt;/&lt;tt&gt;:put&lt;/tt&gt;/&lt;tt&gt;:delete&lt;/tt&gt;
    #   or &lt;tt&gt;:any&lt;/tt&gt; if the method does not matter.  These routes map to a URL like /messages/rss, with a route of rss_messages_url.
    # * &lt;tt&gt;:member&lt;/tt&gt; -- same as :collection, but for actions that operate on a specific member.
    # * &lt;tt&gt;:new&lt;/tt&gt; -- same as :collection, but for actions that operate on the new resource action.
    #
    # If &lt;tt&gt;map.resources&lt;/tt&gt; is called with multiple resources, they all get the same options applied.
    #
    # Examples:
    # 
    #   map.resources :messages, :path_prefix =&gt; &quot;/thread/:thread_id&quot;
    #   # --&gt; GET /thread/7/messages/1
    #  
    #   map.resources :messages, :collection =&gt; { :rss =&gt; :get }
    #   # --&gt; GET /messages/rss (maps to the #rss action)
    #   #     also adds a named route called &quot;rss_messages&quot;
    # 
    #   map.resources :messages, :member =&gt; { :mark =&gt; :post }
    #   # --&gt; POST /messages/1/mark (maps to the #mark action)
    #   #     also adds a named route called &quot;mark_message&quot;
    # 
    #   map.resources :messages, :new =&gt; { :preview =&gt; :post }
    #   # --&gt; POST /messages/new/preview (maps to the #preview action)
    #   #     also adds a named route called &quot;preview_new_message&quot;
    # 
    #   map.resources :messages, :new =&gt; { :new =&gt; :any, :preview =&gt; :post }
    #   # --&gt; POST /messages/new/preview (maps to the #preview action)
    #   #     also adds a named route called &quot;preview_new_message&quot;
    #   # --&gt; /messages/new can be invoked via any request method
    # 
    #   map.resources :messages, :controller =&gt; &quot;categories&quot;,
    #         :path_prefix =&gt; &quot;/category/:category_id&quot;,
    #         :name_prefix =&gt; &quot;category_&quot;
    #   # --&gt; GET /categories/7/messages/1
    #   #     has named route &quot;category_message&quot;
    def resources(*entities, &amp;block)
      options = entities.last.is_a?(Hash) ? entities.pop : { }
      entities.each { |entity| map_resource entity, options.dup, &amp;block }
    end

    # Creates named routes for implementing verb-oriented controllers for a singleton resource. 
    # A singleton resource is global to the current user visiting the application, such as a user's
    # /account profile.
    # 
    # See map.resources for general conventions.  These are the main differences:
    #   - A singular name is given to map.resource.  The default controller name is taken from the singular name.
    #   - There is no &lt;tt&gt;:collection&lt;/tt&gt; option as there is only the singleton resource.
    #   - There is no &lt;tt&gt;:singular&lt;/tt&gt; option as the singular name is passed to map.resource.
    #   - No default index route is created for the singleton resource controller.
    #   - When nesting singleton resources, only the singular name is used as the path prefix (example: 'account/messages/1')
    #
    # Example:
    #
    #   map.resource :account 
    #
    #   class AccountController &lt; ActionController::Base
    #     # POST account_url
    #     def create
    #       # create an account
    #     end
    #
    #     # GET new_account_url
    #     def new
    #       # return an HTML form for describing the new account
    #     end
    #
    #     # GET account_url
    #     def show
    #       # find and return the account
    #     end
    #
    #     # GET edit_account_url
    #     def edit
    #       # return an HTML form for editing the account
    #     end
    #
    #     # PUT account_url
    #     def update
    #       # find and update the account
    #     end
    #
    #     # DELETE account_url
    #     def destroy
    #       # delete the account
    #     end
    #   end
    #
    # Along with the routes themselves, #resource generates named routes for use in
    # controllers and views. &lt;tt&gt;map.resource :account&lt;/tt&gt; produces the following named routes and helpers:
    # 
    #   Named Route   Helpers
    #   account       account_url, hash_for_account_url, 
    #                 account_path, hash_for_account_path
    #   edit_account  edit_account_url, hash_for_edit_account_url,
    #                 edit_account_path, hash_for_edit_account_path
    def resource(*entities, &amp;block)
      options = entities.last.is_a?(Hash) ? entities.pop : { }
      entities.each { |entity| map_singleton_resource entity, options.dup, &amp;block }
    end

    private
      def map_resource(entities, options = {}, &amp;block)
        resource = Resource.new(entities, options)

        with_options :controller =&gt; resource.controller do |map|
          map_collection_actions(map, resource)
          map_default_collection_actions(map, resource)
          map_new_actions(map, resource)
          map_member_actions(map, resource)

          if block_given?
            with_options(:path_prefix =&gt; resource.nesting_path_prefix, :new_name_prefix =&gt; resource.nesting_name_prefix, &amp;block)
          end
        end
      end

      def map_singleton_resource(entities, options = {}, &amp;block)
        resource = SingletonResource.new(entities, options)

        with_options :controller =&gt; resource.controller do |map|
          map_collection_actions(map, resource)
          map_default_singleton_actions(map, resource)
          map_new_actions(map, resource)
          map_member_actions(map, resource)

          if block_given?
            with_options(:path_prefix =&gt; resource.nesting_path_prefix, :new_name_prefix =&gt; resource.nesting_name_prefix, &amp;block)
          end
        end
      end

      def map_collection_actions(map, resource)
        resource.collection_methods.each do |method, actions|
          actions.each do |action|
            action_options = action_options_for(action, resource, method)

            unless resource.old_name_prefix.blank?
              map.deprecated_named_route(&quot;#{action}_#{resource.name_prefix}#{resource.plural}&quot;, &quot;#{resource.old_name_prefix}#{action}_#{resource.plural}&quot;)
              map.deprecated_named_route(&quot;formatted_#{action}_#{resource.name_prefix}#{resource.plural}&quot;, &quot;formatted_#{resource.old_name_prefix}#{action}_#{resource.plural}&quot;)
            end

            if resource.deprecate_name_prefix?
              map.deprecated_named_route(&quot;#{action}_#{resource.name_prefix}#{resource.plural}&quot;, &quot;#{action}_#{resource.plural}&quot;)
              map.deprecated_named_route(&quot;formatted_#{action}_#{resource.name_prefix}#{resource.plural}&quot;, &quot;formatted_#{action}_#{resource.plural}&quot;)
            end

            map.named_route(&quot;#{action}_#{resource.name_prefix}#{resource.plural}&quot;, &quot;#{resource.path}#{resource.action_separator}#{action}&quot;, action_options)
            map.connect(&quot;#{resource.path};#{action}&quot;, action_options)
            map.connect(&quot;#{resource.path}.:format;#{action}&quot;, action_options)
            map.named_route(&quot;formatted_#{action}_#{resource.name_prefix}#{resource.plural}&quot;, &quot;#{resource.path}#{resource.action_separator}#{action}.:format&quot;, action_options)
          end
        end
      end

      def map_default_collection_actions(map, resource)
        index_action_options = action_options_for(&quot;index&quot;, resource)
        map.named_route(&quot;#{resource.name_prefix}#{resource.plural}&quot;, resource.path, index_action_options)
        map.named_route(&quot;formatted_#{resource.name_prefix}#{resource.plural}&quot;, &quot;#{resource.path}.:format&quot;, index_action_options)

        if resource.deprecate_name_prefix?
          map.deprecated_named_route(&quot;#{resource.name_prefix}#{resource.plural}&quot;, &quot;#{resource.plural}&quot;)
          map.deprecated_named_route(&quot;formatted_#{resource.name_prefix}#{resource.plural}&quot;, &quot;formatted_#{resource.plural}&quot;)
        end

        create_action_options = action_options_for(&quot;create&quot;, resource)
        map.connect(resource.path, create_action_options)
        map.connect(&quot;#{resource.path}.:format&quot;, create_action_options)
      end

      def map_default_singleton_actions(map, resource)
        create_action_options = action_options_for(&quot;create&quot;, resource)
        map.connect(resource.path, create_action_options)
        map.connect(&quot;#{resource.path}.:format&quot;, create_action_options)
      end

      def map_new_actions(map, resource)
        resource.new_methods.each do |method, actions|
          actions.each do |action|
            action_options = action_options_for(action, resource, method)
            if action == :new

              unless resource.old_name_prefix.blank?
                map.deprecated_named_route(&quot;new_#{resource.name_prefix}#{resource.singular}&quot;, &quot;#{resource.old_name_prefix}new_#{resource.singular}&quot;)
                map.deprecated_named_route(&quot;formatted_new_#{resource.name_prefix}#{resource.singular}&quot;, &quot;formatted_#{resource.old_name_prefix}new_#{resource.singular}&quot;)
              end

              if resource.deprecate_name_prefix?
                map.deprecated_named_route(&quot;new_#{resource.name_prefix}#{resource.singular}&quot;, &quot;new_#{resource.singular}&quot;)
                map.deprecated_named_route(&quot;formatted_new_#{resource.name_prefix}#{resource.singular}&quot;, &quot;formatted_new_#{resource.singular}&quot;)
              end

              map.named_route(&quot;new_#{resource.name_prefix}#{resource.singular}&quot;, resource.new_path, action_options)
              map.named_route(&quot;formatted_new_#{resource.name_prefix}#{resource.singular}&quot;, &quot;#{resource.new_path}.:format&quot;, action_options)

            else

              unless resource.old_name_prefix.blank?
                map.deprecated_named_route(&quot;#{action}_new_#{resource.name_prefix}#{resource.singular}&quot;, &quot;#{resource.old_name_prefix}#{action}_new_#{resource.singular}&quot;)
                map.deprecated_named_route(&quot;formatted_#{action}_new_#{resource.name_prefix}#{resource.singular}&quot;, &quot;formatted_#{resource.old_name_prefix}#{action}_new_#{resource.singular}&quot;)
              end

              if resource.deprecate_name_prefix?
                map.deprecated_named_route(&quot;#{action}_new_#{resource.name_prefix}#{resource.singular}&quot;, &quot;#{action}_new_#{resource.singular}&quot;)
                map.deprecated_named_route(&quot;formatted_#{action}_new_#{resource.name_prefix}#{resource.singular}&quot;, &quot;formatted_#{action}_new_#{resource.singular}&quot;)
              end

              map.named_route(&quot;#{action}_new_#{resource.name_prefix}#{resource.singular}&quot;, &quot;#{resource.new_path}#{resource.action_separator}#{action}&quot;, action_options)
              map.connect(&quot;#{resource.new_path};#{action}&quot;, action_options)
              map.connect(&quot;#{resource.new_path}.:format;#{action}&quot;, action_options)
              map.named_route(&quot;formatted_#{action}_new_#{resource.name_prefix}#{resource.singular}&quot;, &quot;#{resource.new_path}#{resource.action_separator}#{action}.:format&quot;, action_options)

            end
          end
        end
      end

      def map_member_actions(map, resource)
        resource.member_methods.each do |method, actions|
          actions.each do |action|
            action_options = action_options_for(action, resource, method)

            unless resource.old_name_prefix.blank?
              map.deprecated_named_route(&quot;#{action}_#{resource.name_prefix}#{resource.singular}&quot;, &quot;#{resource.old_name_prefix}#{action}_#{resource.singular}&quot;)
              map.deprecated_named_route(&quot;formatted_#{action}_#{resource.name_prefix}#{resource.singular}&quot;, &quot;formatted_#{resource.old_name_prefix}#{action}_#{resource.singular}&quot;)
            end

            if resource.deprecate_name_prefix?
              map.deprecated_named_route(&quot;#{action}_#{resource.name_prefix}#{resource.singular}&quot;, &quot;#{action}_#{resource.singular}&quot;)
              map.deprecated_named_route(&quot;formatted_#{action}_#{resource.name_prefix}#{resource.singular}&quot;, &quot;formatted_#{action}_#{resource.singular}&quot;)
            end

            map.named_route(&quot;#{action}_#{resource.name_prefix}#{resource.singular}&quot;, &quot;#{resource.member_path}#{resource.action_separator}#{action}&quot;, action_options)
            map.connect(&quot;#{resource.member_path};#{action}&quot;, action_options)
            map.connect(&quot;#{resource.member_path}.:format;#{action}&quot;, action_options)
            map.named_route(&quot;formatted_#{action}_#{resource.name_prefix}#{resource.singular}&quot;, &quot;#{resource.member_path}#{resource.action_separator}#{action}.:format&quot;, action_options)

          end
        end

        show_action_options = action_options_for(&quot;show&quot;, resource)
        map.named_route(&quot;#{resource.name_prefix}#{resource.singular}&quot;, resource.member_path, show_action_options)
        map.named_route(&quot;formatted_#{resource.name_prefix}#{resource.singular}&quot;, &quot;#{resource.member_path}.:format&quot;, show_action_options)

        if resource.deprecate_name_prefix?
          map.deprecated_named_route(&quot;#{resource.name_prefix}#{resource.singular}&quot;, &quot;#{resource.singular}&quot;)
          map.deprecated_named_route(&quot;formatted_#{resource.name_prefix}#{resource.singular}&quot;, &quot;formatted_#{resource.singular}&quot;)
        end

        update_action_options = action_options_for(&quot;update&quot;, resource)
        map.connect(resource.member_path, update_action_options)
        map.connect(&quot;#{resource.member_path}.:format&quot;, update_action_options)

        destroy_action_options = action_options_for(&quot;destroy&quot;, resource)
        map.connect(resource.member_path, destroy_action_options)
        map.connect(&quot;#{resource.member_path}.:format&quot;, destroy_action_options)
      end

      def conditions_for(method)
        { :conditions =&gt; method == :any ? {} : { :method =&gt; method } }
      end

      def action_options_for(action, resource, method = nil)
        default_options = { :action =&gt; action.to_s }
        require_id = resource.kind_of?(SingletonResource) ? {} : { :requirements =&gt; { :id =&gt; Regexp.new(&quot;[^#{Routing::SEPARATORS.join}]+&quot;) } }
        case default_options[:action]
          when &quot;index&quot;, &quot;new&quot; : default_options.merge(conditions_for(method || :get))
          when &quot;create&quot;       : default_options.merge(conditions_for(method || :post))
          when &quot;show&quot;, &quot;edit&quot; : default_options.merge(conditions_for(method || :get)).merge(require_id)
          when &quot;update&quot;       : default_options.merge(conditions_for(method || :put)).merge(require_id)
          when &quot;destroy&quot;      : default_options.merge(conditions_for(method || :delete)).merge(require_id)
          else                  default_options.merge(conditions_for(method))
        end
      end
  end
end

ActionController::Routing::RouteSet::Mapper.send :include, ActionController::Resources
</pre>
    </div>