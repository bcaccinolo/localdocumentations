  <div id="fileHeader">
    <h1>xmlrpc_client.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>actionwebservice/lib/action_web_service/client/xmlrpc_client.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat Apr 02 13:03:36 -0800 2005</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'uri'
require 'xmlrpc/client'

module ActionWebService # :nodoc:
  module Client # :nodoc:

    # Implements XML-RPC client support
    #
    # ==== Example Usage
    #
    #   class BloggerAPI &lt; ActionWebService::API::Base
    #     inflect_names false
    #     api_method :getRecentPosts, :returns =&gt; [[Blog::Post]]
    #   end
    #
    #   blog = ActionWebService::Client::XmlRpc.new(BloggerAPI, &quot;http://.../RPC&quot;, :handler_name =&gt; &quot;blogger&quot;)
    #   posts = blog.getRecentPosts
    class XmlRpc &lt; Base

      # Creates a new web service client using the XML-RPC protocol.
      #
      # +api+ must be an ActionWebService::API::Base derivative, and
      # +endpoint_uri+ must point at the relevant URL to which protocol requests
      # will be sent with HTTP POST.
      #
      # Valid options:
      # [&lt;tt&gt;:handler_name&lt;/tt&gt;]    If the remote server defines its services inside special
      #                             handler (the Blogger API uses a &lt;tt&gt;&quot;blogger&quot;&lt;/tt&gt; handler name for example),
      #                             provide it here, or your method calls will fail
      def initialize(api, endpoint_uri, options={})
        @api = api
        @handler_name = options[:handler_name]
        @protocol = ActionWebService::Protocol::XmlRpc::XmlRpcProtocol.new
        @client = XMLRPC::Client.new2(endpoint_uri, options[:proxy], options[:timeout])
      end

      protected
        def perform_invocation(method_name, args)
          method = @api.api_methods[method_name.to_sym]
          if method.expects &amp;&amp; method.expects.length != args.length
            raise(ArgumentError, &quot;#{method.public_name}: wrong number of arguments (#{args.length} for #{method.expects.length})&quot;)
          end
          args = method.cast_expects(args.dup) rescue args
          if method.expects
            method.expects.each_with_index{ |type, i| args[i] = @protocol.value_to_xmlrpc_wire_format(args[i], type) }
          end
          ok, return_value = @client.call2(public_name(method_name), *args)
          return (method.cast_returns(return_value.dup) rescue return_value) if ok
          raise(ClientError, &quot;#{return_value.faultCode}: #{return_value.faultString}&quot;)
        end

        def public_name(method_name)
          public_name = @api.public_api_method_name(method_name)
          @handler_name ? &quot;#{@handler_name}.#{public_name}&quot; : public_name
        end
    end
  end
end
</pre>
    </div>