  <div id="fileHeader">
    <h1>action_controller_dispatcher.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>actionwebservice/lib/action_web_service/dispatcher/action_controller_dispatcher.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Sep 24 22:20:13 -0700 2006</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'benchmark'
require 'builder/xmlmarkup'

module ActionWebService # :nodoc:
  module Dispatcher # :nodoc:
    module ActionController # :nodoc:
      def self.included(base) # :nodoc:
        class &lt;&lt; base
          include ClassMethods
          alias_method_chain :inherited, :action_controller
        end
        base.class_eval do
          alias_method :web_service_direct_invoke_without_controller, :web_service_direct_invoke
        end
        base.add_web_service_api_callback do |klass, api|
          if klass.web_service_dispatching_mode == :direct
            klass.class_eval 'def api; dispatch_web_service_request; end'
          end
        end
        base.add_web_service_definition_callback do |klass, name, info|
          if klass.web_service_dispatching_mode == :delegated
            klass.class_eval &quot;def #{name}; dispatch_web_service_request; end&quot;
          elsif klass.web_service_dispatching_mode == :layered
            klass.class_eval 'def api; dispatch_web_service_request; end'
          end
        end
        base.send(:include, ActionWebService::Dispatcher::ActionController::InstanceMethods)
      end

      module ClassMethods # :nodoc:
        def inherited_with_action_controller(child)
          inherited_without_action_controller(child)
          child.send(:include, ActionWebService::Dispatcher::ActionController::WsdlAction)
        end
      end

      module InstanceMethods # :nodoc:
        private
          def dispatch_web_service_request
            if request.get?
              render_text('GET not supported', '500 GET not supported')
              return
            end
            exception = nil
            begin
              ws_request = discover_web_service_request(request)
            rescue Exception =&gt; e
              exception = e
            end
            if ws_request
              ws_response = nil
              exception = nil
              bm = Benchmark.measure do
                begin
                  ws_response = invoke_web_service_request(ws_request)
                rescue Exception =&gt; e
                  exception = e
                end
              end
              log_request(ws_request, request.raw_post)
              if exception
                log_error(exception) unless logger.nil?
                send_web_service_error_response(ws_request, exception)
              else
                send_web_service_response(ws_response, bm.real)
              end
            else
              exception ||= DispatcherError.new(&quot;Malformed SOAP or XML-RPC protocol message&quot;)
              log_error(exception) unless logger.nil?
              send_web_service_error_response(ws_request, exception)
            end
          rescue Exception =&gt; e
            log_error(e) unless logger.nil?
            send_web_service_error_response(ws_request, e)
          end

          def send_web_service_response(ws_response, elapsed=nil)
            log_response(ws_response, elapsed)
            options = { :type =&gt; ws_response.content_type, :disposition =&gt; 'inline' }
            send_data(ws_response.body, options)
          end

          def send_web_service_error_response(ws_request, exception)
            if ws_request
              unless self.class.web_service_exception_reporting
                exception = DispatcherError.new(&quot;Internal server error (exception raised)&quot;)
              end
              api_method = ws_request.api_method
              public_method_name = api_method ? api_method.public_name : ws_request.method_name
              return_type = ActionWebService::SignatureTypes.canonical_signature_entry(Exception, 0)
              ws_response = ws_request.protocol.encode_response(public_method_name + 'Response', exception, return_type, ws_request.protocol_options)
              send_web_service_response(ws_response)
            else
              if self.class.web_service_exception_reporting
                message = exception.message
                backtrace = &quot;\nBacktrace:\n#{exception.backtrace.join(&quot;\n&quot;)}&quot;
              else
                message = &quot;Exception raised&quot;
                backtrace = &quot;&quot;
              end
              render_text(&quot;Internal protocol error: #{message}#{backtrace}&quot;, &quot;500 Internal Protocol Error&quot;)
            end
          end

          def web_service_direct_invoke(invocation)
            invocation.method_named_params.each do |name, value|
              params[name] = value
            end
            web_service_direct_invoke_without_controller(invocation)
          end

          def log_request(ws_request, body)
            unless logger.nil?
              name = ws_request.method_name
              api_method = ws_request.api_method
              params = ws_request.method_params
              if api_method &amp;&amp; api_method.expects
                params = api_method.expects.zip(params).map{ |type, param| &quot;#{type.name}=&gt;#{param.inspect}&quot; }
              else
                params = params.map{ |param| param.inspect }
              end
              service = ws_request.service_name
              logger.debug(&quot;\nWeb Service Request: #{name}(#{params.join(&quot;, &quot;)}) Entrypoint: #{service}&quot;)
              logger.debug(indent(body))
            end
          end

          def log_response(ws_response, elapsed=nil)
            unless logger.nil?
              elapsed = (elapsed ? &quot; (%f):&quot; % elapsed : &quot;:&quot;)
              logger.debug(&quot;\nWeb Service Response&quot; + elapsed + &quot; =&gt; #{ws_response.return_value.inspect}&quot;)
              logger.debug(indent(ws_response.body))
            end
          end

          def indent(body)
            body.split(/\n/).map{|x| &quot;  #{x}&quot;}.join(&quot;\n&quot;)
          end
      end

      module WsdlAction # :nodoc:
        XsdNs             = 'http://www.w3.org/2001/XMLSchema'
        WsdlNs            = 'http://schemas.xmlsoap.org/wsdl/'
        SoapNs            = 'http://schemas.xmlsoap.org/wsdl/soap/'
        SoapEncodingNs    = 'http://schemas.xmlsoap.org/soap/encoding/'
        SoapHttpTransport = 'http://schemas.xmlsoap.org/soap/http'

        def wsdl
          case request.method
          when :get
            begin
              options = { :type =&gt; 'text/xml', :disposition =&gt; 'inline' }
              send_data(to_wsdl, options)
            rescue Exception =&gt; e
              log_error(e) unless logger.nil?
            end
          when :post
            render_text('POST not supported', '500 POST not supported')
          end
        end

        private
          def base_uri
            host = request.host_with_port
            relative_url_root = request.relative_url_root
            scheme = request.ssl? ? 'https' : 'http'
            '%s://%s%s/%s/' % [scheme, host, relative_url_root, self.class.controller_path]
          end

          def to_wsdl
            xml = ''
            dispatching_mode = web_service_dispatching_mode
            global_service_name = wsdl_service_name
            namespace = wsdl_namespace || 'urn:ActionWebService'
            soap_action_base = &quot;/#{controller_name}&quot;

            marshaler = ActionWebService::Protocol::Soap::SoapMarshaler.new(namespace)
            apis = {}
            case dispatching_mode
            when :direct
              api = self.class.web_service_api
              web_service_name = controller_class_name.sub(/Controller$/, '').underscore
              apis[web_service_name] = [api, register_api(api, marshaler)]
            when :delegated, :layered
              self.class.web_services.each do |web_service_name, info|
                service = web_service_object(web_service_name)
                api = service.class.web_service_api
                apis[web_service_name] = [api, register_api(api, marshaler)]
              end
            end
            custom_types = []
            apis.values.each do |api, bindings|
              bindings.each do |b|
                custom_types &lt;&lt; b unless custom_types.include?(b)
              end
            end

            xm = Builder::XmlMarkup.new(:target =&gt; xml, :indent =&gt; 2)
            xm.instruct!
            xm.definitions('name'            =&gt; wsdl_service_name,
                           'targetNamespace' =&gt; namespace,
                           'xmlns:typens'    =&gt; namespace,
                           'xmlns:xsd'       =&gt; XsdNs,
                           'xmlns:soap'      =&gt; SoapNs,
                           'xmlns:soapenc'   =&gt; SoapEncodingNs,
                           'xmlns:wsdl'      =&gt; WsdlNs,
                           'xmlns'           =&gt; WsdlNs) do
              # Generate XSD
              if custom_types.size &gt; 0
                xm.types do
                  xm.xsd(:schema, 'xmlns' =&gt; XsdNs, 'targetNamespace' =&gt; namespace) do
                    custom_types.each do |binding|
                      case
                      when binding.type.array?
                        xm.xsd(:complexType, 'name' =&gt; binding.type_name) do
                          xm.xsd(:complexContent) do
                            xm.xsd(:restriction, 'base' =&gt; 'soapenc:Array') do
                              xm.xsd(:attribute, 'ref' =&gt; 'soapenc:arrayType',
                                                 'wsdl:arrayType' =&gt; binding.element_binding.qualified_type_name('typens') + '[]')
                            end
                          end
                        end
                      when binding.type.structured?
                        xm.xsd(:complexType, 'name' =&gt; binding.type_name) do
                          xm.xsd(:all) do
                            binding.type.each_member do |name, type|
                              b = marshaler.register_type(type)
                              xm.xsd(:element, 'name' =&gt; name, 'type' =&gt; b.qualified_type_name('typens'))
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end

              # APIs
              apis.each do |api_name, values|
                api = values[0]
                api.api_methods.each do |name, method|
                  gen = lambda do |msg_name, direction|
                    xm.message('name' =&gt; message_name_for(api_name, msg_name)) do
                      sym = nil
                      if direction == :out
                        returns = method.returns
                        if returns
                          binding = marshaler.register_type(returns[0])
                          xm.part('name' =&gt; 'return', 'type' =&gt; binding.qualified_type_name('typens'))
                        end
                      else
                        expects = method.expects
                        expects.each do |type|
                          binding = marshaler.register_type(type)
                          xm.part('name' =&gt; type.name, 'type' =&gt; binding.qualified_type_name('typens'))
                        end if expects
                      end
                    end
                  end
                  public_name = method.public_name
                  gen.call(public_name, :in)
                  gen.call(&quot;#{public_name}Response&quot;, :out)
                end

                # Port
                port_name = port_name_for(global_service_name, api_name)
                xm.portType('name' =&gt; port_name) do
                  api.api_methods.each do |name, method|
                    xm.operation('name' =&gt; method.public_name) do
                      xm.input('message' =&gt; &quot;typens:&quot; + message_name_for(api_name, method.public_name))
                      xm.output('message' =&gt; &quot;typens:&quot; + message_name_for(api_name, &quot;#{method.public_name}Response&quot;))
                    end
                  end
                end

                # Bind it
                binding_name = binding_name_for(global_service_name, api_name)
                xm.binding('name' =&gt; binding_name, 'type' =&gt; &quot;typens:#{port_name}&quot;) do
                  xm.soap(:binding, 'style' =&gt; 'rpc', 'transport' =&gt; SoapHttpTransport)
                  api.api_methods.each do |name, method|
                    xm.operation('name' =&gt; method.public_name) do
                      case web_service_dispatching_mode
                      when :direct
                        soap_action = soap_action_base + &quot;/api/&quot; + method.public_name
                      when :delegated, :layered
                        soap_action = soap_action_base \
                                    + &quot;/&quot; + api_name.to_s \
                                    + &quot;/&quot; + method.public_name
                      end
                      xm.soap(:operation, 'soapAction' =&gt; soap_action)
                      xm.input do
                        xm.soap(:body,
                                'use'           =&gt; 'encoded',
                                'namespace'     =&gt; namespace,
                                'encodingStyle' =&gt; SoapEncodingNs)
                      end
                      xm.output do
                        xm.soap(:body,
                                'use'           =&gt; 'encoded',
                                'namespace'     =&gt; namespace,
                                'encodingStyle' =&gt; SoapEncodingNs)
                      end
                    end
                  end
                end
              end

              # Define it
              xm.service('name' =&gt; &quot;#{global_service_name}Service&quot;) do
                apis.each do |api_name, values|
                  port_name = port_name_for(global_service_name, api_name)
                  binding_name = binding_name_for(global_service_name,  api_name)
                  case web_service_dispatching_mode
                  when :direct, :layered
                    binding_target = 'api'
                  when :delegated
                    binding_target = api_name.to_s
                  end
                  xm.port('name' =&gt; port_name, 'binding' =&gt; &quot;typens:#{binding_name}&quot;) do
                    xm.soap(:address, 'location' =&gt; &quot;#{base_uri}#{binding_target}&quot;)
                  end
                end
              end
            end
          end

          def port_name_for(global_service, service)
            &quot;#{global_service}#{service.to_s.camelize}Port&quot;
          end

          def binding_name_for(global_service, service)
            &quot;#{global_service}#{service.to_s.camelize}Binding&quot;
          end

          def message_name_for(api_name, message_name)
            mode = web_service_dispatching_mode
            if mode == :layered || mode == :delegated
              api_name.to_s + '-' + message_name
            else
              message_name
            end
          end

          def register_api(api, marshaler)
            bindings = {}
            traverse_custom_types(api, marshaler, bindings) do |binding|
              bindings[binding] = nil unless bindings.has_key?(binding)
              element_binding = binding.element_binding
              bindings[element_binding] = nil if element_binding &amp;&amp; !bindings.has_key?(element_binding)
            end
            bindings.keys
          end

          def traverse_custom_types(api, marshaler, bindings, &amp;block)
            api.api_methods.each do |name, method|
              expects, returns = method.expects, method.returns
              expects.each{ |type| traverse_type(marshaler, type, bindings, &amp;block) if type.custom? } if expects
              returns.each{ |type| traverse_type(marshaler, type, bindings, &amp;block) if type.custom? } if returns
            end
          end

          def traverse_type(marshaler, type, bindings, &amp;block)
            binding = marshaler.register_type(type)
            return if bindings.has_key?(binding)
            bindings[binding] = nil
            yield binding
            if type.array?
              yield marshaler.register_type(type.element_type)
              type = type.element_type
            end
            type.each_member{ |name, type| traverse_type(marshaler, type, bindings, &amp;block) } if type.structured?
          end
       end
    end
  end
end
</pre>
    </div>