  <div id="fileHeader">
    <h1>setup.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>actionwebservice/setup.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Wed Nov 16 16:48:16 -0800 2005</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#
# setup.rb
#
# Copyright (c) 2000-2004 Minero Aoki
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# &quot;Software&quot;), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Note: Originally licensed under LGPL v2+. Using MIT license for Rails
# with permission of Minero Aoki.

#

unless Enumerable.method_defined?(:map)   # Ruby 1.4.6
  module Enumerable
    alias map collect
  end
end

unless File.respond_to?(:read)   # Ruby 1.6
  def File.read(fname)
    open(fname) {|f|
      return f.read
    }
  end
end

def File.binread(fname)
  open(fname, 'rb') {|f|
    return f.read
  }
end

# for corrupted windows stat(2)
def File.dir?(path)
  File.directory?((path[-1,1] == '/') ? path : path + '/')
end


class SetupError &lt; StandardError; end

def setup_rb_error(msg)
  raise SetupError, msg
end

#
# Config
#

if arg = ARGV.detect {|arg| /\A--rbconfig=/ =~ arg }
  ARGV.delete(arg)
  require arg.split(/=/, 2)[1]
  $&quot;.push 'rbconfig.rb'
else
  require 'rbconfig'
end

def multipackage_install?
  FileTest.directory?(File.dirname($0) + '/packages')
end


class ConfigItem
  def initialize(name, template, default, desc)
    @name = name.freeze
    @template = template
    @value = default
    @default = default.dup.freeze
    @description = desc
  end

  attr_reader :name
  attr_reader :description

  attr_accessor :default
  alias help_default default

  def help_opt
    &quot;--#{@name}=#{@template}&quot;
  end

  def value
    @value
  end

  def eval(table)
    @value.gsub(%r&lt;\$([^/]+)&gt;) { table[$1] }
  end

  def set(val)
    @value = check(val)
  end

  private

  def check(val)
    setup_rb_error &quot;config: --#{name} requires argument&quot; unless val
    val
  end
end

class BoolItem &lt; ConfigItem
  def config_type
    'bool'
  end

  def help_opt
    &quot;--#{@name}&quot;
  end

  private

  def check(val)
    return 'yes' unless val
    unless /\A(y(es)?|n(o)?|t(rue)?|f(alse))\z/i =~ val
      setup_rb_error &quot;config: --#{@name} accepts only yes/no for argument&quot;
    end
    (/\Ay(es)?|\At(rue)/i =~ value) ? 'yes' : 'no'
  end
end

class PathItem &lt; ConfigItem
  def config_type
    'path'
  end

  private

  def check(path)
    setup_rb_error &quot;config: --#{@name} requires argument&quot;  unless path
    path[0,1] == '$' ? path : File.expand_path(path)
  end
end

class ProgramItem &lt; ConfigItem
  def config_type
    'program'
  end
end

class SelectItem &lt; ConfigItem
  def initialize(name, template, default, desc)
    super
    @ok = template.split('/')
  end

  def config_type
    'select'
  end

  private

  def check(val)
    unless @ok.include?(val.strip)
      setup_rb_error &quot;config: use --#{@name}=#{@template} (#{val})&quot;
    end
    val.strip
  end
end

class PackageSelectionItem &lt; ConfigItem
  def initialize(name, template, default, help_default, desc)
    super name, template, default, desc
    @help_default = help_default
  end

  attr_reader :help_default

  def config_type
    'package'
  end

  private

  def check(val)
    unless File.dir?(&quot;packages/#{val}&quot;)
      setup_rb_error &quot;config: no such package: #{val}&quot;
    end
    val
  end
end

class ConfigTable_class

  def initialize(items)
    @items = items
    @table = {}
    items.each do |i|
      @table[i.name] = i
    end
    ALIASES.each do |ali, name|
      @table[ali] = @table[name]
    end
  end

  include Enumerable

  def each(&amp;block)
    @items.each(&amp;block)
  end

  def key?(name)
    @table.key?(name)
  end

  def lookup(name)
    @table[name] or raise ArgumentError, &quot;no such config item: #{name}&quot;
  end

  def add(item)
    @items.push item
    @table[item.name] = item
  end

  def remove(name)
    item = lookup(name)
    @items.delete_if {|i| i.name == name }
    @table.delete_if {|name, i| i.name == name }
    item
  end

  def new
    dup()
  end

  def savefile
    '.config'
  end

  def load
    begin
      t = dup()
      File.foreach(savefile()) do |line|
        k, v = *line.split(/=/, 2)
        t[k] = v.strip
      end
      t
    rescue Errno::ENOENT
      setup_rb_error $!.message + &quot;#{File.basename($0)} config first&quot;
    end
  end

  def save
    @items.each {|i| i.value }
    File.open(savefile(), 'w') {|f|
      @items.each do |i|
        f.printf &quot;%s=%s\n&quot;, i.name, i.value if i.value
      end
    }
  end

  def [](key)
    lookup(key).eval(self)
  end

  def []=(key, val)
    lookup(key).set val
  end

end

c = ::Config::CONFIG

rubypath = c['bindir'] + '/' + c['ruby_install_name']

major = c['MAJOR'].to_i
minor = c['MINOR'].to_i
teeny = c['TEENY'].to_i
version = &quot;#{major}.#{minor}&quot;

# ruby ver. &gt;= 1.4.4?
newpath_p = ((major &gt;= 2) or
             ((major == 1) and
              ((minor &gt;= 5) or
               ((minor == 4) and (teeny &gt;= 4)))))

if c['rubylibdir']
  # V &lt; 1.6.3
  _stdruby         = c['rubylibdir']
  _siteruby        = c['sitedir']
  _siterubyver     = c['sitelibdir']
  _siterubyverarch = c['sitearchdir']
elsif newpath_p
  # 1.4.4 &lt;= V &lt;= 1.6.3
  _stdruby         = &quot;$prefix/lib/ruby/#{version}&quot;
  _siteruby        = c['sitedir']
  _siterubyver     = &quot;$siteruby/#{version}&quot;
  _siterubyverarch = &quot;$siterubyver/#{c['arch']}&quot;
else
  # V &lt; 1.4.4
  _stdruby         = &quot;$prefix/lib/ruby/#{version}&quot;
  _siteruby        = &quot;$prefix/lib/ruby/#{version}/site_ruby&quot;
  _siterubyver     = _siteruby
  _siterubyverarch = &quot;$siterubyver/#{c['arch']}&quot;
end
libdir = '-* dummy libdir *-'
stdruby = '-* dummy rubylibdir *-'
siteruby = '-* dummy site_ruby *-'
siterubyver = '-* dummy site_ruby version *-'
parameterize = lambda {|path|
  path.sub(/\A#{Regexp.quote(c['prefix'])}/, '$prefix')\
      .sub(/\A#{Regexp.quote(libdir)}/,      '$libdir')\
      .sub(/\A#{Regexp.quote(stdruby)}/,     '$stdruby')\
      .sub(/\A#{Regexp.quote(siteruby)}/,    '$siteruby')\
      .sub(/\A#{Regexp.quote(siterubyver)}/, '$siterubyver')
}
libdir          = parameterize.call(c['libdir'])
stdruby         = parameterize.call(_stdruby)
siteruby        = parameterize.call(_siteruby)
siterubyver     = parameterize.call(_siterubyver)
siterubyverarch = parameterize.call(_siterubyverarch)

if arg = c['configure_args'].split.detect {|arg| /--with-make-prog=/ =~ arg }
  makeprog = arg.sub(/'/, '').split(/=/, 2)[1]
else
  makeprog = 'make'
end

common_conf = [
  PathItem.new('prefix', 'path', c['prefix'],
               'path prefix of target environment'),
  PathItem.new('bindir', 'path', parameterize.call(c['bindir']),
               'the directory for commands'),
  PathItem.new('libdir', 'path', libdir,
               'the directory for libraries'),
  PathItem.new('datadir', 'path', parameterize.call(c['datadir']),
               'the directory for shared data'),
  PathItem.new('mandir', 'path', parameterize.call(c['mandir']),
               'the directory for man pages'),
  PathItem.new('sysconfdir', 'path', parameterize.call(c['sysconfdir']),
               'the directory for man pages'),
  PathItem.new('stdruby', 'path', stdruby,
               'the directory for standard ruby libraries'),
  PathItem.new('siteruby', 'path', siteruby,
      'the directory for version-independent aux ruby libraries'),
  PathItem.new('siterubyver', 'path', siterubyver,
               'the directory for aux ruby libraries'),
  PathItem.new('siterubyverarch', 'path', siterubyverarch,
               'the directory for aux ruby binaries'),
  PathItem.new('rbdir', 'path', '$siterubyver',
               'the directory for ruby scripts'),
  PathItem.new('sodir', 'path', '$siterubyverarch',
               'the directory for ruby extentions'),
  PathItem.new('rubypath', 'path', rubypath,
               'the path to set to #! line'),
  ProgramItem.new('rubyprog', 'name', rubypath,
                  'the ruby program using for installation'),
  ProgramItem.new('makeprog', 'name', makeprog,
                  'the make program to compile ruby extentions'),
  SelectItem.new('shebang', 'all/ruby/never', 'ruby',
                 'shebang line (#!) editing mode'),
  BoolItem.new('without-ext', 'yes/no', 'no',
               'does not compile/install ruby extentions')
]
class ConfigTable_class   # open again
  ALIASES = {
    'std-ruby'         =&gt; 'stdruby',
    'site-ruby-common' =&gt; 'siteruby',     # For backward compatibility
    'site-ruby'        =&gt; 'siterubyver',  # For backward compatibility
    'bin-dir'          =&gt; 'bindir',
    'bin-dir'          =&gt; 'bindir',
    'rb-dir'           =&gt; 'rbdir',
    'so-dir'           =&gt; 'sodir',
    'data-dir'         =&gt; 'datadir',
    'ruby-path'        =&gt; 'rubypath',
    'ruby-prog'        =&gt; 'rubyprog',
    'ruby'             =&gt; 'rubyprog',
    'make-prog'        =&gt; 'makeprog',
    'make'             =&gt; 'makeprog'
  }
end
multipackage_conf = [
  PackageSelectionItem.new('with', 'name,name...', '', 'ALL',
                           'package names that you want to install'),
  PackageSelectionItem.new('without', 'name,name...', '', 'NONE',
                           'package names that you do not want to install')
]
if multipackage_install?
  ConfigTable = ConfigTable_class.new(common_conf + multipackage_conf)
else
  ConfigTable = ConfigTable_class.new(common_conf)
end


module MetaConfigAPI

  def eval_file_ifexist(fname)
    instance_eval File.read(fname), fname, 1 if File.file?(fname)
  end

  def config_names
    ConfigTable.map {|i| i.name }
  end

  def config?(name)
    ConfigTable.key?(name)
  end

  def bool_config?(name)
    ConfigTable.lookup(name).config_type == 'bool'
  end

  def path_config?(name)
    ConfigTable.lookup(name).config_type == 'path'
  end

  def value_config?(name)
    case ConfigTable.lookup(name).config_type
    when 'bool', 'path'
      true
    else
      false
    end
  end

  def add_config(item)
    ConfigTable.add item
  end

  def add_bool_config(name, default, desc)
    ConfigTable.add BoolItem.new(name, 'yes/no', default ? 'yes' : 'no', desc)
  end

  def add_path_config(name, default, desc)
    ConfigTable.add PathItem.new(name, 'path', default, desc)
  end

  def set_config_default(name, default)
    ConfigTable.lookup(name).default = default
  end

  def remove_config(name)
    ConfigTable.remove(name)
  end

end


#
# File Operations
#

module FileOperations

  def mkdir_p(dirname, prefix = nil)
    dirname = prefix + File.expand_path(dirname) if prefix
    $stderr.puts &quot;mkdir -p #{dirname}&quot; if verbose?
    return if no_harm?

    # does not check '/'... it's too abnormal case
    dirs = File.expand_path(dirname).split(%r&lt;(?=/)&gt;)
    if /\A[a-z]:\z/i =~ dirs[0]
      disk = dirs.shift
      dirs[0] = disk + dirs[0]
    end
    dirs.each_index do |idx|
      path = dirs[0..idx].join('')
      Dir.mkdir path unless File.dir?(path)
    end
  end

  def rm_f(fname)
    $stderr.puts &quot;rm -f #{fname}&quot; if verbose?
    return if no_harm?

    if File.exist?(fname) or File.symlink?(fname)
      File.chmod 0777, fname
      File.unlink fname
    end
  end

  def rm_rf(dn)
    $stderr.puts &quot;rm -rf #{dn}&quot; if verbose?
    return if no_harm?

    Dir.chdir dn
    Dir.foreach('.') do |fn|
      next if fn == '.'
      next if fn == '..'
      if File.dir?(fn)
        verbose_off {
          rm_rf fn
        }
      else
        verbose_off {
          rm_f fn
        }
      end
    end
    Dir.chdir '..'
    Dir.rmdir dn
  end

  def move_file(src, dest)
    File.unlink dest if File.exist?(dest)
    begin
      File.rename src, dest
    rescue
      File.open(dest, 'wb') {|f| f.write File.binread(src) }
      File.chmod File.stat(src).mode, dest
      File.unlink src
    end
  end

  def install(from, dest, mode, prefix = nil)
    $stderr.puts &quot;install #{from} #{dest}&quot; if verbose?
    return if no_harm?

    realdest = prefix ? prefix + File.expand_path(dest) : dest
    realdest = File.join(realdest, File.basename(from)) if File.dir?(realdest)
    str = File.binread(from)
    if diff?(str, realdest)
      verbose_off {
        rm_f realdest if File.exist?(realdest)
      }
      File.open(realdest, 'wb') {|f|
        f.write str
      }
      File.chmod mode, realdest

      File.open(&quot;#{objdir_root()}/InstalledFiles&quot;, 'a') {|f|
        if prefix
          f.puts realdest.sub(prefix, '')
        else
          f.puts realdest
        end
      }
    end
  end

  def diff?(new_content, path)
    return true unless File.exist?(path)
    new_content != File.binread(path)
  end

  def command(str)
    $stderr.puts str if verbose?
    system str or raise RuntimeError, &quot;'system #{str}' failed&quot;
  end

  def ruby(str)
    command config('rubyprog') + ' ' + str
  end
  
  def make(task = '')
    command config('makeprog') + ' ' + task
  end

  def extdir?(dir)
    File.exist?(dir + '/MANIFEST')
  end

  def all_files_in(dirname)
    Dir.open(dirname) {|d|
      return d.select {|ent| File.file?(&quot;#{dirname}/#{ent}&quot;) }
    }
  end

  REJECT_DIRS = %w(
    CVS SCCS RCS CVS.adm .svn
  )

  def all_dirs_in(dirname)
    Dir.open(dirname) {|d|
      return d.select {|n| File.dir?(&quot;#{dirname}/#{n}&quot;) } - %w(. ..) - REJECT_DIRS
    }
  end

end


#
# Main Installer
#

module HookUtils

  def run_hook(name)
    try_run_hook &quot;#{curr_srcdir()}/#{name}&quot; or
    try_run_hook &quot;#{curr_srcdir()}/#{name}.rb&quot;
  end

  def try_run_hook(fname)
    return false unless File.file?(fname)
    begin
      instance_eval File.read(fname), fname, 1
    rescue
      setup_rb_error &quot;hook #{fname} failed:\n&quot; + $!.message
    end
    true
  end

end


module HookScriptAPI

  def get_config(key)
    @config[key]
  end

  alias config get_config

  def set_config(key, val)
    @config[key] = val
  end

  #
  # srcdir/objdir (works only in the package directory)
  #

  #abstract srcdir_root
  #abstract objdir_root
  #abstract relpath

  def curr_srcdir
    &quot;#{srcdir_root()}/#{relpath()}&quot;
  end

  def curr_objdir
    &quot;#{objdir_root()}/#{relpath()}&quot;
  end

  def srcfile(path)
    &quot;#{curr_srcdir()}/#{path}&quot;
  end

  def srcexist?(path)
    File.exist?(srcfile(path))
  end

  def srcdirectory?(path)
    File.dir?(srcfile(path))
  end
  
  def srcfile?(path)
    File.file? srcfile(path)
  end

  def srcentries(path = '.')
    Dir.open(&quot;#{curr_srcdir()}/#{path}&quot;) {|d|
      return d.to_a - %w(. ..)
    }
  end

  def srcfiles(path = '.')
    srcentries(path).select {|fname|
      File.file?(File.join(curr_srcdir(), path, fname))
    }
  end

  def srcdirectories(path = '.')
    srcentries(path).select {|fname|
      File.dir?(File.join(curr_srcdir(), path, fname))
    }
  end

end


class ToplevelInstaller

  Version   = '3.3.1'
  Copyright = 'Copyright (c) 2000-2004 Minero Aoki'

  TASKS = [
    [ 'all',      'do config, setup, then install' ],
    [ 'config',   'saves your configurations' ],
    [ 'show',     'shows current configuration' ],
    [ 'setup',    'compiles ruby extentions and others' ],
    [ 'install',  'installs files' ],
    [ 'clean',    &quot;does `make clean' for each extention&quot; ],
    [ 'distclean',&quot;does `make distclean' for each extention&quot; ]
  ]

  def ToplevelInstaller.invoke
    instance().invoke
  end

  @singleton = nil

  def ToplevelInstaller.instance
    @singleton ||= new(File.dirname($0))
    @singleton
  end

  include MetaConfigAPI

  def initialize(ardir_root)
    @config = nil
    @options = { 'verbose' =&gt; true }
    @ardir = File.expand_path(ardir_root)
  end

  def inspect
    &quot;#&lt;#{self.class} #{__id__()}&gt;&quot;
  end

  def invoke
    run_metaconfigs
    case task = parsearg_global()
    when nil, 'all'
      @config = load_config('config')
      parsearg_config
      init_installers
      exec_config
      exec_setup
      exec_install
    else
      @config = load_config(task)
      __send__ &quot;parsearg_#{task}&quot;
      init_installers
      __send__ &quot;exec_#{task}&quot;
    end
  end
  
  def run_metaconfigs
    eval_file_ifexist &quot;#{@ardir}/metaconfig&quot;
  end

  def load_config(task)
    case task
    when 'config'
      ConfigTable.new
    when 'clean', 'distclean'
      if File.exist?(ConfigTable.savefile)
      then ConfigTable.load
      else ConfigTable.new
      end
    else
      ConfigTable.load
    end
  end

  def init_installers
    @installer = Installer.new(@config, @options, @ardir, File.expand_path('.'))
  end

  #
  # Hook Script API bases
  #

  def srcdir_root
    @ardir
  end

  def objdir_root
    '.'
  end

  def relpath
    '.'
  end

  #
  # Option Parsing
  #

  def parsearg_global
    valid_task = /\A(?:#{TASKS.map {|task,desc| task }.join '|'})\z/

    while arg = ARGV.shift
      case arg
      when /\A\w+\z/
        setup_rb_error &quot;invalid task: #{arg}&quot; unless valid_task =~ arg
        return arg

      when '-q', '--quiet'
        @options['verbose'] = false

      when       '--verbose'
        @options['verbose'] = true

      when '-h', '--help'
        print_usage $stdout
        exit 0

      when '-v', '--version'
        puts &quot;#{File.basename($0)} version #{Version}&quot;
        exit 0
      
      when '--copyright'
        puts Copyright
        exit 0

      else
        setup_rb_error &quot;unknown global option '#{arg}'&quot;
      end
    end

    nil
  end


  def parsearg_no_options
    unless ARGV.empty?
      setup_rb_error &quot;#{task}:  unknown options: #{ARGV.join ' '}&quot;
    end
  end

  alias parsearg_show       parsearg_no_options
  alias parsearg_setup      parsearg_no_options
  alias parsearg_clean      parsearg_no_options
  alias parsearg_distclean  parsearg_no_options

  def parsearg_config
    re = /\A--(#{ConfigTable.map {|i| i.name }.join('|')})(?:=(.*))?\z/
    @options['config-opt'] = []

    while i = ARGV.shift
      if /\A--?\z/ =~ i
        @options['config-opt'] = ARGV.dup
        break
      end
      m = re.match(i)  or setup_rb_error &quot;config: unknown option #{i}&quot;
      name, value = *m.to_a[1,2]
      @config[name] = value
    end
  end

  def parsearg_install
    @options['no-harm'] = false
    @options['install-prefix'] = ''
    while a = ARGV.shift
      case a
      when /\A--no-harm\z/
        @options['no-harm'] = true
      when /\A--prefix=(.*)\z/
        path = $1
        path = File.expand_path(path) unless path[0,1] == '/'
        @options['install-prefix'] = path
      else
        setup_rb_error &quot;install: unknown option #{a}&quot;
      end
    end
  end

  def print_usage(out)
    out.puts 'Typical Installation Procedure:'
    out.puts &quot;  $ ruby #{File.basename $0} config&quot;
    out.puts &quot;  $ ruby #{File.basename $0} setup&quot;
    out.puts &quot;  # ruby #{File.basename $0} install (may require root privilege)&quot;
    out.puts
    out.puts 'Detailed Usage:'
    out.puts &quot;  ruby #{File.basename $0} &lt;global option&gt;&quot;
    out.puts &quot;  ruby #{File.basename $0} [&lt;global options&gt;] &lt;task&gt; [&lt;task options&gt;]&quot;

    fmt = &quot;  %-24s %s\n&quot;
    out.puts
    out.puts 'Global options:'
    out.printf fmt, '-q,--quiet',   'suppress message outputs'
    out.printf fmt, '   --verbose', 'output messages verbosely'
    out.printf fmt, '-h,--help',    'print this message'
    out.printf fmt, '-v,--version', 'print version and quit'
    out.printf fmt, '   --copyright',  'print copyright and quit'
    out.puts
    out.puts 'Tasks:'
    TASKS.each do |name, desc|
      out.printf fmt, name, desc
    end

    fmt = &quot;  %-24s %s [%s]\n&quot;
    out.puts
    out.puts 'Options for CONFIG or ALL:'
    ConfigTable.each do |item|
      out.printf fmt, item.help_opt, item.description, item.help_default
    end
    out.printf fmt, '--rbconfig=path', 'rbconfig.rb to load',&quot;running ruby's&quot;
    out.puts
    out.puts 'Options for INSTALL:'
    out.printf fmt, '--no-harm', 'only display what to do if given', 'off'
    out.printf fmt, '--prefix=path',  'install path prefix', '$prefix'
    out.puts
  end

  #
  # Task Handlers
  #

  def exec_config
    @installer.exec_config
    @config.save   # must be final
  end

  def exec_setup
    @installer.exec_setup
  end

  def exec_install
    @installer.exec_install
  end

  def exec_show
    ConfigTable.each do |i|
      printf &quot;%-20s %s\n&quot;, i.name, i.value
    end
  end

  def exec_clean
    @installer.exec_clean
  end

  def exec_distclean
    @installer.exec_distclean
  end

end


class ToplevelInstallerMulti &lt; ToplevelInstaller

  include HookUtils
  include HookScriptAPI
  include FileOperations

  def initialize(ardir)
    super
    @packages = all_dirs_in(&quot;#{@ardir}/packages&quot;)
    raise 'no package exists' if @packages.empty?
  end

  def run_metaconfigs
    eval_file_ifexist &quot;#{@ardir}/metaconfig&quot;
    @packages.each do |name|
      eval_file_ifexist &quot;#{@ardir}/packages/#{name}/metaconfig&quot;
    end
  end

  def init_installers
    @installers = {}
    @packages.each do |pack|
      @installers[pack] = Installer.new(@config, @options,
                                       &quot;#{@ardir}/packages/#{pack}&quot;,
                                       &quot;packages/#{pack}&quot;)
    end

    with    = extract_selection(config('with'))
    without = extract_selection(config('without'))
    @selected = @installers.keys.select {|name|
                  (with.empty? or with.include?(name)) \
                      and not without.include?(name)
                }
  end

  def extract_selection(list)
    a = list.split(/,/)
    a.each do |name|
      setup_rb_error &quot;no such package: #{name}&quot;  unless @installers.key?(name)
    end
    a
  end

  def print_usage(f)
    super
    f.puts 'Inluded packages:'
    f.puts '  ' + @packages.sort.join(' ')
    f.puts
  end

  #
  # multi-package metaconfig API
  #

  attr_reader :packages

  def declare_packages(list)
    raise 'package list is empty' if list.empty?
    list.each do |name|
      raise &quot;directory packages/#{name} does not exist&quot;\
              unless File.dir?(&quot;#{@ardir}/packages/#{name}&quot;)
    end
    @packages = list
  end

  #
  # Task Handlers
  #

  def exec_config
    run_hook 'pre-config'
    each_selected_installers {|inst| inst.exec_config }
    run_hook 'post-config'
    @config.save   # must be final
  end

  def exec_setup
    run_hook 'pre-setup'
    each_selected_installers {|inst| inst.exec_setup }
    run_hook 'post-setup'
  end

  def exec_install
    run_hook 'pre-install'
    each_selected_installers {|inst| inst.exec_install }
    run_hook 'post-install'
  end

  def exec_clean
    rm_f ConfigTable.savefile
    run_hook 'pre-clean'
    each_selected_installers {|inst| inst.exec_clean }
    run_hook 'post-clean'
  end

  def exec_distclean
    rm_f ConfigTable.savefile
    run_hook 'pre-distclean'
    each_selected_installers {|inst| inst.exec_distclean }
    run_hook 'post-distclean'
  end

  #
  # lib
  #

  def each_selected_installers
    Dir.mkdir 'packages' unless File.dir?('packages')
    @selected.each do |pack|
      $stderr.puts &quot;Processing the package `#{pack}' ...&quot; if @options['verbose']
      Dir.mkdir &quot;packages/#{pack}&quot; unless File.dir?(&quot;packages/#{pack}&quot;)
      Dir.chdir &quot;packages/#{pack}&quot;
      yield @installers[pack]
      Dir.chdir '../..'
    end
  end

  def verbose?
    @options['verbose']
  end

  def no_harm?
    @options['no-harm']
  end

end


class Installer

  FILETYPES = %w( bin lib ext data )

  include HookScriptAPI
  include HookUtils
  include FileOperations

  def initialize(config, opt, srcroot, objroot)
    @config = config
    @options = opt
    @srcdir = File.expand_path(srcroot)
    @objdir = File.expand_path(objroot)
    @currdir = '.'
  end

  def inspect
    &quot;#&lt;#{self.class} #{File.basename(@srcdir)}&gt;&quot;
  end

  #
  # Hook Script API base methods
  #

  def srcdir_root
    @srcdir
  end

  def objdir_root
    @objdir
  end

  def relpath
    @currdir
  end

  #
  # configs/options
  #

  def no_harm?
    @options['no-harm']
  end

  def verbose?
    @options['verbose']
  end

  def verbose_off
    begin
      save, @options['verbose'] = @options['verbose'], false
      yield
    ensure
      @options['verbose'] = save
    end
  end

  #
  # TASK config
  #

  def exec_config
    exec_task_traverse 'config'
  end

  def config_dir_bin(rel)
  end

  def config_dir_lib(rel)
  end

  def config_dir_ext(rel)
    extconf if extdir?(curr_srcdir())
  end

  def extconf
    opt = @options['config-opt'].join(' ')
    command &quot;#{config('rubyprog')} #{curr_srcdir()}/extconf.rb #{opt}&quot;
  end

  def config_dir_data(rel)
  end

  #
  # TASK setup
  #

  def exec_setup
    exec_task_traverse 'setup'
  end

  def setup_dir_bin(rel)
    all_files_in(curr_srcdir()).each do |fname|
      adjust_shebang &quot;#{curr_srcdir()}/#{fname}&quot;
    end
  end

  def adjust_shebang(path)
    return if no_harm?
    tmpfile = File.basename(path) + '.tmp'
    begin
      File.open(path, 'rb') {|r|
        first = r.gets
        return unless File.basename(config('rubypath')) == 'ruby'
        return unless File.basename(first.sub(/\A\#!/, '').split[0]) == 'ruby'
        $stderr.puts &quot;adjusting shebang: #{File.basename(path)}&quot; if verbose?
        File.open(tmpfile, 'wb') {|w|
          w.print first.sub(/\A\#!\s*\S+/, '#! ' + config('rubypath'))
          w.write r.read
        }
        move_file tmpfile, File.basename(path)
      }
    ensure
      File.unlink tmpfile if File.exist?(tmpfile)
    end
  end

  def setup_dir_lib(rel)
  end

  def setup_dir_ext(rel)
    make if extdir?(curr_srcdir())
  end

  def setup_dir_data(rel)
  end

  #
  # TASK install
  #

  def exec_install
    rm_f 'InstalledFiles'
    exec_task_traverse 'install'
  end

  def install_dir_bin(rel)
    install_files collect_filenames_auto(), &quot;#{config('bindir')}/#{rel}&quot;, 0755
  end

  def install_dir_lib(rel)
    install_files ruby_scripts(), &quot;#{config('rbdir')}/#{rel}&quot;, 0644
  end

  def install_dir_ext(rel)
    return unless extdir?(curr_srcdir())
    install_files ruby_extentions('.'),
                  &quot;#{config('sodir')}/#{File.dirname(rel)}&quot;,
                  0555
  end

  def install_dir_data(rel)
    install_files collect_filenames_auto(), &quot;#{config('datadir')}/#{rel}&quot;, 0644
  end

  def install_files(list, dest, mode)
    mkdir_p dest, @options['install-prefix']
    list.each do |fname|
      install fname, dest, mode, @options['install-prefix']
    end
  end

  def ruby_scripts
    collect_filenames_auto().select {|n| /\.rb\z/ =~ n }
  end
  
  # picked up many entries from cvs-1.11.1/src/ignore.c
  reject_patterns = %w( 
    core RCSLOG tags TAGS .make.state
    .nse_depinfo #* .#* cvslog.* ,* .del-* *.olb
    *~ *.old *.bak *.BAK *.orig *.rej _$* *$

    *.org *.in .*
  )
  mapping = {
    '.' =&gt; '\.',
    '$' =&gt; '\$',
    '#' =&gt; '\#',
    '*' =&gt; '.*'
  }
  REJECT_PATTERNS = Regexp.new('\A(?:' +
                               reject_patterns.map {|pat|
                                 pat.gsub(/[\.\$\#\*]/) {|ch| mapping[ch] }
                               }.join('|') +
                               ')\z')

  def collect_filenames_auto
    mapdir((existfiles() - hookfiles()).reject {|fname|
             REJECT_PATTERNS =~ fname
           })
  end

  def existfiles
    all_files_in(curr_srcdir()) | all_files_in('.')
  end

  def hookfiles
    %w( pre-%s post-%s pre-%s.rb post-%s.rb ).map {|fmt|
      %w( config setup install clean ).map {|t| sprintf(fmt, t) }
    }.flatten
  end

  def mapdir(filelist)
    filelist.map {|fname|
      if File.exist?(fname)   # objdir
        fname
      else                    # srcdir
        File.join(curr_srcdir(), fname)
      end
    }
  end

  def ruby_extentions(dir)
    Dir.open(dir) {|d|
      ents = d.select {|fname| /\.#{::Config::CONFIG['DLEXT']}\z/ =~ fname }
      if ents.empty?
        setup_rb_error &quot;no ruby extention exists: 'ruby #{$0} setup' first&quot;
      end
      return ents
    }
  end

  #
  # TASK clean
  #

  def exec_clean
    exec_task_traverse 'clean'
    rm_f ConfigTable.savefile
    rm_f 'InstalledFiles'
  end

  def clean_dir_bin(rel)
  end

  def clean_dir_lib(rel)
  end

  def clean_dir_ext(rel)
    return unless extdir?(curr_srcdir())
    make 'clean' if File.file?('Makefile')
  end

  def clean_dir_data(rel)
  end

  #
  # TASK distclean
  #

  def exec_distclean
    exec_task_traverse 'distclean'
    rm_f ConfigTable.savefile
    rm_f 'InstalledFiles'
  end

  def distclean_dir_bin(rel)
  end

  def distclean_dir_lib(rel)
  end

  def distclean_dir_ext(rel)
    return unless extdir?(curr_srcdir())
    make 'distclean' if File.file?('Makefile')
  end

  #
  # lib
  #

  def exec_task_traverse(task)
    run_hook &quot;pre-#{task}&quot;
    FILETYPES.each do |type|
      if config('without-ext') == 'yes' and type == 'ext'
        $stderr.puts 'skipping ext/* by user option' if verbose?
        next
      end
      traverse task, type, &quot;#{task}_dir_#{type}&quot;
    end
    run_hook &quot;post-#{task}&quot;
  end

  def traverse(task, rel, mid)
    dive_into(rel) {
      run_hook &quot;pre-#{task}&quot;
      __send__ mid, rel.sub(%r[\A.*?(?:/|\z)], '')
      all_dirs_in(curr_srcdir()).each do |d|
        traverse task, &quot;#{rel}/#{d}&quot;, mid
      end
      run_hook &quot;post-#{task}&quot;
    }
  end

  def dive_into(rel)
    return unless File.dir?(&quot;#{@srcdir}/#{rel}&quot;)

    dir = File.basename(rel)
    Dir.mkdir dir unless File.dir?(dir)
    prevdir = Dir.pwd
    Dir.chdir dir
    $stderr.puts '---&gt; ' + rel if verbose?
    @currdir = rel
    yield
    Dir.chdir prevdir
    $stderr.puts '&lt;--- ' + rel if verbose?
    @currdir = File.dirname(rel)
  end

end


if $0 == __FILE__
  begin
    if multipackage_install?
      ToplevelInstallerMulti.invoke
    else
      ToplevelInstaller.invoke
    end
  rescue SetupError
    raise if $DEBUG
    $stderr.puts $!.message
    $stderr.puts &quot;Try 'ruby #{$0} --help' for detailed usage.&quot;
    exit 1
  end
end
</pre>
    </div>