  <div id="fileHeader">
    <h1>aggregations.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activerecord/lib/active_record/aggregations.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Tue Sep 05 11:54:24 -0700 2006</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>module ActiveRecord
  module Aggregations # :nodoc:
    def self.included(base)
      base.extend(ClassMethods)
    end

    def clear_aggregation_cache #:nodoc:
      self.class.reflect_on_all_aggregations.to_a.each do |assoc|
        instance_variable_set &quot;@#{assoc.name}&quot;, nil
      end unless self.new_record?
    end

    # Active Record implements aggregation through a macro-like class method called +composed_of+ for representing attributes 
    # as value objects. It expresses relationships like &quot;Account [is] composed of Money [among other things]&quot; or &quot;Person [is]
    # composed of [an] address&quot;. Each call to the macro adds a description of how the value objects are created from the 
    # attributes of the entity object (when the entity is initialized either as a new object or from finding an existing object) 
    # and how it can be turned back into attributes (when the entity is saved to the database). Example:
    #
    #   class Customer &lt; ActiveRecord::Base
    #     composed_of :balance, :class_name =&gt; &quot;Money&quot;, :mapping =&gt; %w(balance amount)
    #     composed_of :address, :mapping =&gt; [ %w(address_street street), %w(address_city city) ]
    #   end
    #
    # The customer class now has the following methods to manipulate the value objects:
    # * &lt;tt&gt;Customer#balance, Customer#balance=(money)&lt;/tt&gt;
    # * &lt;tt&gt;Customer#address, Customer#address=(address)&lt;/tt&gt;
    #
    # These methods will operate with value objects like the ones described below:
    #
    #  class Money
    #    include Comparable
    #    attr_reader :amount, :currency
    #    EXCHANGE_RATES = { &quot;USD_TO_DKK&quot; =&gt; 6 }  
    # 
    #    def initialize(amount, currency = &quot;USD&quot;) 
    #      @amount, @currency = amount, currency 
    #    end
    #
    #    def exchange_to(other_currency)
    #      exchanged_amount = (amount * EXCHANGE_RATES[&quot;#{currency}_TO_#{other_currency}&quot;]).floor
    #      Money.new(exchanged_amount, other_currency)
    #    end
    #
    #    def ==(other_money)
    #      amount == other_money.amount &amp;&amp; currency == other_money.currency
    #    end
    #
    #    def &lt;=&gt;(other_money)
    #      if currency == other_money.currency
    #        amount &lt;=&gt; amount
    #      else
    #        amount &lt;=&gt; other_money.exchange_to(currency).amount
    #      end
    #    end
    #  end
    #
    #  class Address
    #    attr_reader :street, :city
    #    def initialize(street, city) 
    #      @street, @city = street, city 
    #    end
    #
    #    def close_to?(other_address) 
    #      city == other_address.city 
    #    end
    #
    #    def ==(other_address)
    #      city == other_address.city &amp;&amp; street == other_address.street
    #    end
    #  end
    #  
    # Now it's possible to access attributes from the database through the value objects instead. If you choose to name the
    # composition the same as the attributes name, it will be the only way to access that attribute. That's the case with our
    # +balance+ attribute. You interact with the value objects just like you would any other attribute, though:
    #
    #   customer.balance = Money.new(20)     # sets the Money value object and the attribute
    #   customer.balance                     # =&gt; Money value object
    #   customer.balance.exchanged_to(&quot;DKK&quot;) # =&gt; Money.new(120, &quot;DKK&quot;)
    #   customer.balance &gt; Money.new(10)     # =&gt; true
    #   customer.balance == Money.new(20)    # =&gt; true
    #   customer.balance &lt; Money.new(5)      # =&gt; false
    #
    # Value objects can also be composed of multiple attributes, such as the case of Address. The order of the mappings will
    # determine the order of the parameters. Example:
    #
    #   customer.address_street = &quot;Hyancintvej&quot;
    #   customer.address_city   = &quot;Copenhagen&quot;
    #   customer.address        # =&gt; Address.new(&quot;Hyancintvej&quot;, &quot;Copenhagen&quot;)
    #   customer.address = Address.new(&quot;May Street&quot;, &quot;Chicago&quot;)
    #   customer.address_street # =&gt; &quot;May Street&quot; 
    #   customer.address_city   # =&gt; &quot;Chicago&quot; 
    #
    # == Writing value objects
    #
    # Value objects are immutable and interchangeable objects that represent a given value, such as a Money object representing
    # $5. Two Money objects both representing $5 should be equal (through methods such as == and &lt;=&gt; from Comparable if ranking
    # makes sense). This is unlike entity objects where equality is determined by identity. An entity class such as Customer can
    # easily have two different objects that both have an address on Hyancintvej. Entity identity is determined by object or
    # relational unique identifiers (such as primary keys). Normal ActiveRecord::Base classes are entity objects.
    #
    # It's also important to treat the value objects as immutable. Don't allow the Money object to have its amount changed after
    # creation. Create a new money object with the new value instead. This is exemplified by the Money#exchanged_to method that
    # returns a new value object instead of changing its own values. Active Record won't persist value objects that have been
    # changed through other means than the writer method.
    #
    # The immutable requirement is enforced by Active Record by freezing any object assigned as a value object. Attempting to 
    # change it afterwards will result in a TypeError.
    # 
    # Read more about value objects on http://c2.com/cgi/wiki?ValueObject and on the dangers of not keeping value objects
    # immutable on http://c2.com/cgi/wiki?ValueObjectsShouldBeImmutable
    module ClassMethods
      # Adds reader and writer methods for manipulating a value object:
      # &lt;tt&gt;composed_of :address&lt;/tt&gt; adds &lt;tt&gt;address&lt;/tt&gt; and &lt;tt&gt;address=(new_address)&lt;/tt&gt; methods.
      #
      # Options are:
      # * &lt;tt&gt;:class_name&lt;/tt&gt;  - specify the class name of the association. Use it only if that name can't be inferred
      #   from the part id. So &lt;tt&gt;composed_of :address&lt;/tt&gt; will by default be linked to the +Address+ class, but
      #   if the real class name is +CompanyAddress+, you'll have to specify it with this option.
      # * &lt;tt&gt;:mapping&lt;/tt&gt; - specifies a number of mapping arrays (attribute, parameter) that bind an attribute name
      #   to a constructor parameter on the value class.
      # * &lt;tt&gt;:allow_nil&lt;/tt&gt; - specifies that the aggregate object will not be instantiated when all mapped
      #   attributes are nil.  Setting the aggregate class to nil has the effect of writing nil to all mapped attributes.
      #   This defaults to false.
      #
      # Option examples:
      #   composed_of :temperature, :mapping =&gt; %w(reading celsius)
      #   composed_of :balance, :class_name =&gt; &quot;Money&quot;, :mapping =&gt; %w(balance amount)
      #   composed_of :address, :mapping =&gt; [ %w(address_street street), %w(address_city city) ]
      #   composed_of :gps_location
      #   composed_of :gps_location, :allow_nil =&gt; true
      #
      def composed_of(part_id, options = {})
        options.assert_valid_keys(:class_name, :mapping, :allow_nil)

        name        = part_id.id2name
        class_name  = options[:class_name] || name.camelize
        mapping     = options[:mapping]    || [ name, name ]
        allow_nil   = options[:allow_nil]  || false

        reader_method(name, class_name, mapping, allow_nil)
        writer_method(name, class_name, mapping, allow_nil)
        
        create_reflection(:composed_of, part_id, options, self)
      end

      private
        def reader_method(name, class_name, mapping, allow_nil)
          mapping = (Array === mapping.first ? mapping : [ mapping ])

          allow_nil_condition = if allow_nil
            mapping.collect { |pair| &quot;!read_attribute(\&quot;#{pair.first}\&quot;).nil?&quot;}.join(&quot; &amp;&amp; &quot;)
          else
            &quot;true&quot;
          end

          module_eval &lt;&lt;-end_eval
            def #{name}(force_reload = false)
              if (@#{name}.nil? || force_reload) &amp;&amp; #{allow_nil_condition}
                @#{name} = #{class_name}.new(#{mapping.collect { |pair| &quot;read_attribute(\&quot;#{pair.first}\&quot;)&quot;}.join(&quot;, &quot;)})
              end
              return @#{name}
            end
          end_eval
        end        
        
        def writer_method(name, class_name, mapping, allow_nil)
          mapping = (Array === mapping.first ? mapping : [ mapping ])

          if allow_nil
            module_eval &lt;&lt;-end_eval
              def #{name}=(part)
                if part.nil?
                  #{mapping.collect { |pair| &quot;@attributes[\&quot;#{pair.first}\&quot;] = nil&quot; }.join(&quot;\n&quot;)}
                else
                  @#{name} = part.freeze
                  #{mapping.collect { |pair| &quot;@attributes[\&quot;#{pair.first}\&quot;] = part.#{pair.last}&quot; }.join(&quot;\n&quot;)}
                end
              end
            end_eval
          else
            module_eval &lt;&lt;-end_eval
              def #{name}=(part)
                @#{name} = part.freeze
                #{mapping.collect{ |pair| &quot;@attributes[\&quot;#{pair.first}\&quot;] = part.#{pair.last}&quot; }.join(&quot;\n&quot;)}
              end
            end_eval
          end
        end
    end
  end
end
</pre>
    </div>