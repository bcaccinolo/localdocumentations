  <div id="fileHeader">
    <h1>schema_definitions.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activerecord/lib/active_record/connection_adapters/abstract/schema_definitions.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon Jan 15 07:51:54 -0800 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'date'
require 'bigdecimal'
require 'bigdecimal/util'

module ActiveRecord
  module ConnectionAdapters #:nodoc:
    # An abstract definition of a column in a table.
    class Column
      attr_reader :name, :default, :type, :limit, :null, :sql_type, :precision, :scale
      attr_accessor :primary

      # Instantiates a new column in the table.
      #
      # +name+ is the column's name, as in &lt;tt&gt;&lt;b&gt;supplier_id&lt;/b&gt; int(11)&lt;/tt&gt;.
      # +default+ is the type-casted default value, such as &lt;tt&gt;sales_stage varchar(20) default &lt;b&gt;'new'&lt;/b&gt;&lt;/tt&gt;.
      # +sql_type+ is only used to extract the column's length, if necessary.  For example, &lt;tt&gt;company_name varchar(&lt;b&gt;60&lt;/b&gt;)&lt;/tt&gt;.
      # +null+ determines if this column allows +NULL+ values.
      def initialize(name, default, sql_type = nil, null = true)
        @name, @sql_type, @null = name, sql_type, null
        @limit, @precision, @scale  = extract_limit(sql_type), extract_precision(sql_type), extract_scale(sql_type) 
        @type = simplified_type(sql_type)
        @default = type_cast(default)

        @primary = nil
      end

      def text?
        [:string, :text].include? type
      end

      def number?
        [:float, :integer, :decimal].include? type
      end

      # Returns the Ruby class that corresponds to the abstract data type.
      def klass
        case type
          when :integer       then Fixnum
          when :float         then Float
          when :decimal       then BigDecimal
          when :datetime      then Time
          when :date          then Date
          when :timestamp     then Time
          when :time          then Time
          when :text, :string then String
          when :binary        then String
          when :boolean       then Object
        end
      end

      # Casts value (which is a String) to an appropriate instance.
      def type_cast(value)
        return nil if value.nil?
        case type
          when :string    then value
          when :text      then value
          when :integer   then value.to_i rescue value ? 1 : 0
          when :float     then value.to_f
          when :decimal   then self.class.value_to_decimal(value)
          when :datetime  then self.class.string_to_time(value)
          when :timestamp then self.class.string_to_time(value)
          when :time      then self.class.string_to_dummy_time(value)
          when :date      then self.class.string_to_date(value)
          when :binary    then self.class.binary_to_string(value)
          when :boolean   then self.class.value_to_boolean(value)
          else value
        end
      end

      def type_cast_code(var_name)
        case type
          when :string    then nil
          when :text      then nil
          when :integer   then &quot;(#{var_name}.to_i rescue #{var_name} ? 1 : 0)&quot;
          when :float     then &quot;#{var_name}.to_f&quot;
          when :decimal   then &quot;#{self.class.name}.value_to_decimal(#{var_name})&quot;
          when :datetime  then &quot;#{self.class.name}.string_to_time(#{var_name})&quot;
          when :timestamp then &quot;#{self.class.name}.string_to_time(#{var_name})&quot;
          when :time      then &quot;#{self.class.name}.string_to_dummy_time(#{var_name})&quot;
          when :date      then &quot;#{self.class.name}.string_to_date(#{var_name})&quot;
          when :binary    then &quot;#{self.class.name}.binary_to_string(#{var_name})&quot;
          when :boolean   then &quot;#{self.class.name}.value_to_boolean(#{var_name})&quot;
          else nil
        end
      end

      # Returns the human name of the column name.
      #
      # ===== Examples
      #  Column.new('sales_stage', ...).human_name #=&gt; 'Sales stage'
      def human_name
        Base.human_attribute_name(@name)
      end

      # Used to convert from Strings to BLOBs
      def self.string_to_binary(value)
        value
      end

      # Used to convert from BLOBs to Strings
      def self.binary_to_string(value)
        value
      end

      def self.string_to_date(string)
        return string unless string.is_a?(String)
        date_array = ParseDate.parsedate(string)
        # treat 0000-00-00 as nil
        Date.new(date_array[0], date_array[1], date_array[2]) rescue nil
      end

      def self.string_to_time(string)
        return string unless string.is_a?(String)
        time_hash = Date._parse(string)
        time_hash[:sec_fraction] = microseconds(time_hash)
        time_array = time_hash.values_at(:year, :mon, :mday, :hour, :min, :sec, :sec_fraction)
        # treat 0000-00-00 00:00:00 as nil
        Time.send(Base.default_timezone, *time_array) rescue DateTime.new(*time_array[0..5]) rescue nil
      end

      def self.string_to_dummy_time(string)
        return string unless string.is_a?(String)
        return nil if string.empty?
        time_hash = Date._parse(string)
        time_hash[:sec_fraction] = microseconds(time_hash)
        # pad the resulting array with dummy date information
        time_array = [2000, 1, 1]
        time_array += time_hash.values_at(:hour, :min, :sec, :sec_fraction)
        Time.send(Base.default_timezone, *time_array) rescue nil
      end

      # convert something to a boolean
      def self.value_to_boolean(value)
        if value == true || value == false
          value
        else
          %w(true t 1).include?(value.to_s.downcase)
        end
      end

      # convert something to a BigDecimal
      def self.value_to_decimal(value)
        if value.is_a?(BigDecimal)
          value
        elsif value.respond_to?(:to_d)
          value.to_d
        else
          value.to_s.to_d
        end
      end

      private
        # '0.123456' -&gt; 123456
        # '1.123456' -&gt; 123456
        def self.microseconds(time)
          ((time[:sec_fraction].to_f % 1) * 1_000_000).to_i
        end

        def extract_limit(sql_type)
          $1.to_i if sql_type =~ /\((.*)\)/
        end

        def extract_precision(sql_type)
          $2.to_i if sql_type =~ /^(numeric|decimal|number)\((\d+)(,\d+)?\)/i
        end

        def extract_scale(sql_type)
          case sql_type
            when /^(numeric|decimal|number)\((\d+)\)/i then 0
            when /^(numeric|decimal|number)\((\d+)(,(\d+))\)/i then $4.to_i
          end
        end

        def simplified_type(field_type)
          case field_type
            when /int/i
              :integer
            when /float|double/i
              :float
            when /decimal|numeric|number/i
              extract_scale(field_type) == 0 ? :integer : :decimal
            when /datetime/i
              :datetime
            when /timestamp/i
              :timestamp
            when /time/i
              :time
            when /date/i
              :date
            when /clob/i, /text/i
              :text
            when /blob/i, /binary/i
              :binary
            when /char/i, /string/i
              :string
            when /boolean/i
              :boolean
          end
        end
    end

    class IndexDefinition &lt; Struct.new(:table, :name, :unique, :columns) #:nodoc:
    end

    class ColumnDefinition &lt; Struct.new(:base, :name, :type, :limit, :precision, :scale, :default, :null) #:nodoc:
      
      def sql_type
        base.type_to_sql(type.to_sym, limit, precision, scale) rescue type
      end
      
      def to_sql
        column_sql = &quot;#{base.quote_column_name(name)} #{sql_type}&quot;
        add_column_options!(column_sql, :null =&gt; null, :default =&gt; default) unless type.to_sym == :primary_key
        column_sql
      end
      alias to_s :to_sql

      private

        def add_column_options!(sql, options)
          base.add_column_options!(sql, options.merge(:column =&gt; self))
        end
    end

    # Represents a SQL table in an abstract way.
    # Columns are stored as ColumnDefinition in the #columns attribute.
    class TableDefinition
      attr_accessor :columns

      def initialize(base)
        @columns = []
        @base = base
      end

      # Appends a primary key definition to the table definition.
      # Can be called multiple times, but this is probably not a good idea.
      def primary_key(name)
        column(name, :primary_key)
      end

      # Returns a ColumnDefinition for the column with name +name+.
      def [](name)
        @columns.find {|column| column.name.to_s == name.to_s}
      end

      # Instantiates a new column for the table.
      # The +type+ parameter must be one of the following values:
      # &lt;tt&gt;:primary_key&lt;/tt&gt;, &lt;tt&gt;:string&lt;/tt&gt;, &lt;tt&gt;:text&lt;/tt&gt;,
      # &lt;tt&gt;:integer&lt;/tt&gt;, &lt;tt&gt;:float&lt;/tt&gt;, &lt;tt&gt;:decimal&lt;/tt&gt;,
      # &lt;tt&gt;:datetime&lt;/tt&gt;, &lt;tt&gt;:timestamp&lt;/tt&gt;, &lt;tt&gt;:time&lt;/tt&gt;,
      # &lt;tt&gt;:date&lt;/tt&gt;, &lt;tt&gt;:binary&lt;/tt&gt;, &lt;tt&gt;:boolean&lt;/tt&gt;.
      #
      # Available options are (none of these exists by default):
      # * &lt;tt&gt;:limit&lt;/tt&gt;:
      #   Requests a maximum column length (&lt;tt&gt;:string&lt;/tt&gt;, &lt;tt&gt;:text&lt;/tt&gt;,
      #   &lt;tt&gt;:binary&lt;/tt&gt; or &lt;tt&gt;:integer&lt;/tt&gt; columns only)
      # * &lt;tt&gt;:default&lt;/tt&gt;:
      #   The column's default value. Use nil for NULL.
      # * &lt;tt&gt;:null&lt;/tt&gt;:
      #   Allows or disallows +NULL+ values in the column.  This option could
      #   have been named &lt;tt&gt;:null_allowed&lt;/tt&gt;.
      # * &lt;tt&gt;:precision&lt;/tt&gt;:
      #   Specifies the precision for a &lt;tt&gt;:decimal&lt;/tt&gt; column. 
      # * &lt;tt&gt;:scale&lt;/tt&gt;:
      #   Specifies the scale for a &lt;tt&gt;:decimal&lt;/tt&gt; column. 
      #
      # Please be aware of different RDBMS implementations behavior with
      # &lt;tt&gt;:decimal&lt;/tt&gt; columns:
      # * The SQL standard says the default scale should be 0, &lt;tt&gt;:scale&lt;/tt&gt; &lt;=
      #   &lt;tt&gt;:precision&lt;/tt&gt;, and makes no comments about the requirements of
      #   &lt;tt&gt;:precision&lt;/tt&gt;.
      # * MySQL: &lt;tt&gt;:precision&lt;/tt&gt; [1..63], &lt;tt&gt;:scale&lt;/tt&gt; [0..30]. 
      #   Default is (10,0).
      # * PostgreSQL: &lt;tt&gt;:precision&lt;/tt&gt; [1..infinity], 
      #   &lt;tt&gt;:scale&lt;/tt&gt; [0..infinity]. No default.
      # * SQLite2: Any &lt;tt&gt;:precision&lt;/tt&gt; and &lt;tt&gt;:scale&lt;/tt&gt; may be used. 
      #   Internal storage as strings. No default.
      # * SQLite3: No restrictions on &lt;tt&gt;:precision&lt;/tt&gt; and &lt;tt&gt;:scale&lt;/tt&gt;,
      #   but the maximum supported &lt;tt&gt;:precision&lt;/tt&gt; is 16. No default.
      # * Oracle: &lt;tt&gt;:precision&lt;/tt&gt; [1..38], &lt;tt&gt;:scale&lt;/tt&gt; [-84..127]. 
      #   Default is (38,0).
      # * DB2: &lt;tt&gt;:precision&lt;/tt&gt; [1..63], &lt;tt&gt;:scale&lt;/tt&gt; [0..62]. 
      #   Default unknown.
      # * Firebird: &lt;tt&gt;:precision&lt;/tt&gt; [1..18], &lt;tt&gt;:scale&lt;/tt&gt; [0..18]. 
      #   Default (9,0). Internal types NUMERIC and DECIMAL have different
      #   storage rules, decimal being better.
      # * FrontBase?: &lt;tt&gt;:precision&lt;/tt&gt; [1..38], &lt;tt&gt;:scale&lt;/tt&gt; [0..38]. 
      #   Default (38,0). WARNING Max &lt;tt&gt;:precision&lt;/tt&gt;/&lt;tt&gt;:scale&lt;/tt&gt; for
      #   NUMERIC is 19, and DECIMAL is 38.
      # * SqlServer?: &lt;tt&gt;:precision&lt;/tt&gt; [1..38], &lt;tt&gt;:scale&lt;/tt&gt; [0..38]. 
      #   Default (38,0).
      # * Sybase: &lt;tt&gt;:precision&lt;/tt&gt; [1..38], &lt;tt&gt;:scale&lt;/tt&gt; [0..38]. 
      #   Default (38,0).
      # * OpenBase?: Documentation unclear. Claims storage in &lt;tt&gt;double&lt;/tt&gt;.
      #
      # This method returns &lt;tt&gt;self&lt;/tt&gt;.
      #
      # ===== Examples
      #  # Assuming td is an instance of TableDefinition
      #  td.column(:granted, :boolean)
      #    #=&gt; granted BOOLEAN
      #
      #  td.column(:picture, :binary, :limit =&gt; 2.megabytes)
      #    #=&gt; picture BLOB(2097152)
      #
      #  td.column(:sales_stage, :string, :limit =&gt; 20, :default =&gt; 'new', :null =&gt; false)
      #    #=&gt; sales_stage VARCHAR(20) DEFAULT 'new' NOT NULL
      #
      #  def.column(:bill_gates_money, :decimal, :precision =&gt; 15, :scale =&gt; 2)
      #    #=&gt; bill_gates_money DECIMAL(15,2)
      #
      #  def.column(:sensor_reading, :decimal, :precision =&gt; 30, :scale =&gt; 20)
      #    #=&gt; sensor_reading DECIMAL(30,20)
      #
      #  # While &lt;tt&gt;:scale&lt;/tt&gt; defaults to zero on most databases, it
      #  # probably wouldn't hurt to include it.
      #  def.column(:huge_integer, :decimal, :precision =&gt; 30)
      #    #=&gt; huge_integer DECIMAL(30)
      def column(name, type, options = {})
        column = self[name] || ColumnDefinition.new(@base, name, type)
        column.limit = options[:limit] || native[type.to_sym][:limit] if options[:limit] or native[type.to_sym]
        column.precision = options[:precision]
        column.scale = options[:scale]
        column.default = options[:default]
        column.null = options[:null]
        @columns &lt;&lt; column unless @columns.include? column
        self
      end

      # Returns a String whose contents are the column definitions
      # concatenated together.  This string can then be pre and appended to
      # to generate the final SQL to create the table.
      def to_sql
        @columns * ', '
      end

      private
        def native
          @base.native_database_types
        end
    end
  end
end
</pre>
    </div>