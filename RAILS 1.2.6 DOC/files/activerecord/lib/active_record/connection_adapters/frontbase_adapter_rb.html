  <div id="fileHeader">
    <h1>frontbase_adapter.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activerecord/lib/active_record/connection_adapters/frontbase_adapter.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Thu Jan 18 08:52:47 -0800 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre># Requires FrontBase Ruby bindings (gem install ruby-frontbase)

require 'active_record/connection_adapters/abstract_adapter'

FB_TRACE = false

module ActiveRecord

  class Base
    class &lt;&lt; self
      # Establishes a connection to the database that's used by all Active Record objects.
      def frontbase_connection(config) # :nodoc:
        # FrontBase only supports one unnamed sequence per table
        define_attr_method(:set_sequence_name, :sequence_name, &amp;Proc.new {|*args| nil})

        config = config.symbolize_keys
        database     = config[:database]
        port         = config[:port]
        host         = config[:host]
        username     = config[:username]
        password     = config[:password]
        dbpassword   = config[:dbpassword]
        session_name = config[:session_name]

        dbpassword = '' if dbpassword.nil?
        
        # Turn off colorization since it makes tail/less output difficult
        self.colorize_logging = false

        require_library_or_gem 'frontbase' unless self.class.const_defined? :FBSQL_Connect
        
        # Check bindings version
        version = &quot;0.0.0&quot;
        version = FBSQL_Connect::FB_BINDINGS_VERSION if defined? FBSQL_Connect::FB_BINDINGS_VERSION
        
        if ActiveRecord::ConnectionAdapters::FrontBaseAdapter.compare_versions(version,&quot;1.0.0&quot;) == -1
          raise AdapterNotFound,
            'The FrontBase adapter requires ruby-frontbase version 1.0.0 or greater; you appear ' &lt;&lt;
            &quot;to be running an older version (#{version}) -- please update ruby-frontbase (gem install ruby-frontbase).&quot;
        end
        connection = FBSQL_Connect.connect(host, port, database, username, password, dbpassword, session_name)
        ConnectionAdapters::FrontBaseAdapter.new(connection, logger, [host, port, database, username, password, dbpassword, session_name], config)
      end            
    end    
  end
  
  module ConnectionAdapters
    
    # From EOF Documentation....
    # buffer should have space for EOUniqueBinaryKeyLength (12) bytes.
    # Assigns a world-wide unique ID made up of:
    # &lt; Sequence [2], ProcessID [2] , Time [4], IP Addr [4] &gt;
    
    class TwelveByteKey &lt; String #:nodoc:
      @@mutex = Mutex.new
      @@sequence_number = rand(65536)
      @@key_cached_pid_component = nil
      @@key_cached_ip_component = nil

      def initialize(string = nil)
        # Generate a unique key
        if string.nil?
          new_key = replace('_' * 12)

          new_key[0..1]  = self.class.key_sequence_component        
          new_key[2..3]  = self.class.key_pid_component
          new_key[4..7]  = self.class.key_time_component
          new_key[8..11] = self.class.key_ip_component
          new_key
        else
          if string.size == 24
            string.gsub!(/[[:xdigit:]]{2}/) { |x| x.hex.chr }
          end
          raise &quot;string is not 12 bytes long&quot; unless string.size == 12
          super(string)
        end
      end
            
      def inspect
        unpack(&quot;H*&quot;).first.upcase
      end
    
      alias_method :to_s, :inspect
      
      private
            
        class &lt;&lt; self
          def key_sequence_component
            seq = nil
            @@mutex.synchronize do
              seq = @@sequence_number
              @@sequence_number = (@@sequence_number + 1) % 65536
            end
            
            sequence_component = &quot;__&quot;
            sequence_component[0] = seq &gt;&gt; 8
            sequence_component[1] = seq
            sequence_component
          end
          
          def key_pid_component
            if @@key_cached_pid_component.nil?
              @@mutex.synchronize do
                pid = $$
                pid_component = &quot;__&quot;
                pid_component[0] = pid &gt;&gt; 8
                pid_component[1] = pid
                @@key_cached_pid_component = pid_component
              end
            end
            @@key_cached_pid_component
          end
          
          def key_time_component
            time = Time.new.to_i
            time_component = &quot;____&quot;
            time_component[0] = (time &amp; 0xFF000000) &gt;&gt; 24
            time_component[1] = (time &amp; 0x00FF0000) &gt;&gt; 16
            time_component[2] = (time &amp; 0x0000FF00) &gt;&gt; 8
            time_component[3] = (time &amp; 0x000000FF)
            time_component
          end
          
          def key_ip_component
            if @@key_cached_ip_component.nil?
              @@mutex.synchronize do
                old_lookup_flag  = BasicSocket.do_not_reverse_lookup
                BasicSocket.do_not_reverse_lookup = true
                udpsocket = UDPSocket.new
                udpsocket.connect(&quot;17.112.152.32&quot;,1)
                ip_string = udpsocket.addr[3]
                BasicSocket.do_not_reverse_lookup = old_lookup_flag
                packed = Socket.pack_sockaddr_in(0,ip_string)
                addr_subset = packed[4..7]
                ip = addr_subset[0] &lt;&lt; 24 | addr_subset[1] &lt;&lt; 16 | addr_subset[2] &lt;&lt; 8 | addr_subset[3]
                ip_component = &quot;____&quot;
                ip_component[0] = (ip &amp; 0xFF000000) &gt;&gt; 24
                ip_component[1] = (ip &amp; 0x00FF0000) &gt;&gt; 16
                ip_component[2] = (ip &amp; 0x0000FF00) &gt;&gt; 8
                ip_component[3] = (ip &amp; 0x000000FF)
                @@key_cached_ip_component = ip_component
              end
            end
            @@key_cached_ip_component
          end
        end
    end
    
    class FrontBaseColumn &lt; Column #:nodoc:
      attr_reader :fb_autogen
      
      def initialize(base, name, type, typename, limit, precision, scale, default, nullable)
        
        @base       = base
        @name       = name
        @type       = simplified_type(type,typename,limit)
        @limit      = limit
        @precision  = precision
        @scale      = scale
        @default    = default
        @null       = nullable == &quot;YES&quot;
        @text       = [:string, :text].include? @type
        @number     = [:float, :integer, :decimal].include? @type
        @fb_autogen = false

        if @default
          @default.gsub!(/^'(.*)'$/,'\1') if @text
          @fb_autogen =  @default.include?(&quot;SELECT UNIQUE FROM&quot;)
          case @type
          when :boolean 
            @default = @default == &quot;TRUE&quot;
          when :binary
            if @default != &quot;X''&quot;
              buffer = &quot;&quot;
              @default.scan(/../) { |h| buffer &lt;&lt; h.hex.chr }
              @default = buffer
            else
              @default = &quot;&quot;
            end
          else
            @default = type_cast(@default)
          end
        end
      end
      
      # Casts value (which is a String) to an appropriate instance.
      def type_cast(value)
        if type == :twelvebytekey
          ActiveRecord::ConnectionAdapters::TwelveByteKey.new(value)
        else
          super(value)
        end
      end

      def type_cast_code(var_name)
        if type == :twelvebytekey
          &quot;ActiveRecord::ConnectionAdapters::TwelveByteKey.new(#{var_name})&quot;
        else
          super(var_name)
        end
      end

      private
        def simplified_type(field_type, type_name,limit)
          ret_type = :string
          puts &quot;typecode: [#{field_type}] [#{type_name}]&quot;  if FB_TRACE

          # 12 byte primary keys are a special case that Apple's EOF
          # used heavily.  Optimize for this case
          if field_type == 11 &amp;&amp; limit == 96
           ret_type = :twelvebytekey            # BIT(96)
          else
           ret_type = case field_type
             when 1  then :boolean   # BOOLEAN
             when 2  then :integer   # INTEGER
             when 4  then :float     # FLOAT
             when 10 then :string    # CHARACTER VARYING
             when 11 then :bitfield  # BIT
             when 13 then :date      # DATE
             when 14 then :time      # TIME
             when 16 then :timestamp # TIMESTAMP
             when 20 then :text      # CLOB
             when 21 then :binary    # BLOB
             when 22 then :integer   # TINYINT
             else
               puts &quot;ERROR: Unknown typecode: [#{field_type}] [#{type_name}]&quot;
           end
          end
          puts &quot;ret_type: #{ret_type.inspect}&quot; if FB_TRACE
          ret_type
        end
    end

    class FrontBaseAdapter &lt; AbstractAdapter
        
      class &lt;&lt; self
        def compare_versions(v1, v2)
          v1_seg  = v1.split(&quot;.&quot;)
          v2_seg  = v2.split(&quot;.&quot;)
          0.upto([v1_seg.length,v2_seg.length].min) do |i|
            step  = (v1_seg[i].to_i &lt;=&gt; v2_seg[i].to_i)
            return step unless step == 0
          end
          return v1_seg.length &lt;=&gt; v2_seg.length
        end    
      end
            
      def initialize(connection, logger, connection_options, config)
        super(connection, logger)
        @connection_options, @config = connection_options, config
        @transaction_mode = :pessimistic
        
        # Start out in auto-commit mode
        self.rollback_db_transaction
        
        # threaded_connections_test.rb will fail unless we set the session
        # to optimistic locking mode
#         set_pessimistic_transactions
#         execute &quot;SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ WRITE, LOCKING OPTIMISTIC&quot;
      end

      # Returns the human-readable name of the adapter.  Use mixed case - one
      # can always use downcase if needed.
      def adapter_name #:nodoc:
        'FrontBase'
      end

      # Does this adapter support migrations?  Backend specific, as the
      # abstract adapter always returns +false+.
      def supports_migrations? #:nodoc:
        true
      end

      def native_database_types #:nodoc:
        {
          :primary_key    =&gt; &quot;INTEGER DEFAULT UNIQUE PRIMARY KEY&quot;,
          :string         =&gt; { :name =&gt; &quot;VARCHAR&quot;, :limit =&gt; 255 },
          :text           =&gt; { :name =&gt; &quot;CLOB&quot; },
          :integer        =&gt; { :name =&gt; &quot;INTEGER&quot; },
          :float          =&gt; { :name =&gt; &quot;FLOAT&quot; },
          :decimal        =&gt; { :name =&gt; &quot;DECIMAL&quot; },
          :datetime       =&gt; { :name =&gt; &quot;TIMESTAMP&quot; },
          :timestamp      =&gt; { :name =&gt; &quot;TIMESTAMP&quot; },
          :time           =&gt; { :name =&gt; &quot;TIME&quot; },
          :date           =&gt; { :name =&gt; &quot;DATE&quot; },
          :binary         =&gt; { :name =&gt; &quot;BLOB&quot; },
          :boolean        =&gt; { :name =&gt; &quot;BOOLEAN&quot; },
          :twelvebytekey  =&gt; { :name =&gt; &quot;BYTE&quot;, :limit =&gt; 12}
        }
      end


      # QUOTING ==================================================

      # Quotes the column value to help prevent
      # {SQL injection attacks}[http://en.wikipedia.org/wiki/SQL_injection].
      def quote(value, column = nil)
        return value.quoted_id if value.respond_to?(:quoted_id)

        retvalue = &quot;&lt;INVALID&gt;&quot;

        puts &quot;quote(#{value.inspect}(#{value.class}),#{column.type.inspect})&quot; if FB_TRACE
        # If a column was passed in, use column type information
        unless value.nil?
          if column
            retvalue = case column.type
              when :string
                if value.kind_of?(String)
                  &quot;'#{quote_string(value.to_s)}'&quot; # ' (for ruby-mode)
                else
                  &quot;'#{quote_string(value.to_yaml)}'&quot;
                end
              when :integer
                if value.kind_of?(TrueClass)
                  '1'
                elsif value.kind_of?(FalseClass)
                  '0'
                else
                   value.to_i.to_s
                end
              when :float
                value.to_f.to_s
              when :decimal
                value.to_d.to_s(&quot;F&quot;)
              when :datetime, :timestamp
                &quot;TIMESTAMP '#{value.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)}'&quot;
              when :time
                &quot;TIME '#{value.strftime(&quot;%H:%M:%S&quot;)}'&quot;
              when :date
                &quot;DATE '#{value.strftime(&quot;%Y-%m-%d&quot;)}'&quot;
              when :twelvebytekey
                value = value.to_s.unpack(&quot;H*&quot;).first unless value.kind_of?(TwelveByteKey)
                &quot;X'#{value.to_s}'&quot;
              when :boolean
                value = quoted_true if value.kind_of?(TrueClass)
                value = quoted_false if value.kind_of?(FalseClass)
                value
              when :binary
                blob_handle = @connection.create_blob(value.to_s)
                puts &quot;SQL -&gt; Insert #{value.to_s.length} byte blob as #{retvalue}&quot; if FB_TRACE
                blob_handle.handle
              when :text
                if value.kind_of?(String)
                  clobdata = value.to_s # ' (for ruby-mode)
                else
                  clobdata = value.to_yaml
                end
                clob_handle = @connection.create_clob(clobdata)
                puts &quot;SQL -&gt; Insert #{value.to_s.length} byte clob as #{retvalue}&quot; if FB_TRACE
                clob_handle.handle
              else
                raise &quot;*** UNKNOWN TYPE: #{column.type.inspect}&quot;
            end # case
          # Since we don't have column type info, make a best guess based
          # on the Ruby class of the value
          else
            retvalue = case value
              when ActiveRecord::ConnectionAdapters::TwelveByteKey
                s = value.unpack(&quot;H*&quot;).first
                &quot;X'#{s}'&quot;
              when String
                if column &amp;&amp; column.type == :binary
                  s = value.unpack(&quot;H*&quot;).first
                  &quot;X'#{s}'&quot;
                elsif column &amp;&amp; [:integer, :float, :decimal].include?(column.type) 
                  value.to_s
                else
                  &quot;'#{quote_string(value)}'&quot; # ' (for ruby-mode)
                end
              when NilClass
                &quot;NULL&quot;
              when TrueClass
                (column &amp;&amp; column.type == :integer ? '1' : quoted_true)
              when FalseClass
                (column &amp;&amp; column.type == :integer ? '0' : quoted_false)
              when Float, Fixnum, Bignum, BigDecimal
                value.to_s
              when Time, Date, DateTime
                if column
                  case column.type
                    when :date
                      &quot;DATE '#{value.strftime(&quot;%Y-%m-%d&quot;)}'&quot;
                    when :time
                      &quot;TIME '#{value.strftime(&quot;%H:%M:%S&quot;)}'&quot;
                    when :timestamp
                      &quot;TIMESTAMP '#{value.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)}'&quot;
                  else
                    raise NotImplementedError, &quot;Unknown column type!&quot;
                  end # case
                else # Column wasn't passed in, so try to guess the right type
                  if value.kind_of? Date
                    &quot;DATE '#{value.strftime(&quot;%Y-%m-%d&quot;)}'&quot;
                  else
                    if [:hour, :min, :sec].all? {|part| value.send(:part).zero? }
                      &quot;TIME '#{value.strftime(&quot;%H:%M:%S&quot;)}'&quot;
                    else
                      &quot;TIMESTAMP '#{quoted_date(value)}'&quot;
                    end
                  end 
                end #if column
              else 
                &quot;'#{quote_string(value.to_yaml)}'&quot;
            end #case
          end
        else
          retvalue = &quot;NULL&quot;
        end
         
        retvalue
      end # def

      # Quotes a string, escaping any ' (single quote) characters.
      def quote_string(s)
        s.gsub(/'/, &quot;''&quot;) # ' (for ruby-mode)
      end

      def quote_column_name(name) #:nodoc:
        %( &quot;#{name}&quot; )
      end

      def quoted_true
        &quot;true&quot;
      end
      
      def quoted_false
        &quot;false&quot;
      end


      # CONNECTION MANAGEMENT ====================================

      def active?
        true if @connection.status == 1
      rescue =&gt; e
        false
      end

      def reconnect!
        @connection.close rescue nil
        @connection = FBSQL_Connect.connect(*@connection_options.first(7))
      end

      # Close this connection
      def disconnect!
        @connection.close rescue nil
        @active = false
      end

      # DATABASE STATEMENTS ======================================

      # Returns an array of record hashes with the column names as keys and
      # column values as values.
      def select_all(sql, name = nil) #:nodoc:
        fbsql        = cleanup_fb_sql(sql)
        return_value = []
        fbresult     = execute(sql, name)
        puts &quot;select_all SQL -&gt; #{fbsql}&quot; if FB_TRACE
        columns = fbresult.columns

        fbresult.each do |row|
          puts &quot;SQL &lt;- #{row.inspect}&quot;  if FB_TRACE
          hashed_row = {}    
          colnum     = 0
          row.each do |col|
            hashed_row[columns[colnum]] = col
            if col.kind_of?(FBSQL_LOB)
              hashed_row[columns[colnum]] = col.read
            end
            colnum += 1
          end
          puts &quot;raw row: #{hashed_row.inspect}&quot; if FB_TRACE
          return_value &lt;&lt; hashed_row
        end
        return_value
      end

      def select_one(sql, name = nil) #:nodoc:
        fbsql        = cleanup_fb_sql(sql)
        return_value = []
        fbresult     = execute(fbsql, name)
        puts &quot;SQL -&gt; #{fbsql}&quot;  if FB_TRACE
        columns = fbresult.columns
        
        fbresult.each do |row|
          puts &quot;SQL &lt;- #{row.inspect}&quot;  if FB_TRACE
          hashed_row = {}    
          colnum     = 0
          row.each do |col|
            hashed_row[columns[colnum]] = col
            if col.kind_of?(FBSQL_LOB)
              hashed_row[columns[colnum]] = col.read
            end
            colnum += 1
          end
          return_value &lt;&lt; hashed_row
          break
        end
        fbresult.clear
        return_value.first
      end

      def query(sql, name = nil) #:nodoc:
        fbsql = cleanup_fb_sql(sql)
        puts &quot;SQL(query) -&gt; #{fbsql}&quot;  if FB_TRACE
        log(fbsql, name) { @connection.query(fbsql) }
      rescue =&gt; e
        puts &quot;FB Exception: #{e.inspect}&quot; if FB_TRACE
        raise e
      end

      def execute(sql, name = nil) #:nodoc:
        fbsql = cleanup_fb_sql(sql)
        puts &quot;SQL(execute) -&gt; #{fbsql}&quot;  if FB_TRACE
        log(fbsql, name) { @connection.query(fbsql) }
      rescue ActiveRecord::StatementInvalid =&gt; e
        if e.message.scan(/Table name - \w* - exists/).empty?
          puts &quot;FB Exception: #{e.inspect}&quot; if FB_TRACE
          raise e
        end
      end
      
      # Returns the last auto-generated ID from the affected table.
      def insert(sql, name = nil, pk = nil, id_value = nil, sequence_name = nil) #:nodoc:
        puts &quot;SQL -&gt; #{sql.inspect}&quot;  if FB_TRACE
        execute(sql, name)
        id_value || pk
      end

      # Executes the update statement and returns the number of rows affected.
      def update(sql, name = nil) #:nodoc:
        puts &quot;SQL -&gt; #{sql.inspect}&quot;  if FB_TRACE
        execute(sql, name).num_rows
      end

      alias_method :delete, :update #:nodoc:

      def set_pessimistic_transactions
        if @transaction_mode == :optimistic
          execute &quot;SET TRANSACTION ISOLATION LEVEL SERIALIZABLE, LOCKING PESSIMISTIC, READ WRITE&quot;
          @transaction_mode = :pessimistic
        end
      end

      def set_optimistic_transactions
        if @transaction_mode == :pessimistic
          execute &quot;SET TRANSACTION ISOLATION LEVEL REPEATABLE READ, READ WRITE, LOCKING OPTIMISTIC&quot;
          @transaction_mode = :optimistic
        end
      end

      def begin_db_transaction #:nodoc:
        execute &quot;SET COMMIT FALSE&quot; rescue nil
      end

      def commit_db_transaction #:nodoc:
        execute &quot;COMMIT&quot;
      ensure
        execute &quot;SET COMMIT TRUE&quot;
      end

      def rollback_db_transaction #:nodoc:
        execute &quot;ROLLBACK&quot;
      ensure
        execute &quot;SET COMMIT TRUE&quot;
      end

      def add_limit_offset!(sql, options) #:nodoc:
        if limit = options[:limit]
          offset = options[:offset] || 0
        
# Here is the full syntax FrontBase supports:
# (from gclem@frontbase.com)
# 
#       TOP &lt;limit - unsigned integer&gt;
#       TOP ( &lt;offset expr&gt;, &lt;limit expr&gt;)
        
          # &quot;TOP 0&quot; is not allowed, so we have
          # to use a cheap trick.
          if limit.zero?
            case sql
            when /WHERE/i
              sql.sub!(/WHERE/i, 'WHERE 0 = 1 AND ')
            when /ORDER\s+BY/i
              sql.sub!(/ORDER\s+BY/i, 'WHERE 0 = 1 ORDER BY')
            else
              sql &lt;&lt; 'WHERE 0 = 1'
            end
          else
            if offset.zero?
              sql.replace sql.gsub(&quot;SELECT &quot;,&quot;SELECT TOP #{limit} &quot;)
            else
              sql.replace sql.gsub(&quot;SELECT &quot;,&quot;SELECT TOP(#{offset},#{limit}) &quot;)
            end
          end
        end
      end

      def prefetch_primary_key?(table_name = nil)
        true
      end

      # Returns the next sequence value from a sequence generator. Not generally
      # called directly; used by ActiveRecord to get the next primary key value
      # when inserting a new database record (see #prefetch_primary_key?).
      def next_sequence_value(sequence_name)
        unique = select_value(&quot;SELECT UNIQUE FROM #{sequence_name}&quot;,&quot;Next Sequence Value&quot;)
        # The test cases cannot handle a zero primary key
        unique.zero? ? select_value(&quot;SELECT UNIQUE FROM #{sequence_name}&quot;,&quot;Next Sequence Value&quot;) : unique
      end

      def default_sequence_name(table, column)
        table
      end

      # Set the sequence to the max value of the table's column.
      def reset_sequence!(table, column, sequence = nil)
        klasses = classes_for_table_name(table)
        klass   = klasses.nil? ? nil : klasses.first
        pk      = klass.primary_key unless klass.nil?
        if pk &amp;&amp; klass.columns_hash[pk].type == :integer
          execute(&quot;SET UNIQUE FOR #{klass.table_name}(#{pk})&quot;)
        end
      end

      def classes_for_table_name(table)
        ActiveRecord::Base.send(:subclasses).select {|klass| klass.table_name == table}
      end
      
      def reset_pk_sequence!(table, pk = nil, sequence = nil)
        klasses = classes_for_table_name(table)
        klass   = klasses.nil? ? nil : klasses.first
        pk      = klass.primary_key unless klass.nil?
        if pk &amp;&amp; klass.columns_hash[pk].type == :integer
          mpk = select_value(&quot;SELECT MAX(#{pk}) FROM #{table}&quot;)
          execute(&quot;SET UNIQUE FOR #{klass.table_name}(#{pk})&quot;)
        end
      end

      # SCHEMA STATEMENTS ========================================

      def structure_dump #:nodoc:
        select_all(&quot;SHOW TABLES&quot;).inject('') do |structure, table|
          structure &lt;&lt; select_one(&quot;SHOW CREATE TABLE #{table.to_a.first.last}&quot;)[&quot;Create Table&quot;] &lt;&lt; &quot;;\n\n&quot;
        end
      end

      def recreate_database(name) #:nodoc:
        drop_database(name)
        create_database(name)
      end

      def create_database(name) #:nodoc:
        execute &quot;CREATE DATABASE #{name}&quot;
      end
      
      def drop_database(name) #:nodoc:
        execute &quot;DROP DATABASE #{name}&quot;
      end

      def current_database
        select_value('SELECT &quot;CATALOG_NAME&quot; FROM INFORMATION_SCHEMA.CATALOGS').downcase
      end

      def tables(name = nil) #:nodoc:
        select_values(&lt;&lt;-SQL, nil)
          SELECT &quot;TABLE_NAME&quot; 
          FROM   INFORMATION_SCHEMA.TABLES   AS T0,
                 INFORMATION_SCHEMA.SCHEMATA AS T1 
          WHERE  T0.SCHEMA_PK  = T1.SCHEMA_PK 
          AND    &quot;SCHEMA_NAME&quot; = CURRENT_SCHEMA
        SQL
      end

      def indexes(table_name, name = nil)#:nodoc:
        indexes = []
        current_index = nil
        sql = &lt;&lt;-SQL
          SELECT   INDEX_NAME, T2.ORDINAL_POSITION, INDEX_COLUMN_COUNT, INDEX_TYPE, 
                   &quot;COLUMN_NAME&quot;, IS_NULLABLE 
          FROM     INFORMATION_SCHEMA.TABLES             AS T0, 
                   INFORMATION_SCHEMA.INDEXES            AS T1, 
                   INFORMATION_SCHEMA.INDEX_COLUMN_USAGE AS T2, 
                   INFORMATION_SCHEMA.COLUMNS            AS T3 
          WHERE    T0.&quot;TABLE_NAME&quot; = '#{table_name}' 
            AND    INDEX_TYPE &lt;&gt; 0 
            AND    T0.TABLE_PK   = T1.TABLE_PK 
            AND    T0.TABLE_PK   = T2.TABLE_PK 
            AND    T0.TABLE_PK   = T3.TABLE_PK 
            AND    T1.INDEXES_PK = T2.INDEX_PK 
            AND    T2.COLUMN_PK  = T3.COLUMN_PK 
          ORDER BY INDEX_NAME, T2.ORDINAL_POSITION
        SQL

        columns = []
        query(sql).each do |row|
          index_name   = row[0]
          ord_position = row[1]
          ndx_colcount = row[2]
          index_type   = row[3]
          column_name  = row[4]
          
          is_unique = index_type == 1
          
          columns &lt;&lt; column_name
          if ord_position == ndx_colcount
            indexes &lt;&lt; IndexDefinition.new(table_name, index_name, is_unique , columns)
            columns = []
          end
        end
        indexes
      end

      def columns(table_name, name = nil)#:nodoc:
        sql = &lt;&lt;-SQL
          SELECT   &quot;TABLE_NAME&quot;, &quot;COLUMN_NAME&quot;, ORDINAL_POSITION, IS_NULLABLE, COLUMN_DEFAULT, 
                   DATA_TYPE, DATA_TYPE_CODE, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION, 
                   NUMERIC_PRECISION_RADIX, NUMERIC_SCALE, DATETIME_PRECISION, DATETIME_PRECISION_LEADING 
          FROM     INFORMATION_SCHEMA.TABLES               T0, 
                   INFORMATION_SCHEMA.COLUMNS              T1, 
                   INFORMATION_SCHEMA.DATA_TYPE_DESCRIPTOR T3 
          WHERE    &quot;TABLE_NAME&quot; = '#{table_name}' 
            AND    T0.TABLE_PK  = T1.TABLE_PK 
            AND    T0.TABLE_PK  = T3.TABLE_OR_DOMAIN_PK 
            AND    T1.COLUMN_PK = T3.COLUMN_NAME_PK 
          ORDER BY T1.ORDINAL_POSITION
        SQL

        rawresults = query(sql,name)
        columns = []
        rawresults.each do |field|
          args = [base       = field[0],
                  name       = field[1],
                  typecode   = field[6],
                  typestring = field[5],
                  limit      = field[7],
                  precision  = field[8],
                  scale      = field[9],
                  default    = field[4],
                  nullable   = field[3]]
          columns &lt;&lt; FrontBaseColumn.new(*args)
         end
        columns
      end
      
      def create_table(name, options = {})
        table_definition = TableDefinition.new(self)
        table_definition.primary_key(options[:primary_key] || &quot;id&quot;) unless options[:id] == false

        yield table_definition

        if options[:force]
          drop_table(name) rescue nil
        end

        create_sql = &quot;CREATE#{' TEMPORARY' if options[:temporary]} TABLE &quot;
        create_sql &lt;&lt; &quot;#{name} (&quot;
        create_sql &lt;&lt; table_definition.to_sql
        create_sql &lt;&lt; &quot;) #{options[:options]}&quot;
        begin_db_transaction
        execute create_sql
        commit_db_transaction
        rescue ActiveRecord::StatementInvalid =&gt; e
          raise e unless e.message.match(/Table name - \w* - exists/)
      end
      
      def rename_table(name, new_name)
        columns = columns(name)
        pkcol = columns.find {|c| c.fb_autogen}
        execute &quot;ALTER TABLE NAME #{name} TO #{new_name}&quot;
        if pkcol
          change_column_default(new_name,pkcol.name,&quot;UNIQUE&quot;)
          begin_db_transaction
          mpk = select_value(&quot;SELECT MAX(#{pkcol.name}) FROM #{new_name}&quot;)
          mpk = 0 if mpk.nil?
          execute &quot;SET UNIQUE=#{mpk} FOR #{new_name}&quot;
          commit_db_transaction
        end
      end  

      # Drops a table from the database.
      def drop_table(name, options = {})
        execute &quot;DROP TABLE #{name} RESTRICT&quot;
      rescue ActiveRecord::StatementInvalid =&gt; e
        raise e unless e.message.match(/Referenced TABLE - \w* - does not exist/)
      end

      # Adds a new column to the named table.
      # See TableDefinition#column for details of the options you can use.
      def add_column(table_name, column_name, type, options = {})
        add_column_sql = &quot;ALTER TABLE #{table_name} ADD #{column_name} #{type_to_sql(type, options[:limit])}&quot;
        options[:type] = type
        add_column_options!(add_column_sql, options)
        execute(add_column_sql)
      end

      def add_column_options!(sql, options) #:nodoc:
        default_value = quote(options[:default], options[:column])
        if options_include_default?(options)
          if options[:type] == :boolean
            default_value = options[:default] == 0 ? quoted_false : quoted_true
          end
          sql &lt;&lt; &quot; DEFAULT #{default_value}&quot;
        end
        sql &lt;&lt; &quot; NOT NULL&quot; if options[:null] == false
      end

      # Removes the column from the table definition.
      # ===== Examples
      #  remove_column(:suppliers, :qualification)
      def remove_column(table_name, column_name)
        execute &quot;ALTER TABLE #{table_name} DROP #{column_name} RESTRICT&quot;
      end

      def remove_index(table_name, options = {}) #:nodoc:
        if options[:unique]
          execute &quot;ALTER TABLE #{table_name} DROP CONSTRAINT #{quote_column_name(index_name(table_name, options))} RESTRICT&quot;
        else
          execute &quot;DROP INDEX #{quote_column_name(index_name(table_name, options))}&quot;
        end
      end

      def change_column_default(table_name, column_name, default) #:nodoc:
        execute &quot;ALTER TABLE #{table_name} ALTER COLUMN #{column_name} SET DEFAULT #{default}&quot; if default != &quot;NULL&quot;
      end

      def change_column(table_name, column_name, type, options = {}) #:nodoc:
        change_column_sql = %( ALTER COLUMN &quot;#{table_name}&quot;.&quot;#{column_name}&quot; TO #{type_to_sql(type, options[:limit])} )
        execute(change_column_sql)
        change_column_sql = %( ALTER TABLE &quot;#{table_name}&quot; ALTER COLUMN &quot;#{column_name}&quot; )

        if options_include_default?(options)
          default_value = quote(options[:default], options[:column])
          if type == :boolean
            default_value = options[:default] == 0 ? quoted_false : quoted_true
          end
          change_column_sql &lt;&lt; &quot; SET DEFAULT #{default_value}&quot;
        end

        execute(change_column_sql)
        
#         change_column_sql = &quot;ALTER TABLE #{table_name} CHANGE #{column_name} #{column_name} #{type_to_sql(type, options[:limit])}&quot;
#         add_column_options!(change_column_sql, options)
#         execute(change_column_sql)
      end

      def rename_column(table_name, column_name, new_column_name) #:nodoc:
        execute %( ALTER COLUMN NAME &quot;#{table_name}&quot;.&quot;#{column_name}&quot; TO &quot;#{new_column_name}&quot; )
      end
            
      private
      
        # Clean up sql to make it something FrontBase can digest
        def cleanup_fb_sql(sql) #:nodoc:
          # Turn non-standard != into standard &lt;&gt;
          cleansql = sql.gsub(&quot;!=&quot;, &quot;&lt;&gt;&quot;) 
          # Strip blank lines and comments
          cleansql.split(&quot;\n&quot;).reject { |line| line.match(/^(?:\s*|--.*)$/) } * &quot;\n&quot;
        end
    end
  end
end
</pre>
    </div>