  <div id="fileHeader">
    <h1>openbase_adapter.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activerecord/lib/active_record/connection_adapters/openbase_adapter.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Thu Jan 18 08:52:47 -0800 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'active_record/connection_adapters/abstract_adapter'

module ActiveRecord
  class Base
    # Establishes a connection to the database that's used by all Active Record objects
    def self.openbase_connection(config) # :nodoc:
      require_library_or_gem 'openbase' unless self.class.const_defined?(:OpenBase)

      config = config.symbolize_keys
      host     = config[:host]
      username = config[:username].to_s
      password = config[:password].to_s
      

      if config.has_key?(:database)
        database = config[:database]
      else
        raise ArgumentError, &quot;No database specified. Missing argument: database.&quot;
      end

      oba = ConnectionAdapters::OpenBaseAdapter.new(
        OpenBase.new(database, host, username, password), logger
      )
      
      oba
    end
    
  end

  module ConnectionAdapters
    class OpenBaseColumn &lt; Column #:nodoc:
      private
        def simplified_type(field_type)
          return :integer if field_type.downcase =~ /long/
          return :decimal if field_type.downcase == &quot;money&quot;
          return :binary  if field_type.downcase == &quot;object&quot;
          super
        end
    end
    # The OpenBase adapter works with the Ruby/Openbase driver by Tetsuya Suzuki.
    # http://www.spice-of-life.net/ruby-openbase/ (needs version 0.7.3+)
    #
    # Options:
    #
    # * &lt;tt&gt;:host&lt;/tt&gt; -- Defaults to localhost
    # * &lt;tt&gt;:username&lt;/tt&gt; -- Defaults to nothing
    # * &lt;tt&gt;:password&lt;/tt&gt; -- Defaults to nothing
    # * &lt;tt&gt;:database&lt;/tt&gt; -- The name of the database. No default, must be provided.
    #
    # The OpenBase adapter will make use of OpenBase's ability to generate unique ids
    # for any column with an unique index applied.  Thus, if the value of a primary
    # key is not specified at the time an INSERT is performed, the adapter will prefetch
    # a unique id for the primary key.  This prefetching is also necessary in order 
    # to return the id after an insert.
    #
    # Caveat: Operations involving LIMIT and OFFSET do not yet work!
    #
    # Maintainer: derrick.spell@gmail.com
    class OpenBaseAdapter &lt; AbstractAdapter
      def adapter_name
        'OpenBase'
      end
      
      def native_database_types
        {
          :primary_key =&gt; &quot;integer UNIQUE INDEX DEFAULT _rowid&quot;,
          :string      =&gt; { :name =&gt; &quot;char&quot;, :limit =&gt; 4096 },
          :text        =&gt; { :name =&gt; &quot;text&quot; },
          :integer     =&gt; { :name =&gt; &quot;integer&quot; },
          :float       =&gt; { :name =&gt; &quot;float&quot; },
          :decimal     =&gt; { :name =&gt; &quot;decimal&quot; },
          :datetime    =&gt; { :name =&gt; &quot;datetime&quot; },
          :timestamp   =&gt; { :name =&gt; &quot;timestamp&quot; },
          :time        =&gt; { :name =&gt; &quot;time&quot; },
          :date        =&gt; { :name =&gt; &quot;date&quot; },
          :binary      =&gt; { :name =&gt; &quot;object&quot; },
          :boolean     =&gt; { :name =&gt; &quot;boolean&quot; }
        }
      end
      
      def supports_migrations?
        false
      end      
      
      def prefetch_primary_key?(table_name = nil)
        true
      end
      
      def default_sequence_name(table_name, primary_key) # :nodoc:
        &quot;#{table_name} #{primary_key}&quot;
      end
      
      def next_sequence_value(sequence_name)
        ary = sequence_name.split(' ')
        if (!ary[1]) then
          ary[0] =~ /(\w+)_nonstd_seq/
          ary[0] = $1
        end
        @connection.unique_row_id(ary[0], ary[1])
      end

      
      # QUOTING ==================================================
      
      def quote(value, column = nil)
        if value.kind_of?(String) &amp;&amp; column &amp;&amp; column.type == :binary
          &quot;'#{@connection.insert_binary(value)}'&quot;
        else
          super
        end
      end
      
      def quoted_true
        &quot;1&quot;
      end
      
      def quoted_false
        &quot;0&quot;
      end
      


      # DATABASE STATEMENTS ======================================

      def add_limit_offset!(sql, options) #:nodoc:
        if limit = options[:limit]
          unless offset = options[:offset]
            sql &lt;&lt; &quot; RETURN RESULTS #{limit}&quot;
          else
            limit = limit + offset
            sql &lt;&lt; &quot; RETURN RESULTS #{offset} TO #{limit}&quot;
          end
        end
      end
      
      def select_all(sql, name = nil) #:nodoc:
        select(sql, name)
      end

      def select_one(sql, name = nil) #:nodoc:
        add_limit_offset!(sql,{:limit =&gt; 1})
        results = select(sql, name)
        results.first if results
      end

      def insert(sql, name = nil, pk = nil, id_value = nil, sequence_name = nil) #:nodoc:
        execute(sql, name)
        update_nulls_after_insert(sql, name, pk, id_value, sequence_name)
        id_value
      end
      
      def execute(sql, name = nil) #:nodoc:
        log(sql, name) { @connection.execute(sql) }
      end

      def update(sql, name = nil) #:nodoc:
        execute(sql, name).rows_affected
      end

      alias_method :delete, :update #:nodoc:
#=begin
      def begin_db_transaction #:nodoc:
        execute &quot;START TRANSACTION&quot;
      rescue Exception
        # Transactions aren't supported
      end

      def commit_db_transaction #:nodoc:
        execute &quot;COMMIT&quot;
      rescue Exception
        # Transactions aren't supported
      end

      def rollback_db_transaction #:nodoc:
        execute &quot;ROLLBACK&quot;
      rescue Exception
        # Transactions aren't supported
      end
#=end      

      # SCHEMA STATEMENTS ========================================

      # Return the list of all tables in the schema search path.
      def tables(name = nil) #:nodoc:
        tables = @connection.tables
        tables.reject! { |t| /\A_SYS_/ === t }
        tables
      end

      def columns(table_name, name = nil) #:nodoc:
        sql = &quot;SELECT * FROM _sys_tables &quot;
        sql &lt;&lt; &quot;WHERE tablename='#{table_name}' AND INDEXOF(fieldname,'_')&lt;&gt;0 &quot;
        sql &lt;&lt; &quot;ORDER BY columnNumber&quot;
        columns = []
        select_all(sql, name).each do |row|
          columns &lt;&lt; OpenBaseColumn.new(row[&quot;fieldname&quot;],
                                default_value(row[&quot;defaultvalue&quot;]),
                                sql_type_name(row[&quot;typename&quot;],row[&quot;length&quot;]),
                                row[&quot;notnull&quot;]
                                )
    #      breakpoint() if row[&quot;fieldname&quot;] == &quot;content&quot;
        end
        columns
      end

      def indexes(table_name, name = nil)#:nodoc:
        sql = &quot;SELECT fieldname, notnull, searchindex, uniqueindex, clusteredindex FROM _sys_tables &quot;
        sql &lt;&lt; &quot;WHERE tablename='#{table_name}' AND INDEXOF(fieldname,'_')&lt;&gt;0 &quot;
        sql &lt;&lt; &quot;AND primarykey=0 &quot;
        sql &lt;&lt; &quot;AND (searchindex=1 OR uniqueindex=1 OR clusteredindex=1) &quot;
        sql &lt;&lt; &quot;ORDER BY columnNumber&quot;
        indexes = []
        execute(sql, name).each do |row|
          indexes &lt;&lt; IndexDefinition.new(table_name,index_name(row),row[3]==1,[row[0]])
        end
        indexes
      end


      private
        def select(sql, name = nil)
          sql = translate_sql(sql)
          results = execute(sql, name)

          date_cols = []
          col_names = []
          results.column_infos.each do |info|
            col_names &lt;&lt; info.name
            date_cols &lt;&lt; info.name if info.type == &quot;date&quot;
          end
          
          rows = []
          if ( results.rows_affected )
            results.each do |row|  # loop through result rows
              hashed_row = {}
              row.each_index do |index| 
                hashed_row[&quot;#{col_names[index]}&quot;] = row[index] unless col_names[index] == &quot;_rowid&quot;
              end
              date_cols.each do |name|
                unless hashed_row[&quot;#{name}&quot;].nil? or hashed_row[&quot;#{name}&quot;].empty?
                  hashed_row[&quot;#{name}&quot;] = Date.parse(hashed_row[&quot;#{name}&quot;],false).to_s
                end
              end
              rows &lt;&lt; hashed_row
            end
          end
          rows
        end
        
        def default_value(value)
          # Boolean type values
          return true if value =~ /true/
          return false if value =~ /false/
 
          # Date / Time magic values
          return Time.now.to_s if value =~ /^now\(\)/i
 
          # Empty strings should be set to null
          return nil if value.empty?
          
          # Otherwise return what we got from OpenBase
          # and hope for the best...
          return value
        end 
        
        def sql_type_name(type_name, length)
          return &quot;#{type_name}(#{length})&quot; if ( type_name =~ /char/ )
          type_name
        end
                
        def index_name(row = [])
          name = &quot;&quot;
          name &lt;&lt; &quot;UNIQUE &quot; if row[3]
          name &lt;&lt; &quot;CLUSTERED &quot; if row[4]
          name &lt;&lt; &quot;INDEX&quot;
          name
        end
        
        def translate_sql(sql)
          
          # Change table.* to list of columns in table
          while (sql =~ /SELECT.*\s(\w+)\.\*/)
            table = $1
            cols = columns(table)
            if ( cols.size == 0 ) then
              # Maybe this is a table alias
              sql =~ /FROM(.+?)(?:LEFT|OUTER|JOIN|WHERE|GROUP|HAVING|ORDER|RETURN|$)/  
              $1 =~ /[\s|,](\w+)\s+#{table}[\s|,]/ # get the tablename for this alias
              cols = columns($1)
            end
            select_columns = []
            cols.each do |col|
              select_columns &lt;&lt; table + '.' + col.name
            end
            sql.gsub!(table + '.*',select_columns.join(&quot;, &quot;)) if select_columns
          end
   
          # Change JOIN clause to table list and WHERE condition
          while (sql =~ /JOIN/)
            sql =~ /((LEFT )?(OUTER )?JOIN (\w+) ON )(.+?)(?:LEFT|OUTER|JOIN|WHERE|GROUP|HAVING|ORDER|RETURN|$)/
            join_clause = $1 + $5
            is_outer_join = $3
            join_table = $4
            join_condition = $5
            join_condition.gsub!(/=/,&quot;*&quot;) if is_outer_join
            if (sql =~ /WHERE/)
              sql.gsub!(/WHERE/,&quot;WHERE (#{join_condition}) AND&quot;)
            else
              sql.gsub!(join_clause,&quot;#{join_clause} WHERE #{join_condition}&quot;)
            end
            sql =~ /(FROM .+?)(?:LEFT|OUTER|JOIN|WHERE|$)/
            from_clause = $1
            sql.gsub!(from_clause,&quot;#{from_clause}, #{join_table} &quot;)
            sql.gsub!(join_clause,&quot;&quot;)
          end
    
          # ORDER BY _rowid if no explicit ORDER BY
          # This will ensure that find(:first) returns the first inserted row
          if (sql !~ /(ORDER BY)|(GROUP BY)/)
            if (sql =~ /RETURN RESULTS/)
              sql.sub!(/RETURN RESULTS/,&quot;ORDER BY _rowid RETURN RESULTS&quot;)
            else
              sql &lt;&lt; &quot; ORDER BY _rowid&quot;
            end
          end
          
          sql
        end
        
        def update_nulls_after_insert(sql, name = nil, pk = nil, id_value = nil, sequence_name = nil)
          sql =~ /INSERT INTO (\w+) \((.*)\) VALUES\s*\((.*)\)/m
          table = $1
          cols = $2
          values = $3
          cols = cols.split(',')
          values.gsub!(/'[^']*'/,&quot;''&quot;)
          values.gsub!(/&quot;[^&quot;]*&quot;/,&quot;\&quot;\&quot;&quot;)
          values = values.split(',')
          update_cols = []
          values.each_index { |index| update_cols &lt;&lt; cols[index] if values[index] =~ /\s*NULL\s*/ }
          update_sql = &quot;UPDATE #{table} SET&quot;
          update_cols.each { |col| update_sql &lt;&lt; &quot; #{col}=NULL,&quot; unless col.empty? }
          update_sql.chop!()
          update_sql &lt;&lt; &quot; WHERE #{pk}=#{quote(id_value)}&quot;
          execute(update_sql, name + &quot; NULL Correction&quot;) if update_cols.size &gt; 0
        end
        
      end
  end
end
</pre>
    </div>