  <div id="fileHeader">
    <h1>xml_serialization.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activerecord/lib/active_record/xml_serialization.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Fri Sep 29 15:45:58 -0700 2006</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>module ActiveRecord #:nodoc:
  module XmlSerialization
    # Builds an XML document to represent the model.   Some configuration is
    # availble through +options+, however more complicated cases should use 
    # override ActiveRecord's to_xml.
    #
    # By default the generated XML document will include the processing 
    # instruction and all object's attributes.  For example:
    #    
    #   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    #   &lt;topic&gt;
    #     &lt;title&gt;The First Topic&lt;/title&gt;
    #     &lt;author-name&gt;David&lt;/author-name&gt;
    #     &lt;id type=&quot;integer&quot;&gt;1&lt;/id&gt;
    #     &lt;approved type=&quot;boolean&quot;&gt;false&lt;/approved&gt;
    #     &lt;replies-count type=&quot;integer&quot;&gt;0&lt;/replies-count&gt;
    #     &lt;bonus-time type=&quot;datetime&quot;&gt;2000-01-01T08:28:00+12:00&lt;/bonus-time&gt;
    #     &lt;written-on type=&quot;datetime&quot;&gt;2003-07-16T09:28:00+1200&lt;/written-on&gt;
    #     &lt;content&gt;Have a nice day&lt;/content&gt;
    #     &lt;author-email-address&gt;david@loudthinking.com&lt;/author-email-address&gt;
    #     &lt;parent-id&gt;&lt;/parent-id&gt;
    #     &lt;last-read type=&quot;date&quot;&gt;2004-04-15&lt;/last-read&gt;
    #   &lt;/topic&gt;
    #
    # This behavior can be controlled with :only, :except,
    # :skip_instruct, :skip_types and :dasherize.  The :only and
    # :except options are the same as for the #attributes method.
    # The default is to dasherize all column names, to disable this,
    # set :dasherize to false.  To not have the column type included
    # in the XML output, set :skip_types to false.
    #
    # For instance:
    #
    #   topic.to_xml(:skip_instruct =&gt; true, :except =&gt; [ :id, :bonus_time, :written_on, :replies_count ])
    #
    #   &lt;topic&gt;
    #     &lt;title&gt;The First Topic&lt;/title&gt;
    #     &lt;author-name&gt;David&lt;/author-name&gt;
    #     &lt;approved type=&quot;boolean&quot;&gt;false&lt;/approved&gt;
    #     &lt;content&gt;Have a nice day&lt;/content&gt;
    #     &lt;author-email-address&gt;david@loudthinking.com&lt;/author-email-address&gt;
    #     &lt;parent-id&gt;&lt;/parent-id&gt;
    #     &lt;last-read type=&quot;date&quot;&gt;2004-04-15&lt;/last-read&gt;
    #   &lt;/topic&gt;
    # 
    # To include first level associations use :include
    #
    #   firm.to_xml :include =&gt; [ :account, :clients ]
    #
    #   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    #   &lt;firm&gt;
    #     &lt;id type=&quot;integer&quot;&gt;1&lt;/id&gt;
    #     &lt;rating type=&quot;integer&quot;&gt;1&lt;/rating&gt;
    #     &lt;name&gt;37signals&lt;/name&gt;
    #     &lt;clients&gt;
    #       &lt;client&gt;
    #         &lt;rating type=&quot;integer&quot;&gt;1&lt;/rating&gt;
    #         &lt;name&gt;Summit&lt;/name&gt;
    #       &lt;/client&gt;
    #       &lt;client&gt;
    #         &lt;rating type=&quot;integer&quot;&gt;1&lt;/rating&gt;
    #         &lt;name&gt;Microsoft&lt;/name&gt;
    #       &lt;/client&gt;
    #     &lt;/clients&gt;
    #     &lt;account&gt;
    #       &lt;id type=&quot;integer&quot;&gt;1&lt;/id&gt;
    #       &lt;credit-limit type=&quot;integer&quot;&gt;50&lt;/credit-limit&gt;
    #     &lt;/account&gt;
    #   &lt;/firm&gt;
    #
    # To include any methods on the object(s) being called use :methods
    #
    #   firm.to_xml :methods =&gt; [ :calculated_earnings, :real_earnings ]
    #
    #   &lt;firm&gt;
    #     # ... normal attributes as shown above ...
    #     &lt;calculated-earnings&gt;100000000000000000&lt;/calculated-earnings&gt;
    #     &lt;real-earnings&gt;5&lt;/real-earnings&gt;
    #   &lt;/firm&gt;
    #
    # To call any Proc's on the object(s) use :procs.  The Proc's
    # are passed a modified version of the options hash that was
    # given to #to_xml.
    #
    #   proc = Proc.new { |options| options[:builder].tag!('abc', 'def') }
    #   firm.to_xml :procs =&gt; [ proc ]
    #
    #   &lt;firm&gt;
    #     # ... normal attributes as shown above ...
    #     &lt;abc&gt;def&lt;/abc&gt;
    #   &lt;/firm&gt;
    #
    # You may override the to_xml method in your ActiveRecord::Base
    # subclasses if you need to.  The general form of doing this is
    #
    #   class IHaveMyOwnXML &lt; ActiveRecord::Base
    #     def to_xml(options = {})
    #       options[:indent] ||= 2
    #       xml = options[:builder] ||= Builder::XmlMarkup.new(:indent =&gt; options[:indent])
    #       xml.instruct! unless options[:skip_instruct]
    #       xml.level_one do
    #         xml.tag!(:second_level, 'content')
    #       end
    #     end
    #   end
    def to_xml(options = {})
      XmlSerializer.new(self, options).to_s
    end
  end

  class XmlSerializer #:nodoc:
    attr_reader :options
    
    def initialize(record, options = {})
      @record, @options = record, options.dup
    end
    
    def builder
      @builder ||= begin
        options[:indent] ||= 2
        builder = options[:builder] ||= Builder::XmlMarkup.new(:indent =&gt; options[:indent])

        unless options[:skip_instruct]
          builder.instruct!
          options[:skip_instruct] = true
        end
        
        builder
      end
    end

    def root
      root = (options[:root] || @record.class.to_s.underscore).to_s
      dasherize? ? root.dasherize : root
    end
    
    def dasherize?
      !options.has_key?(:dasherize) || options[:dasherize]
    end


    # To replicate the behavior in ActiveRecord#attributes,
    # :except takes precedence over :only.  If :only is not set
    # for a N level model but is set for the N+1 level models,
    # then because :except is set to a default value, the second
    # level model can have both :except and :only set.  So if
    # :only is set, always delete :except.
    def serializable_attributes
      attribute_names = @record.attribute_names

      if options[:only]
        options.delete(:except)
        attribute_names = attribute_names &amp; Array(options[:only]).collect { |n| n.to_s }
      else
        options[:except] = Array(options[:except]) | Array(@record.class.inheritance_column)
        attribute_names = attribute_names - options[:except].collect { |n| n.to_s }
      end
      
      attribute_names.collect { |name| Attribute.new(name, @record) }
    end

    def serializable_method_attributes
      Array(options[:methods]).collect { |name| MethodAttribute.new(name.to_s, @record) }
    end


    def add_attributes
      (serializable_attributes + serializable_method_attributes).each do |attribute|
        add_tag(attribute)
      end
    end

    def add_includes
      if include_associations = options.delete(:include)
        root_only_or_except = { :except =&gt; options[:except],
                                :only =&gt; options[:only] }

        include_has_options = include_associations.is_a?(Hash)

        for association in include_has_options ? include_associations.keys : Array(include_associations)
          association_options = include_has_options ? include_associations[association] : root_only_or_except

          opts = options.merge(association_options)

          case @record.class.reflect_on_association(association).macro
          when :has_many, :has_and_belongs_to_many
            records = @record.send(association).to_a
            unless records.empty?
              tag = records.first.class.to_s.underscore.pluralize
              tag = tag.dasherize if dasherize?

              builder.tag!(tag) do
                records.each { |r| r.to_xml(opts.merge(:root =&gt; association.to_s.singularize)) }
              end
            end
          when :has_one, :belongs_to
            if record = @record.send(association)
              record.to_xml(opts.merge(:root =&gt; association))
            end
          end
        end

        options[:include] = include_associations
      end
    end

    def add_procs
      if procs = options.delete(:procs)
        [ *procs ].each do |proc|
          proc.call(options)
        end
      end
    end


    def add_tag(attribute)
      builder.tag!(
        dasherize? ? attribute.name.dasherize : attribute.name, 
        attribute.value.to_s, 
        attribute.decorations(!options[:skip_types])
      )
    end

    def serialize
      args = [root]
      if options[:namespace]
        args &lt;&lt; {:xmlns=&gt;options[:namespace]}
      end
        
      builder.tag!(*args) do
        add_attributes
        add_includes
        add_procs
      end
    end        
    
    alias_method :to_s, :serialize

    class Attribute #:nodoc:
      attr_reader :name, :value, :type
    
      def initialize(name, record)
        @name, @record = name, record
      
        @type  = compute_type
        @value = compute_value
      end

      # There is a significant speed improvement if the value
      # does not need to be escaped, as #tag! escapes all values
      # to ensure that valid XML is generated.  For known binary
      # values, it is at least an order of magnitude faster to
      # Base64 encode binary values and directly put them in the
      # output XML than to pass the original value or the Base64
      # encoded value to the #tag! method. It definitely makes
      # no sense to Base64 encode the value and then give it to
      # #tag!, since that just adds additional overhead.
      def needs_encoding?
        ![ :binary, :date, :datetime, :boolean, :float, :integer ].include?(type)
      end
    
      def decorations(include_types = true)
        decorations = {}

        if type == :binary
          decorations[:encoding] = 'base64'
        end
      
        if include_types &amp;&amp; type != :string
          decorations[:type] = type
        end
      
        decorations
      end
    
      protected
        def compute_type
          type = @record.class.columns_hash[name].type

          case type
            when :text
              :string
            when :time
              :datetime
            else
              type
          end
        end
    
        def compute_value
          value = @record.send(name)
        
          if formatter = Hash::XML_FORMATTING[type.to_s]
            value ? formatter.call(value) : nil
          else
            value
          end
        end
    end

    class MethodAttribute &lt; Attribute #:nodoc:
      protected
        def compute_type
          Hash::XML_TYPE_NAMES[@record.send(name).class.name] || :string
        end
    end
  end
end
</pre>
    </div>