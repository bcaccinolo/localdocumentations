  <div id="fileHeader">
    <h1>has_many_association.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activerecord/lib/active_record/associations/has_many_association.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Wed Aug 15 21:58:45 -0700 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>module ActiveRecord
  module Associations
    class HasManyAssociation &lt; AssociationCollection #:nodoc:
      def initialize(owner, reflection)
        super
        construct_sql
      end

      def build(attributes = {})
        if attributes.is_a?(Array)
          attributes.collect { |attr| build(attr) }
        else
          record = @reflection.klass.new(attributes)
          set_belongs_to_association_for(record)
          
          @target ||= [] unless loaded?
          @target &lt;&lt; record
          
          record
        end
      end

      # DEPRECATED.
      def find_all(runtime_conditions = nil, orderings = nil, limit = nil, joins = nil)
        if @reflection.options[:finder_sql]
          @reflection.klass.find_by_sql(@finder_sql)
        else
          conditions = @finder_sql
          conditions += &quot; AND (#{sanitize_sql(runtime_conditions)})&quot; if runtime_conditions
          orderings ||= @reflection.options[:order]
          @reflection.klass.find_all(conditions, orderings, limit, joins)
        end
      end
      deprecate :find_all =&gt; &quot;use find(:all, ...) instead&quot;

      # DEPRECATED. Find the first associated record.  All arguments are optional.
      def find_first(conditions = nil, orderings = nil)
        find_all(conditions, orderings, 1).first
      end
      deprecate :find_first =&gt; &quot;use find(:first, ...) instead&quot;

      # Count the number of associated records. All arguments are optional.
      def count(*args)
        if @reflection.options[:counter_sql]
          @reflection.klass.count_by_sql(@counter_sql)
        elsif @reflection.options[:finder_sql]
          @reflection.klass.count_by_sql(@finder_sql)
        else
          column_name, options = @reflection.klass.send(:construct_count_options_from_legacy_args, *args)          
          options[:conditions] = options[:conditions].nil? ?
            @finder_sql :
            @finder_sql + &quot; AND (#{sanitize_sql(options[:conditions])})&quot;
          options[:include] ||= @reflection.options[:include]

          @reflection.klass.count(column_name, options)
        end
      end

      def find(*args)
        options = Base.send(:extract_options_from_args!, args)

        # If using a custom finder_sql, scan the entire collection.
        if @reflection.options[:finder_sql]
          expects_array = args.first.kind_of?(Array)
          ids = args.flatten.compact.uniq

          if ids.size == 1
            id = ids.first
            record = load_target.detect { |record| id == record.id }
            expects_array ? [ record ] : record
          else
            load_target.select { |record| ids.include?(record.id) }
          end
        else
          conditions = &quot;#{@finder_sql}&quot;
          if sanitized_conditions = sanitize_sql(options[:conditions])
            conditions &lt;&lt; &quot; AND (#{sanitized_conditions})&quot;
          end
          options[:conditions] = conditions

          if options[:order] &amp;&amp; @reflection.options[:order]
            options[:order] = &quot;#{options[:order]}, #{@reflection.options[:order]}&quot;
          elsif @reflection.options[:order]
            options[:order] = @reflection.options[:order]
          end

          merge_options_from_reflection!(options)

          # Pass through args exactly as we received them.
          args &lt;&lt; options
          @reflection.klass.find(*args)
        end
      end

      protected
        def method_missing(method, *args, &amp;block)
          if @target.respond_to?(method) || (!@reflection.klass.respond_to?(method) &amp;&amp; Class.respond_to?(method))
            super
          else
            create_scoping = {}
            set_belongs_to_association_for(create_scoping)

            @reflection.klass.with_scope(
              :create =&gt; create_scoping,
              :find =&gt; {
                :conditions =&gt; @finder_sql, 
                :joins      =&gt; @join_sql, 
                :readonly   =&gt; false
              }
            ) do
              @reflection.klass.send(method, *args, &amp;block)
            end
          end
        end

        def load_target
          if !@owner.new_record? || foreign_key_present
            begin
              if !loaded?
                if @target.is_a?(Array) &amp;&amp; @target.any?
                  @target = (find_target + @target).uniq
                else
                  @target = find_target
                end
              end
            rescue ActiveRecord::RecordNotFound
              reset
            end
          end

          loaded if target
          target
        end

        def count_records
          count = if has_cached_counter?
            @owner.send(:read_attribute, cached_counter_attribute_name)
          elsif @reflection.options[:counter_sql]
            @reflection.klass.count_by_sql(@counter_sql)
          else
            @reflection.klass.count(:conditions =&gt; @counter_sql, :include =&gt; @reflection.options[:include])
          end
          
          @target = [] and loaded if count == 0
          
          if @reflection.options[:limit]
            count = [ @reflection.options[:limit], count ].min
          end
          
          return count
        end

        def has_cached_counter?
          @owner.attribute_present?(cached_counter_attribute_name)
        end

        def cached_counter_attribute_name
          &quot;#{@reflection.name}_count&quot;
        end

        def insert_record(record)
          set_belongs_to_association_for(record)
          record.save
        end

        def delete_records(records)
          if @reflection.options[:dependent]
            records.each { |r| r.destroy }
          else
            ids = quoted_record_ids(records)
            @reflection.klass.update_all(
              &quot;#{@reflection.primary_key_name} = NULL&quot;, 
              &quot;#{@reflection.primary_key_name} = #{@owner.quoted_id} AND #{@reflection.klass.primary_key} IN (#{ids})&quot;
            )
          end
        end

        def target_obsolete?
          false
        end

        def construct_sql
          case
            when @reflection.options[:finder_sql]
              @finder_sql = interpolate_sql(@reflection.options[:finder_sql])

            when @reflection.options[:as]
              @finder_sql = 
                &quot;#{@reflection.klass.table_name}.#{@reflection.options[:as]}_id = #{@owner.quoted_id} AND &quot; + 
                &quot;#{@reflection.klass.table_name}.#{@reflection.options[:as]}_type = #{@owner.class.quote_value(@owner.class.base_class.name.to_s)}&quot;
              @finder_sql &lt;&lt; &quot; AND (#{conditions})&quot; if conditions
            
            else
              @finder_sql = &quot;#{@reflection.klass.table_name}.#{@reflection.primary_key_name} = #{@owner.quoted_id}&quot;
              @finder_sql &lt;&lt; &quot; AND (#{conditions})&quot; if conditions
          end

          if @reflection.options[:counter_sql]
            @counter_sql = interpolate_sql(@reflection.options[:counter_sql])
          elsif @reflection.options[:finder_sql]
            # replace the SELECT clause with COUNT(*), preserving any hints within /* ... */
            @reflection.options[:counter_sql] = @reflection.options[:finder_sql].sub(/SELECT (\/\*.*?\*\/ )?(.*)\bFROM\b/im) { &quot;SELECT #{$1}COUNT(*) FROM&quot; }
            @counter_sql = interpolate_sql(@reflection.options[:counter_sql])
          else
            @counter_sql = @finder_sql
          end
        end
    end
  end
end
</pre>
    </div>