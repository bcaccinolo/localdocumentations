  <div id="fileHeader">
    <h1>conversions.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activesupport/lib/active_support/core_ext/array/conversions.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Dec 03 08:47:53 -0800 2006</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>module ActiveSupport #:nodoc:
  module CoreExtensions #:nodoc:
    module Array #:nodoc:
      module Conversions
        # Converts the array to comma-seperated sentence where the last element is joined by the connector word. Options:
        # * &lt;tt&gt;:connector&lt;/tt&gt;: The word used to join the last element in arrays with two or more elements (default: &quot;and&quot;)
        # * &lt;tt&gt;:skip_last_comma&lt;/tt&gt;: Set to true to return &quot;a, b and c&quot; instead of &quot;a, b, and c&quot;.
        def to_sentence(options = {})
          options.assert_valid_keys(:connector, :skip_last_comma)
          options.reverse_merge! :connector =&gt; 'and', :skip_last_comma =&gt; false
          
          case length
          	when 0
          		&quot;&quot;
            when 1
              self[0]
            when 2
              &quot;#{self[0]} #{options[:connector]} #{self[1]}&quot;
            else
              &quot;#{self[0...-1].join(', ')}#{options[:skip_last_comma] ? '' : ','} #{options[:connector]} #{self[-1]}&quot;
          end
        end

        # When an array is given to url_for, it is converted to a slash separated string.
        def to_param
          join '/'
        end
        
        def self.included(klass) #:nodoc:
          klass.send(:alias_method, :to_default_s, :to_s)
          klass.send(:alias_method, :to_s, :to_formatted_s)
        end
        
        def to_formatted_s(format = :default)
          case format
            when :db
              if respond_to?(:empty?) &amp;&amp; self.empty?
                &quot;null&quot;
              else
                collect { |element| element.id }.join(&quot;,&quot;)
              end
            else
              to_default_s
          end
        end
        
        def to_xml(options = {})
          raise &quot;Not all elements respond to to_xml&quot; unless all? { |e| e.respond_to? :to_xml }

          options[:root]     ||= all? { |e| e.is_a?(first.class) &amp;&amp; first.class.to_s != &quot;Hash&quot; } ? first.class.to_s.underscore.pluralize : &quot;records&quot;
          options[:children] ||= options[:root].singularize
          options[:indent]   ||= 2
          options[:builder]  ||= Builder::XmlMarkup.new(:indent =&gt; options[:indent])

          root     = options.delete(:root).to_s
          children = options.delete(:children)

          if !options.has_key?(:dasherize) || options[:dasherize]
            root = root.dasherize
          end

          options[:builder].instruct! unless options.delete(:skip_instruct)

          opts = options.merge({ :root =&gt; children })

          options[:builder].tag!(root) { each { |e| e.to_xml(opts.merge!({ :skip_instruct =&gt; true })) } }
        end

      end
    end
  end
end
</pre>
    </div>