  <div id="fileHeader">
    <h1>conversions.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>activesupport/lib/active_support/core_ext/hash/conversions.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Wed Oct 10 22:56:58 -0700 2007</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>require 'date'
require 'xml_simple'
require 'cgi'
 
# Extensions needed for Hash#to_query
class Object
  def to_param #:nodoc:
    to_s
  end

  def to_query(key) #:nodoc:
    &quot;#{CGI.escape(key.to_s)}=#{CGI.escape(to_param.to_s)}&quot;
  end
end

class Array
  def to_query(key) #:nodoc:
    collect { |value| value.to_query(&quot;#{key}[]&quot;) }.sort * '&amp;'
  end
end

# Locked down XmlSimple#xml_in_string
class XmlSimple
  # Same as xml_in but doesn't try to smartly shoot itself in the foot.
  def xml_in_string(string, options = nil)
    handle_options('in', options)

    @doc = parse(string)
    result = collapse(@doc.root)

    if @options['keeproot']
      merge({}, @doc.root.name, result)
    else
      result
    end
  end

  def self.xml_in_string(string, options = nil)
    new.xml_in_string(string, options)
  end
end

module ActiveSupport #:nodoc:
  module CoreExtensions #:nodoc:
    module Hash #:nodoc:
      module Conversions
        XML_TYPE_NAMES = {
          &quot;Fixnum&quot;     =&gt; &quot;integer&quot;,
          &quot;Bignum&quot;     =&gt; &quot;integer&quot;,
          &quot;BigDecimal&quot; =&gt; &quot;numeric&quot;,
          &quot;Float&quot;      =&gt; &quot;float&quot;,
          &quot;Date&quot;       =&gt; &quot;date&quot;,
          &quot;DateTime&quot;   =&gt; &quot;datetime&quot;,
          &quot;Time&quot;       =&gt; &quot;datetime&quot;,
          &quot;TrueClass&quot;  =&gt; &quot;boolean&quot;,
          &quot;FalseClass&quot; =&gt; &quot;boolean&quot;
        } unless defined? XML_TYPE_NAMES

        XML_FORMATTING = {
          &quot;date&quot;     =&gt; Proc.new { |date| date.to_s(:db) },
          &quot;datetime&quot; =&gt; Proc.new { |time| time.xmlschema },
          &quot;binary&quot;   =&gt; Proc.new { |binary| Base64.encode64(binary) }
        } unless defined? XML_FORMATTING

        def self.included(klass)
          klass.extend(ClassMethods)
        end

        def to_query(namespace = nil)
          collect do |key, value|
            value.to_query(namespace ? &quot;#{namespace}[#{key}]&quot; : key)
          end.sort * '&amp;'
        end

        def to_xml(options = {})
          options[:indent] ||= 2
          options.reverse_merge!({ :builder =&gt; Builder::XmlMarkup.new(:indent =&gt; options[:indent]),
                                   :root =&gt; &quot;hash&quot; })
          options[:builder].instruct! unless options.delete(:skip_instruct)
          dasherize = !options.has_key?(:dasherize) || options[:dasherize]
          root = dasherize ? options[:root].to_s.dasherize : options[:root].to_s

          options[:builder].__send__(:method_missing, root) do
            each do |key, value|
              case value
                when ::Hash
                  value.to_xml(options.merge({ :root =&gt; key, :skip_instruct =&gt; true }))
                when ::Array
                  value.to_xml(options.merge({ :root =&gt; key, :children =&gt; key.to_s.singularize, :skip_instruct =&gt; true}))
                when ::Method, ::Proc
                  # If the Method or Proc takes two arguments, then
                  # pass the suggested child element name.  This is
                  # used if the Method or Proc will be operating over
                  # multiple records and needs to create an containing
                  # element that will contain the objects being
                  # serialized.
                  if 1 == value.arity
                    value.call(options.merge({ :root =&gt; key, :skip_instruct =&gt; true }))
                  else
                    value.call(options.merge({ :root =&gt; key, :skip_instruct =&gt; true }), key.to_s.singularize)
                  end
                else
                  if value.respond_to?(:to_xml)
                    value.to_xml(options.merge({ :root =&gt; key, :skip_instruct =&gt; true }))
                  else
                    type_name = XML_TYPE_NAMES[value.class.name]

                    key = dasherize ? key.to_s.dasherize : key.to_s

                    attributes = options[:skip_types] || value.nil? || type_name.nil? ? { } : { :type =&gt; type_name }
                    if value.nil?
                      attributes[:nil] = true
                    end

                    options[:builder].tag!(key,
                      XML_FORMATTING[type_name] ? XML_FORMATTING[type_name].call(value) : value,
                      attributes
                    )
                end
              end
            end
          end

        end

        module ClassMethods
          def from_xml(xml)
            # TODO: Refactor this into something much cleaner that doesn't rely on XmlSimple
            undasherize_keys(typecast_xml_value(XmlSimple.xml_in_string(xml,
              'forcearray'   =&gt; false,
              'forcecontent' =&gt; true,
              'keeproot'     =&gt; true,
              'contentkey'   =&gt; '__content__')
            ))
          end

          def create_from_xml(xml)
            ActiveSupport::Deprecation.warn(&quot;Hash.create_from_xml has been renamed to Hash.from_xml&quot;, caller)
            from_xml(xml)
          end

          private
            def typecast_xml_value(value)
              case value.class.to_s
                when &quot;Hash&quot;
                  if value.has_key?(&quot;__content__&quot;)
                    content = translate_xml_entities(value[&quot;__content__&quot;])
                    case value[&quot;type&quot;]
                      when &quot;integer&quot;  then content.to_i
                      when &quot;boolean&quot;  then content.strip == &quot;true&quot;
                      when &quot;datetime&quot; then ::Time.parse(content).utc
                      when &quot;date&quot;     then ::Date.parse(content)
                      else                 content
                    end
                  else
                    (value.blank? || value['type'] || value['nil'] == 'true') ? nil : value.inject({}) do |h,(k,v)|
                      h[k] = typecast_xml_value(v)
                      h
                    end
                  end
                when &quot;Array&quot;
                  value.map! { |i| typecast_xml_value(i) }
                  case value.length
                    when 0 then nil
                    when 1 then value.first
                    else value
                  end
                when &quot;String&quot;
                  value
                else
                  raise &quot;can't typecast #{value.inspect}&quot;
              end
            end

            def translate_xml_entities(value)
              value.gsub(/&amp;lt;/,   &quot;&lt;&quot;).
                    gsub(/&amp;gt;/,   &quot;&gt;&quot;).
                    gsub(/&amp;quot;/, '&quot;').
                    gsub(/&amp;apos;/, &quot;'&quot;).
                    gsub(/&amp;amp;/,  &quot;&amp;&quot;)
            end

            def undasherize_keys(params)
              case params.class.to_s
                when &quot;Hash&quot;
                  params.inject({}) do |h,(k,v)|
                    h[k.to_s.tr(&quot;-&quot;, &quot;_&quot;)] = undasherize_keys(v)
                    h
                  end
                when &quot;Array&quot;
                  params.map { |v| undasherize_keys(v) }
                else
                  params
              end
            end
        end
      end
    end
  end
end
</pre>
    </div>