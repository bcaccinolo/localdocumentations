  <div id="fileHeader">
    <h1>utils.rb</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>actionmailer/lib/action_mailer/vendor/tmail/utils.rb
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sat Oct 15 18:40:03 -0700 2005</td>
    </tr>
    </table>
  </div>
 <!-- banner header -->

  <div id="bodyContent" >
    <h2>Source Code</h2>
    <pre>#
# utils.rb
#
#--
# Copyright (c) 1998-2003 Minero Aoki &lt;aamine@loveruby.net&gt;
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# &quot;Software&quot;), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Note: Originally licensed under LGPL v2+. Using MIT license for Rails
# with permission of Minero Aoki.
#++

module TMail

  class SyntaxError &lt; StandardError; end


  def TMail.new_boundary
    'mimepart_' + random_tag
  end

  def TMail.new_message_id( fqdn = nil )
    fqdn ||= ::Socket.gethostname
    &quot;&lt;#{random_tag()}@#{fqdn}.tmail&gt;&quot;
  end

  def TMail.random_tag
    @uniq += 1
    t = Time.now
    sprintf('%x%x_%x%x%d%x',
            t.to_i, t.tv_usec,
            $$, Thread.current.object_id, @uniq, rand(255))
  end
  private_class_method :random_tag

  @uniq = 0


  module TextUtils

    aspecial     = '()&lt;&gt;[]:;.\\,&quot;'
    tspecial     = '()&lt;&gt;[];:\\,&quot;/?='
    lwsp         = &quot; \t\r\n&quot;
    control      = '\x00-\x1f\x7f-\xff'

    ATOM_UNSAFE   = /[#{Regexp.quote aspecial}#{control}#{lwsp}]/n
    PHRASE_UNSAFE = /[#{Regexp.quote aspecial}#{control}]/n
    TOKEN_UNSAFE  = /[#{Regexp.quote tspecial}#{control}#{lwsp}]/n
    CONTROL_CHAR  = /[#{control}]/n

    def atom_safe?( str )
      not ATOM_UNSAFE === str
    end

    def quote_atom( str )
      (ATOM_UNSAFE === str) ? dquote(str) : str
    end

    def quote_phrase( str )
      (PHRASE_UNSAFE === str) ? dquote(str) : str
    end

    def token_safe?( str )
      not TOKEN_UNSAFE === str
    end

    def quote_token( str )
      (TOKEN_UNSAFE === str) ? dquote(str) : str
    end

    def dquote( str )
      '&quot;' + str.gsub(/[&quot;\\]/n) {|s| '\\' + s } + '&quot;'
    end
    private :dquote


    def join_domain( arr )
      arr.map {|i|
          if /\A\[.*\]\z/ === i
            i
          else
            quote_atom(i)
          end
      }.join('.')
    end


    ZONESTR_TABLE = {
      'jst' =&gt;   9 * 60,
      'eet' =&gt;   2 * 60,
      'bst' =&gt;   1 * 60,
      'met' =&gt;   1 * 60,
      'gmt' =&gt;   0,
      'utc' =&gt;   0,
      'ut'  =&gt;   0,
      'nst' =&gt; -(3 * 60 + 30),
      'ast' =&gt;  -4 * 60,
      'edt' =&gt;  -4 * 60,
      'est' =&gt;  -5 * 60,
      'cdt' =&gt;  -5 * 60,
      'cst' =&gt;  -6 * 60,
      'mdt' =&gt;  -6 * 60,
      'mst' =&gt;  -7 * 60,
      'pdt' =&gt;  -7 * 60,
      'pst' =&gt;  -8 * 60,
      'a'   =&gt;  -1 * 60,
      'b'   =&gt;  -2 * 60,
      'c'   =&gt;  -3 * 60,
      'd'   =&gt;  -4 * 60,
      'e'   =&gt;  -5 * 60,
      'f'   =&gt;  -6 * 60,
      'g'   =&gt;  -7 * 60,
      'h'   =&gt;  -8 * 60,
      'i'   =&gt;  -9 * 60,
      # j not use
      'k'   =&gt; -10 * 60,
      'l'   =&gt; -11 * 60,
      'm'   =&gt; -12 * 60,
      'n'   =&gt;   1 * 60,
      'o'   =&gt;   2 * 60,
      'p'   =&gt;   3 * 60,
      'q'   =&gt;   4 * 60,
      'r'   =&gt;   5 * 60,
      's'   =&gt;   6 * 60,
      't'   =&gt;   7 * 60,
      'u'   =&gt;   8 * 60,
      'v'   =&gt;   9 * 60,
      'w'   =&gt;  10 * 60,
      'x'   =&gt;  11 * 60,
      'y'   =&gt;  12 * 60,
      'z'   =&gt;   0 * 60
    }

    def timezone_string_to_unixtime( str )
      if m = /([\+\-])(\d\d?)(\d\d)/.match(str)
        sec = (m[2].to_i * 60 + m[3].to_i) * 60
        m[1] == '-' ? -sec : sec
      else
        min = ZONESTR_TABLE[str.downcase] or
                raise SyntaxError, &quot;wrong timezone format '#{str}'&quot;
        min * 60
      end
    end


    WDAY = %w( Sun Mon Tue Wed Thu Fri Sat TMailBUG )
    MONTH = %w( TMailBUG Jan Feb Mar Apr May Jun
                         Jul Aug Sep Oct Nov Dec TMailBUG )

    def time2str( tm )
      # [ruby-list:7928]
      gmt = Time.at(tm.to_i)
      gmt.gmtime
      offset = tm.to_i - Time.local(*gmt.to_a[0,6].reverse).to_i

      # DO NOT USE strftime: setlocale() breaks it
      sprintf '%s, %s %s %d %02d:%02d:%02d %+.2d%.2d',
              WDAY[tm.wday], tm.mday, MONTH[tm.month],
              tm.year, tm.hour, tm.min, tm.sec,
              *(offset / 60).divmod(60)
    end


    MESSAGE_ID = /&lt;[^\@&gt;]+\@[^&gt;\@]+&gt;/

    def message_id?( str )
      MESSAGE_ID === str
    end


    MIME_ENCODED = /=\?[^\s?=]+\?[QB]\?[^\s?=]+\?=/i

    def mime_encoded?( str )
      MIME_ENCODED === str
    end
  

    def decode_params( hash )
      new = Hash.new
      encoded = nil
      hash.each do |key, value|
        if m = /\*(?:(\d+)\*)?\z/.match(key)
          ((encoded ||= {})[m.pre_match] ||= [])[(m[1] || 0).to_i] = value
        else
          new[key] = to_kcode(value)
        end
      end
      if encoded
        encoded.each do |key, strings|
          new[key] = decode_RFC2231(strings.join(''))
        end
      end

      new
    end

    NKF_FLAGS = {
      'EUC'  =&gt; '-e -m',
      'SJIS' =&gt; '-s -m'
    }

    def to_kcode( str )
      flag = NKF_FLAGS[$KCODE] or return str
      NKF.nkf(flag, str)
    end

    RFC2231_ENCODED = /\A(?:iso-2022-jp|euc-jp|shift_jis|us-ascii)?'[a-z]*'/in

    def decode_RFC2231( str )
      m = RFC2231_ENCODED.match(str) or return str
      begin
        NKF.nkf(NKF_FLAGS[$KCODE],
        m.post_match.gsub(/%[\da-f]{2}/in) {|s| s[1,2].hex.chr })
      rescue
        m.post_match.gsub(/%[\da-f]{2}/in, &quot;&quot;)
      end
    end

  end

end
</pre>
    </div>